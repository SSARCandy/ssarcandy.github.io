<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SSARCandy</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://ssarcandy.tw/"/>
  <updated>2016-12-17T19:12:41.582Z</updated>
  <id>https://ssarcandy.tw/</id>
  
  <author>
    <name>許書軒</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>pbrt - 用多點光源模擬環境光</title>
    <link href="https://ssarcandy.tw/2016/12/17/pbrt-mediancut-environment-light/"/>
    <id>https://ssarcandy.tw/2016/12/17/pbrt-mediancut-environment-light/</id>
    <published>2016-12-17T17:45:08.000Z</published>
    <updated>2016-12-17T19:12:41.582Z</updated>
    
    <content type="html"><![CDATA[<p>環境中總有一些背景光，像是太陽光、遠處大樓窗戶反光之類的，可以看成一整片不均勻分布的光源，有些地方亮；有些地方暗。<br>pbrt 中是用 important sampling 來渲染環境光，不過，其實也可以把環境光轉換成一堆點光源來計算。</p>
<p><img src="/img/2016-12-18/1.jpg" alt=""><br><a id="more"></a><br><img src="/img/2016-12-18/4.jpg"alt=" 不同的環境光會讓場景中物件有不同的渲染結果[1]"><span class="image-caption"> 不同的環境光會讓場景中物件有不同的渲染結果[1]</span></p>
<h1 id="Median-Cut-Alogrithm"><a href="#Median-Cut-Alogrithm" class="headerlink" title="Median Cut Alogrithm"></a>Median Cut Alogrithm</h1><p>直接來看一張圖:</p>
<p><img src="/img/2016-12-18/2.jpg" alt="用 median-cut algorithm 把環境光轉成多點光源[2]"><span class="image-caption">用 median-cut algorithm 把環境光轉成多點光源[2]</span></p>
<p>事實上這方法很簡單，就是將整張 environment light probe 切成 x 塊相同能量的區塊(x 是多少開心就好~)，整個邏輯可以分成幾步驟:</p>
<ol>
<li>初始狀態 = 整張 env light probe 影像（陣列中只有一個區域）</li>
<li>對於每個區域，沿著長邊切成兩塊一樣能量的區塊</li>
<li>如果區塊少於 x ，則繼續做 2.</li>
<li>把點光源放在每個區域中的能量重心處</li>
</ol>
<h1 id="計算能量重心"><a href="# 計算能量重心" class="headerlink" title="計算能量重心"></a>計算能量重心 </h1><p> 能量重心計算其實就是 x, y 軸分別加權平均（權重為點能量）<br>點能量計算方式可以根據 RGB channel 加權平均來計算<br>eg. Y = 0.2125R + 0.7154G + 0.0721B 之類的加權法</p>
<h1 id="計算區塊能量"><a href="# 計算區塊能量" class="headerlink" title="計算區塊能量"></a>計算區塊能量 </h1><p> 直覺的想法其實就是這區塊中所有點能量和就是這區塊能量了。<br>不過在做 Median-cut 時期時會不斷需要計算區塊的能量，用這種暴力解會使效能突破天際的差。<br>這邊可以利用預先計算 environment light probe 的能量 Sum Area Table(簡稱 SAT)，概念很簡單:<br>一開始先維護一個能量累積的二維陣列，每個點的值就是其左上角區塊的能量和，藉由這個陣列可以使獲得任意區塊能量的時間複雜度為 O(1)。</p>
<p><img src="/img/2016-12-18/3.jpg" alt="這張圖說明了若要獲得紅色區塊能量和，只需查表四次，計算 D-B-C+A 即可得出。"><span class="image-caption">這張圖說明了若要獲得紅色區塊能量和，只需查表四次，計算 D-B-C+A 即可得出。</span></p>
<h1 id="結果"><a href="# 結果" class="headerlink" title="結果"></a>結果 </h1><p> 渲染出來的結果其實跟原本的環境光還是有些差別，畢竟是用多點光源來模擬環境光，本來就不會一模一樣。</p>
<p><img src="/img/2016-12-18/new-256-my.jpg" alt="Median cut algorithm"><span class="image-caption">Median cut algorithm</span><br><img src="/img/2016-12-18/new-256.jpg" alt="Important sampling(original)"><span class="image-caption">Important sampling(original)</span></p>
<p>不過在效能方面，用多點光源模擬所需要的運算時間大概都只有原本算法的 30% ，可以說是大幅加速了!</p>
<h1 id="雜談"><a href="# 雜談" class="headerlink" title="雜談"></a>雜談</h1><ul>
<li>這次中間卡了一周跑去 SIGGRAPH ASIA，由於我懶沒帶電腦去，所以也就稍微趕了一點…(幸好這次比較簡單一點點…哈哈)</li>
<li>我學乖了，用 cmlab 工作站跑 pbrt 整個就是舒爽，Enter 按下去差不多就算完了~</li>
<li>GA 累積人次快突破 5000 瀏覽了，不過發現還真的有人在看我的文章還是覺得很特別~ 哈哈</li>
<li>之前 group meeting 座前面學長一直在看我的 <a href="https://ssarcandy.tw/2016/11/09/pbrt-realistic-camera/">realist-camera</a>，害我注意力都被吸走了 XD</li>
</ul>
<hr>
<p>註:<br>[1] 原圖來自 Physically Based Rendering, Second Edition<br>[2] 原圖來自 A Median Cut Algorithm for Light Probe Sampling, SIGGRAPH 2006</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;環境中總有一些背景光，像是太陽光、遠處大樓窗戶反光之類的，可以看成一整片不均勻分布的光源，有些地方亮；有些地方暗。&lt;br&gt;pbrt 中是用 important sampling 來渲染環境光，不過，其實也可以把環境光轉換成一堆點光源來計算。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/img/2016-12-18/1.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="pbrt" scheme="https://ssarcandy.tw/tags/pbrt/"/>
    
      <category term="c++" scheme="https://ssarcandy.tw/tags/c/"/>
    
      <category term="rendering" scheme="https://ssarcandy.tw/tags/rendering/"/>
    
  </entry>
  
  <entry>
    <title>用 Facebook 聊天機器人當通知系統</title>
    <link href="https://ssarcandy.tw/2016/11/17/cml-fb-bot/"/>
    <id>https://ssarcandy.tw/2016/11/17/cml-fb-bot/</id>
    <published>2016-11-17T11:57:17.000Z</published>
    <updated>2016-12-17T19:12:41.582Z</updated>
    
    <content type="html"><![CDATA[<p>CMLab 有二十幾台 unix work stations 供大家使用 (據說 CMLab 的工作站比資工系工作站還要好…)。<br> 雖然這些機器設備都很強悍，但還是有時候會出現某台機器掛掉，或是 CPU, Memory, Swap 用量過高之類的事件。若有這類事發生就必須去處理，不然一直讓機器維持在高負載很容易就死掉了。<br>實驗室有個 <a href="https://www.cmlab.csie.ntu.edu.tw/status/" target="_blank" rel="external">網站</a> 可以查看機器及時狀態，什麼機器有什麼問題一看就知道，超方便的。</p>
<p>但是不上去看就不會知道有沒有狀況，所以我就決定做個有狀況發生就通知我的 Facebook chat bot。</p>
<a id="more"></a>
<h2 id="爬網頁"><a href="# 爬網頁" class="headerlink" title="爬網頁"></a>爬網頁 </h2><p> 最簡單的方式莫過於把網站的內容爬下來，如果有高負載或死機就通知我。<br>我用 nodejs <a href="https://github.com/request/request" target="_blank" rel="external">request</a> 來完成這件事。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> request = <span class="built_in">require</span>(<span class="string">'request'</span>);</div><div class="line">request(<span class="string">'https://www.cmlab.csie.ntu.edu.tw/status/'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">error, response, body</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(body) <span class="comment">// Show the HTML</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h2 id="facebook-chat-api"><a href="#facebook-chat-api" class="headerlink" title="facebook-chat-api"></a>facebook-chat-api</h2><p><a href="https://github.com/Schmavery/facebook-chat-api" target="_blank" rel="external">facebook-chat-api</a> 可以很容易的操作聊天室相關的行為，我利用這套件來達成通知自己。<br>將爬下來的網頁內容，找出掛掉的機器，配合 <a href="https://github.com/Schmavery/facebook-chat-api" target="_blank" rel="external">facebook-chat-api</a> 就可以用 fb 通知有機器掛掉了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// require modules</span></div><div class="line"> </div><div class="line"><span class="keyword">let</span> deadMachines = [];</div><div class="line">request(<span class="string">'http://www.cmlab.csie.ntu.edu.tw/status/'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, res, body</span>) </span>&#123;</div><div class="line">    <span class="keyword">const</span> $ = cheerio.load(body);</div><div class="line">    <span class="keyword">const</span> dead = $(<span class="string">'.dead'</span>);</div><div class="line"> </div><div class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; dead.length; i++) &#123;</div><div class="line">        <span class="keyword">const</span> machineId = dead.eq(i).text();</div><div class="line">        deadMachines.push(machineId);</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="comment">// all machines are fine~</span></div><div class="line">    <span class="keyword">if</span> (!deadMachines.length) <span class="keyword">return</span>;</div><div class="line"> </div><div class="line">    <span class="comment">// login to facebook and send msg to unix manager</span></div><div class="line">    loginFacebook(config.account, <span class="function"><span class="keyword">function</span> (<span class="params">err, api</span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span> (err) <span class="keyword">return</span> <span class="built_in">console</span>.error(err);</div><div class="line"> </div><div class="line">        api.sendMessage(<span class="string">`<span class="subst">$&#123;deadMachines.toString()&#125;</span> is dead.`</span>, <span class="comment">/* channel_id */</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</div><div class="line">            <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;deadMachines.toString()&#125;</span> is dead.`</span>);</div><div class="line">        &#125;);</div><div class="line">    &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<div><img src="/img/2016-11-17/1.png" alt="透過 Facebook 聊天室告知我有機器掛掉了。"><span class="image-caption">透過 Facebook 聊天室告知我有機器掛掉了。</span></div>

<h2 id="定時檢查"><a href="# 定時檢查" class="headerlink" title="定時檢查"></a>定時檢查 </h2><p> 這隻程式並不是個持續監控的程式，只能算是個 script 而已。所以我用 <code>crontab</code> 設定排程定時檢查機器是不是有狀況。<br>利用 unix 指令 <code>crontab -e</code> 編輯排程。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 每小時執行程式</span></div><div class="line">0 * * * * node index.js</div></pre></td></tr></table></figure>
<p>crontab 是吃 localtime，系統現在是甚麼時間可以藉由 <code>timedatectl</code> 查看:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ timedatectl</div><div class="line">      Local time: Thu 2016-11-17 22:15:13 CST</div><div class="line">  Universal time: Thu 2016-11-17 14:15:13 UTC</div><div class="line">        RTC time: n/a</div><div class="line">       Time zone: Asia/Taipei (CST, +0800)</div><div class="line"> Network time on: yes</div><div class="line">NTP synchronized: yes</div><div class="line"> RTC <span class="keyword">in</span> <span class="built_in">local</span> TZ: no</div></pre></td></tr></table></figure>
<p>另外，如果設定了新的 Time Zone，則必須重啟 crontab service 才會讓他吃到正確的時間。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ /etc/init.d/cron restart</div></pre></td></tr></table></figure>
<h2 id="截圖"><a href="# 截圖" class="headerlink" title="截圖"></a>截圖 </h2><p> 直到現在其實已經達成目標了，但是只講句「某某機器掛了。」似乎還是差強人意，為了防範未然，應該要把高負載的機器也告知一下，提早處理以免機器死掉。<br>想想感覺把整個網站截圖下來傳給我不是最快嗎。<br>恩，那就這樣弄吧！</p>
<p>多虧廣大 nodejs 套件開發者，這件事可以很容易地利用 <a href="https://github.com/brenden/node-webshot" target="_blank" rel="external">webshot</a> 達成。</p>
<div><img src="/img/2016-11-17/2.png" alt="截下整個表格傳給我。"><span class="image-caption">截下整個表格傳給我。</span></div>

<h2 id="Callback-to-Promise"><a href="#Callback-to-Promise" class="headerlink" title="Callback to Promise"></a>Callback to Promise</h2><p>爬網頁、截圖、傳訊息都是非同步的動作，寫起來就變成 Callback Hell 了。<br>真的是醜爆了…</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Scrap web</span></div><div class="line">request(<span class="string">'url'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, res, body</span>) </span>&#123;</div><div class="line">    <span class="comment">/* do something with 'body' */</span></div><div class="line">    <span class="comment">// Screenshot</span></div><div class="line">    webshot(body, <span class="string">'tmp.png'</span>, options, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</div><div class="line">        <span class="comment">// login to facebook and send msg</span></div><div class="line">        loginFacebook(config.account, <span class="function"><span class="keyword">function</span> (<span class="params">err, api</span>) </span>&#123;</div><div class="line">            <span class="comment">// send message</span></div><div class="line">        &#125;);</div><div class="line">    &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>利用 <a href="http://bluebirdjs.com/docs/getting-started.html" target="_blank" rel="external">bluebird</a>，可以把 Callback 神奇的轉為 Promise，<br>並且用 es6 的語法改寫，就可以大幅改善程式碼的易讀性～</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">request(<span class="string">'url'</span>)</div><div class="line">    .then(<span class="function"><span class="params">body</span> =&gt;</span> &#123;</div><div class="line">        <span class="comment">/* do something with 'body' */</span></div><div class="line">        <span class="comment">// Screenshot</span></div><div class="line">        <span class="keyword">return</span> webshot(body, <span class="string">'tmp.png'</span>, options);</div><div class="line">    &#125;)</div><div class="line">    .then(<span class="function"><span class="params">()</span> =&gt;</span> loginFacebook(config.account)) <span class="comment">// login to facebook and send msg</span></div><div class="line">    .then(<span class="function"><span class="params">api</span> =&gt;</span> &#123;</div><div class="line">        <span class="comment">// send message</span></div><div class="line">    &#125;)</div><div class="line">    .catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.error(err));</div></pre></td></tr></table></figure>
<p>完整的程式碼: <a href="https://github.com/SSARCandy/cml-status-fb-notify" target="_blank" rel="external">https://github.com/SSARCandy/cml-status-fb-notify</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;CMLab 有二十幾台 unix work stations 供大家使用(據說 CMLab 的工作站比資工系工作站還要好…)。&lt;br&gt;雖然這些機器設備都很強悍，但還是有時候會出現某台機器掛掉，或是 CPU, Memory, Swap 用量過高之類的事件。若有這類事發生就必須去處理，不然一直讓機器維持在高負載很容易就死掉了。&lt;br&gt;實驗室有個 &lt;a href=&quot;https://www.cmlab.csie.ntu.edu.tw/status/&quot;&gt;網站&lt;/a&gt; 可以查看機器及時狀態，什麼機器有什麼問題一看就知道，超方便的。&lt;/p&gt;
&lt;p&gt;但是不上去看就不會知道有沒有狀況，所以我就決定做個有狀況發生就通知我的 Facebook chat bot。&lt;/p&gt;
    
    </summary>
    
    
      <category term="nodejs" scheme="https://ssarcandy.tw/tags/nodejs/"/>
    
      <category term="unix" scheme="https://ssarcandy.tw/tags/unix/"/>
    
  </entry>
  
  <entry>
    <title>Realistic camera in pbrt</title>
    <link href="https://ssarcandy.tw/2016/11/09/pbrt-realistic-camera/"/>
    <id>https://ssarcandy.tw/2016/11/09/pbrt-realistic-camera/</id>
    <published>2016-11-09T05:14:41.000Z</published>
    <updated>2016-12-17T19:12:41.582Z</updated>
    
    <content type="html"><![CDATA[<p>Ray-tracing 中的相機 (眼睛) 是所有光束的起點，從相機成像平面出發的光束如果能夠經由折射、反射等等最終到達光源的那些「存活」的光束，才對最終的影像有影響的光束。這種與現實物理相反的設計 (從光源發出光並追蹤那些存活到相機成像平面的光束) 是為了減少計算量。<br><img src="/img/2016-11-09/01.png" alt="ray-tracing 中，光束是從相機射出來的。[1]"><span class="image-caption">ray-tracing 中，光束是從相機射出來的。[1]</span></p>
<a id="more"></a>
<h1 id="實作真實相機光學系統"><a href="# 實作真實相機光學系統" class="headerlink" title="實作真實相機光學系統"></a>實作真實相機光學系統 </h1><p> 相機的光學系統決定了最終成像的樣貌，比如廣角、魚眼、正交投影等等樣貌， <a href="https://github.com/mmp/pbrt-v2" target="_blank" rel="external">pbrt-v2</a> 中實做了最常見的幾個，包含了 perspective camera, orthographic camera，原始程式碼在 <code>src/camera</code> 之下。</p>
<p>實際上的相機的光學系統通常都包含了多個透鏡，以此來達成比較複雜的成像(或是減少透鏡的像差)。<br><img src="/img/2016-11-09/02.png" alt="真實相機通常都是由多片透鏡組成的光學系統。[2]"><span class="image-caption">真實相機通常都是由多片透鏡組成的光學系統。[2]</span></p>
<p>上圖是描述光學系統各個透鏡面的相關參數，從成像平面出發的 eye-ray 會在這個光學系統折射多次之後才會進入場景中，而這些光束又會跟場景的物件相交、反射等等，就如同 <a href="https://ssarcandy.tw/2016/10/10/pbrt-heightfield/"> 這篇 </a> 在做的事。</p>
<p>所以，要模擬真實相機的光學系統，其實就是幾個步驟：</p>
<ol>
<li>在成像平面上與第一個透鏡面上各取一點，相連產生 eye-ray</li>
<li>找出 eye-ray 與第一個透鏡面的交點，沒交點就結束</li>
<li>找出折射後的新 eye-ray</li>
<li>重覆 2, 3 直到 eye-ray 離開光學系統進入場景為止</li>
</ol>
<p>以 pseudo-code 表示，大概可以寫成這樣：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">filmP = random point on film</div><div class="line">lensP = random point on first lens</div><div class="line">ray.o = filmP</div><div class="line">ray.d = Vector(lensP - originP)</div><div class="line">  </div><div class="line"><span class="keyword">for</span> l <span class="keyword">in</span> lens:  <span class="comment"># from rear to front</span></div><div class="line">  intersectionP = l.intersect(ray)</div><div class="line">  <span class="keyword">if</span> <span class="keyword">not</span> intersectionP:</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span></div><div class="line">  </div><div class="line">  newDirection = l.refractRay(ray)</div><div class="line">  <span class="keyword">if</span> <span class="keyword">not</span> newDirection:</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span></div><div class="line">  </div><div class="line">  ray.d = newDirection</div></pre></td></tr></table></figure>
<hr>
<p>其實也可以借助一些除錯工具來視覺化光束的折射行為，這邊我使用 vdb 來畫出整個光學系統並且追蹤光束的折射行為。<br>(關於如何利用 vdb 除錯，可以參考 <a href="https://ssarcandy.tw/2016/10/13/debug-using-vdb/"> 這篇</a>。)<br><img src="/img/2016-11-09/03.png" alt="pbrt 模擬從成像平面中點發出光束，經過多次折射直至離開相機鏡頭。"><span class="image-caption">pbrt 模擬從成像平面中點發出光束，經過多次折射直至離開相機鏡頭。</span></p>
<p>除此之外，也需要計算每條 ray 的權重，根據論文 [2] 所說是如下公式：</p>
<p>$E = A\frac{cos^4\theta}{Z^2}$</p>
<p>$A$: 出射瞳面積<br>$Z$: 最後透鏡與成像平面的距離<br>$\theta$: 光束與成像平面法向量夾角</p>
<h1 id="結果"><a href="# 結果" class="headerlink" title="結果"></a>結果 </h1><p> 我嘗試渲染大張一點的圖並且讓每個像素的採樣夠多次，希望能夠讓結果圖漂亮一點。<br>代價就是一張圖要跑好幾個小時……</p>
<p><img src="/img/2016-11-09/05.png" alt="dobule-gauss 50mm with 512 samples per pixel(1024*1024)"><span class="image-caption">dobule-gauss 50mm with 512 samples per pixel(1024*1024)</span><br><img src="/img/2016-11-09/06.png" alt="wide 22mm with 512 samples per pixel(1024*1024)"><span class="image-caption">wide 22mm with 512 samples per pixel(1024*1024)</span><br><img src="/img/2016-11-09/07.png" alt="telephoto 250mm with 512 samples per pixel(1024*1024)"><span class="image-caption">telephoto 250mm with 512 samples per pixel(1024*1024)</span><br><img src="/img/2016-11-09/08.png" alt="fisheye 10mm with 512 samples per pixel(1024*1024)"><span class="image-caption">fisheye 10mm with 512 samples per pixel(1024*1024)</span></p>
<h1 id="加速"><a href="# 加速" class="headerlink" title="加速"></a>加速 </h1><p> 每個透鏡面基本上是以部份的球面來模擬，要求交點很容易，因為 <code>src/shape/shpere.cpp</code> 已經實做求交點了，可以直接創一個 Sphere object ，然後再 <code>s.Intersect(r, &amp;thit, &amp;rayEpsilon, &amp;dg)</code> 來取得交點。</p>
<p>這樣寫簡單易懂，三兩下解決求交點這件事，但其實效能並不好，因為只為了求一個交點卻建構了一個完整的 shpere shape ，稍微有點浪費……</p>
<p>改善方式可以藉由複製貼上 <code>Shpere::Intersect()</code> 並加以改寫，就可以省去這樣的 overhead<br>實際上效能大約差 2 倍。</p>
<h1 id="各種坑"><a href="# 各種坑" class="headerlink" title="各種坑"></a>各種坑</h1><ul>
<li><strong>RasterToCamera</strong><br>在 <code>GenerateRay()</code> 中，<code>sample.imageX</code> <code>sample.imageY</code> 是在 Raster space 上，需轉至 Camera space，Raster/Camera space 之間關係如圖(省略 z 軸)，可以看出來轉換方式大概就是：上下翻轉、平移、縮小。<br><img src="/img/2016-11-09/04.png" alt="Raster/Camera space 之間關係。"><span class="image-caption">Raster/Camera space 之間關係。</span></li>
<li><strong>Ray minT, maxT</strong><br>在 <code>GenerateRay()</code> 中產生的 ray 記得參數要給好給滿，之前因為沒給值到 min/maxT 導致結果有坑坑巴巴的破圖…</li>
<li><strong>Total reflection</strong><br>我使用 <a href="https://www.wikiwand.com/en/Snell&#39;s_law" target="_blank" rel="external">Snell’s law</a> 計算折射後的新方向，在公式中，若發生全反射時會讓其中一項產生虛數，程式就整個爆炸了。<br>所以記得要注意別把負數開根號了。</li>
</ul>
<hr>
<p> 註:<br> [1]: 圖片取自維基百科 <a href="https://www.wikiwand.com/en/Ray_tracing_(graphics" target="_blank" rel="external">Ray-tracing</a>)<br> [2]: A Realistic Camera Model for Computer Graphics, SIGGRAPH 1995</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Ray-tracing 中的相機(眼睛)是所有光束的起點，從相機成像平面出發的光束如果能夠經由折射、反射等等最終到達光源的那些「存活」的光束，才對最終的影像有影響的光束。這種與現實物理相反的設計(從光源發出光並追蹤那些存活到相機成像平面的光束)是為了減少計算量。&lt;br&gt;&lt;img src=&quot;/img/2016-11-09/01.png&quot; alt=&quot;ray-tracing 中，光束是從相機射出來的。[1]&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="pbrt" scheme="https://ssarcandy.tw/tags/pbrt/"/>
    
      <category term="c++" scheme="https://ssarcandy.tw/tags/c/"/>
    
      <category term="rendering" scheme="https://ssarcandy.tw/tags/rendering/"/>
    
  </entry>
  
  <entry>
    <title>vdb - Debugging visual programs</title>
    <link href="https://ssarcandy.tw/2016/10/13/debug-using-vdb/"/>
    <id>https://ssarcandy.tw/2016/10/13/debug-using-vdb/</id>
    <published>2016-10-13T12:34:53.000Z</published>
    <updated>2016-12-17T19:12:41.582Z</updated>
    
    <content type="html"><![CDATA[<p>有時候在寫 <a href="https://www.opengl.org/" target="_blank" rel="external">openGL</a> 或者是類似 <a href="http://www.pbrt.org/" target="_blank" rel="external">pbrt</a> 這樣有牽涉到三維空間的程式的時候總是很難除錯…<br>雖然可以設斷點看看變數內容有沒有問題，但說實在的其實這樣看有時候根本看不出所以然，這樣還是難以除錯。</p>
<p><a href="https://github.com/zdevito/vdb" target="_blank" rel="external">vdb</a> 是一個解決這樣問題的工具，它提供了很多常見的畫線、畫點等等函式，最重要的是他的易用性，可以在幾乎不更動程式碼的狀態下就完成偵錯。</p>
<a id="more"></a>
<h2 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h2><p>其實在 <a href="https://github.com/zdevito/vdb/blob/master/README.md" target="_blank" rel="external">vdb README</a> 已經說的滿清楚的了，這邊在整理一下:</p>
<ol>
<li>下載 <code>vdb-win.zip</code> 或 <code>vdb-osx.tar.gz</code></li>
<li>把 <code>vdb.h</code> include 進你要偵錯的程式</li>
<li>執行 <code>vdb.exe</code> 或 <code>./vdb</code></li>
<li>在要偵錯的程式中，可以在任何地方插入 <code>vdb_line()</code> 等他所提供的函式</li>
</ol>
<h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><p>以 pbrt 為例，由於結果都是一張渲染完成的影像，說實在的這真的很難 debug….<br>那利用 vdb 這工具能有甚麼好處呢？</p>
<p>藉由他，可以很容易地畫出像是物體的樣子以及他的 Bounding Box，如圖：<br><img src="/img/2016-10-13/1.png" alt="heightfield object and its bounding box"><span class="image-caption">heightfield object and its bounding box</span></p>
<hr>
<p>或者是當你在算 Vertex normal 時，不知道到底算的對不對，也可以直接畫出來：<br><img src="/img/2016-10-13/2.png" alt="Showing Normals on vertices"><span class="image-caption">Showing Normals on vertices</span></p>
<hr>
<p>我個人覺得 vdb 對我最大的幫助是 object space 以及 world space 之間的關係了，<br>坐標系一個沒弄好就會讓渲染的結果差異甚大，完全摸不著頭緒到底發生什麼事情…..</p>
<p>藉由 vdb 實際畫出各個 object 時候，很容易就發現 object/world space 之間的 bug<br><img src="/img/2016-10-13/3.png" alt="Bounding box 沒有正確的轉換到 object space，導致跑到怪怪的地方"><span class="image-caption">Bounding box 沒有正確的轉換到 object space，導致跑到怪怪的地方</span></p>
<h2 id="Some-tips"><a href="#Some-tips" class="headerlink" title="Some tips"></a>Some tips</h2><p>其實上面說的很簡單，但事實上我剛開始嘗試使用 vdb 時遇到了超多的問題，這邊就來記錄一下：</p>
<h5 id="Header-files-order"><a href="#Header-files-order" class="headerlink" title="Header files order"></a>Header files order</h5><p><code>#include &quot;vdb.h&quot;</code> 要擺在哪裡？一般來說當然越上面越好，但還是有例外的：</p>
<figure class="highlight cpp"><figcaption><span>heightfield.cpp</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdafx.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"vdb.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"shapes/heightfieldImproved.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"shapes/trianglemesh.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"paramset.h"</span></span></div></pre></td></tr></table></figure>
<p>以上面的例子來說，<code>#include &quot;vdb.h&quot;</code>必須放在 <code>#include &quot;stdafx.h&quot;</code>後面。<br><code>stdafx.h</code>是來做 precompiled headers 用的，所以置於他之前的 include 都會被忽略，就會造成找不到 <code>vdb_line()</code> 之類的錯誤。</p>
<h5 id="Use-ONE-thread"><a href="#Use-ONE-thread" class="headerlink" title="Use ONE thread"></a>Use ONE thread</h5><p>vdb 不支援多執行緒，如果在偵錯的程式是多執行緒的話，有可能會導致畫在 vdb 上的東西不正確 (漏畫)。<br> 解決方法就是在偵錯時使用單一執行緒。</p>
<h5 id="Using-winsock-instead-of-winsock2"><a href="#Using-winsock-instead-of-winsock2" class="headerlink" title="Using winsock instead of winsock2"></a>Using winsock instead of winsock2</h5><p>這問題應該是只在 Windows 會發生，並且在要偵錯的程式中使用到 <code>windows.h</code>。<br>vdb 中用到了 <code>winsock2.h</code>，這是跟 <code>socket</code> 有關的東西，<br>然而 <code>windows.h</code> 中也有 include 一個叫 <code>winsock.h</code> 的東西。<br><code>winsock.h</code>, <code>winsock2.h</code> 有很多函式都各自有宣告，而同時引用兩者會造成 <strong>redefinition</strong> 錯誤。</p>
<p>解決方法是把 <code>vdb.h</code> 中，<code>winsock2.h</code>改成 <code>winsock.h</code>。<br> 詳細可查看 <a href="http://stackoverflow.com/questions/39849684/header-correct-but-compile-erroridentifier-not-found" target="_blank" rel="external">stackoverflow 這篇</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有時候在寫 &lt;a href=&quot;https://www.opengl.org/&quot;&gt;openGL&lt;/a&gt; 或者是類似 &lt;a href=&quot;http://www.pbrt.org/&quot;&gt;pbrt&lt;/a&gt; 這樣有牽涉到三維空間的程式的時候總是很難除錯…&lt;br&gt;雖然可以設斷點看看變數內容有沒有問題，但說實在的其實這樣看有時候根本看不出所以然，這樣還是難以除錯。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/zdevito/vdb&quot;&gt;vdb&lt;/a&gt; 是一個解決這樣問題的工具，它提供了很多常見的畫線、畫點等等函式，最重要的是他的易用性，可以在幾乎不更動程式碼的狀態下就完成偵錯。&lt;/p&gt;
    
    </summary>
    
    
      <category term="pbrt" scheme="https://ssarcandy.tw/tags/pbrt/"/>
    
      <category term="c++" scheme="https://ssarcandy.tw/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>改善 pbrt 中的 heightfield shape</title>
    <link href="https://ssarcandy.tw/2016/10/10/pbrt-heightfield/"/>
    <id>https://ssarcandy.tw/2016/10/10/pbrt-heightfield/</id>
    <published>2016-10-10T13:14:41.000Z</published>
    <updated>2016-12-17T19:12:41.582Z</updated>
    
    <content type="html"><![CDATA[<p>pbrt 是一個基於物理的 ray-tracing libarary，他可以拿來產生接近現實的真實場景，據說 IKEA 的型錄都是用類似方法產生的，而不是真的把產品擺出來拍照。 哈哈</p>
<div><img src="/img/2016-10-10/3.jpg" alt="據說 IKEA 型錄的圖都是渲染出來的[1]"><span class="image-caption">據說 IKEA 型錄的圖都是渲染出來的[1]</span></div>


<a id="more"></a>
<h2 id="關於 -pbrt- 與 -ray-tracing"><a href="# 關於 -pbrt- 與 -ray-tracing" class="headerlink" title="關於 pbrt 與 ray-tracing"></a>關於 pbrt 與 ray-tracing</h2><p>Ray-tracing 說穿了就是在模擬自然界光線的運作，我們之所以看的到東西，其實就是因為光線打到物體並反射到我們眼睛，這也是為甚麼在無光的地方會伸手不見五指 (因為沒有任何光打到手指並反射到眼中)。<br> 至於電腦要怎麼模擬這件事，大致來說是光線從光源出發，途中遇到障礙物就要算交點，有交點就要根據材質特性反射，反射之後就是一條新的光線，就繼續做交點測試直到進到眼睛中(或直到能量遞減完畢)。可以看出，ray-tracing 最重要的大概就是與物件算交點了，因為 ray 會一直做交點測試，所以與物件的交點測試必須要夠快才行，不然就會算到天荒地老….</p>
<p>pbrt 除了最基本的 triangleMesh 以外，還實作很多其他一些常見的 shape(球體、圓柱體、圓形、heightfield…)，這其實是拿來給 api 使用的，一般人可以寫 pbrt 專用的描述檔來描述一個場景中的物體、光源等等，再藉由 pbrt 的程式來渲染出整張影像。</p>
<p>pbrt 中的各種 shape，有些是會先轉成 triangleMesh(對三角形求交點應該是圖學中最基礎的了，如果原本物件太複雜通常就會先把它拆成三角形組合再來算)；而有些是有實作對 shape 交點測試的。由於把物件轉成 triangleMesh 其實就硬是多一個步驟了啊，如果可以與 shape 直接求交點，那速度上當然會大躍進~</p>
<h2 id="實作 -heightfield- 交點測試"><a href="# 實作 -heightfield- 交點測試" class="headerlink" title="實作 heightfield 交點測試"></a>實作 heightfield 交點測試</h2><p>Heightfield 其實就是平面但是有高低差，也就是說，對每個 $(x, y)$ 而言只會有一個 $z$ 值。算是個滿單純的 shape。<br>Heightfield 也是原本就有實作的一種 shape，是直接用 <code>Refine()</code> 來把形狀轉為 triangleMesh 再做交點測試的。</p>
<p>如果能夠跳過三角化而直接與 heightfield 做交點測試，可能可以比較快喔？<br>參考一下別的 shape，包含球體、圓柱體等實作的交點測試的方法都是在幾何意義上直接求交點，也就是算數學求解~ 哈哈 <br> 但 heightfield 似乎是沒辦法從幾何意義上直接解了，需要用更暴力的方法~</p>
<p>這邊我是使用 <a href="https://www.wikiwand.com/en/Digital_differential_analyzer" target="_blank" rel="external">DDA</a>(digital differential analyzer) 來做交點測試，這東西其實原本是拿來畫線的演算法，因為實際上的線是連續的，但是呈現在電腦上卻必須以 pixel 為單位呈現。而這邊與 heightfield 的交點測試就是將 DDA 擴展至三維空間中(多了 Z 軸)。</p>
<div><img src="/img/2016-10-10/2.png" alt="2D-DDA 邏輯。[2]"><span class="image-caption">2D-DDA 邏輯。[2]</span></div>

<p>可以看到其實可以在一開始就算出 <code>x</code>, <code>y</code> 要走多少會到下一個 pixel，這些都是定值，也讓遍歷整個 Pixel-Grid 變得很容易，而 3D-DDA 就只是再加入 <code>z</code> 軸的資訊，並且每一個 pixel 變成 voxel。<br>3D-DDA 這樣的方式其實在 pbrt 裡面已有實作，是來作為加速結構用途，但是由於 heightfield 本身特性(對每個 $(x, y)$ 而言只會有一個 $z$ 值)，我們可以讓 Voxel 的高度等於 heightfield 的高度，如此一來就可以讓 3D 結構的 heightfield 套用 2D-DDA 了！耶~~~</p>
<p>建好 DDA 需要的資訊後，接下來就是要實作 Ray 交點測試了，在遍歷 Voxel 的過程中，需要針對這個 Voxel 做交點測試，如果有交點就結束了；沒有就到下個 Voxel。<br>而關於每個 Voxel 的交點測試其實也是滿單純的，在設計 DDA 的結構時，除了讓 Voxel 高等於 heightfield 高，可以變成 2D-DDA 以外，讓 Voxel 的寬等於一個單位的 <code>x</code> 及 <code>y</code> 也是有很大的好處的，如下圖:</p>
<div><img src="/img/2016-10-10/4.png" alt="從正上方看下來的 heightfield 樣子，數值為對應 z 值。讓 Voxel 寬度等於一格寬有好處。"><span class="image-caption">從正上方看下來的 heightfield 樣子，數值為對應 z 值。讓 Voxel 寬度等於一格寬有好處。</span></div>

<p>依據這樣的設計，每次在做 Voxel 交點測試時，可以知道這 Voxel 中就是包含兩個三角形；也就是說分別對這兩個三角形做交點測試就好了~~</p>
<p>根據這樣的算法，就可以得出與原本直接三角化的做法一模一樣的結果:</p>
<div><img src="/img/2016-10-10/landsea-big.jpg" alt="用直接求交點的方式取代原本先做三角化的方法。"><span class="image-caption">用直接求交點的方式取代原本先做三角化的方法。</span></div>


<h2 id="平滑化"><a href="# 平滑化" class="headerlink" title="平滑化"></a>平滑化 </h2><p> 看看上圖的結果，看得出都是一面一面的三角形面，這是因為同一個面上所有點都是一樣的法向量，所以反射角度也都一樣，自然就成這副德性。<br>如果要做平滑化的話就必須內插三角形內部的點的法向量，使得三角面反射光會看起來滑順一點。</p>
<div><img src="/img/2016-10-10/1.png" alt="三角化後每個點 M 都有六個鄰居。"><span class="image-caption">三角化後每個點 M 都有六個鄰居。</span></div>

<p>這邊我是直接平均法向量來達成這樣的效果，由於三角化之後每個點會有六個鄰居；<br>點 <code>M</code> 的鄰居有 <code>TL</code>、<code>T</code>、<code>R</code>、<code>BR</code>、<code>B</code>、<code>L</code> 六點，點 <code>M</code> 的法向量可以藉由任意兩向量外積得出。</p>
<p>那我就平均一下六個法向量來當作真正的法向量，以 <code>M</code> 為原點，可算出平均法向量為:<br>$\underset{Normalize(}{}\underset{TL}{\rightarrow}  \underset{\times}{} \underset{L}{\rightarrow} \underset{+}{} \underset{L}{\rightarrow}  \underset{\times}{} \underset{B}{\rightarrow} \underset{+}{} \underset{B}{\rightarrow}  \underset{\times}{} \underset{BR}{\rightarrow} \underset{+}{} \underset{BR}{\rightarrow}  \underset{\times}{} \underset{R}{\rightarrow} \underset{+}{} \underset{R}{\rightarrow}  \underset{\times}{} \underset{T}{\rightarrow} \underset{+}{} \underset{T}{\rightarrow}  \underset{\times}{} \underset{TL}{\rightarrow} \underset{)}{}$</p>
<p>這樣子改進後，就可以讓結果變這樣:</p>
<div><img src="/img/2016-10-10/landsea-big-smooth.jpg" alt="平滑化的結果"><span class="image-caption">平滑化的結果</span></div>

<h2 id="浮點數精度問題 -10-22- 更新"><a href="# 浮點數精度問題 -10-22- 更新" class="headerlink" title="浮點數精度問題 (10/22 更新)"></a> 浮點數精度問題 (10/22 更新)</h2><p> 做完平滑化之後，感覺海好像怪怪的歐….<br>一開始其實我還沒察覺，過這麼久才發現這問題…</p>
<p>很顯然只有海有這樣的問題，八成是因為海的 $z$ 值差距太小，計算法向量時的誤差。<br>用這樣的思維去追查程式後，發現我原本在算六個法向量總和後有做 <code>Normalize(sumOfNormals)</code>，這步驟造成 $z$ 值起伏太小的海的計算誤差….<br>把 <code>Normalize()</code> 拔掉之後就正常了～</p>
 <div><img src="/img/2016-10-10/4.jpg" alt="修正浮點數精度問題後的結果"><span class="image-caption">修正浮點數精度問題後的結果</span></div>


<h2 id="加速"><a href="# 加速" class="headerlink" title="加速"></a>加速 </h2><p> 很可惜的是我做完以後，速度沒有想像中的快速，反而比原本的還慢了兩倍以上…. 嗚嗚嗚….<br>稍微看看別的 shape 的交點測試，其實有很多時候會先跟 Bbox(Bounding Box) 做測試，因為與 Bbox 交點是容易很多的，如果與 Bbox 無交點就也不用繼續做下去了。<br>在 Voxel 交點測試中，也應當先與整個 Voxel 做測試，確定有交點再去試裡面的兩個三角形，這樣就可以省下很大量的做白工。</p>
<p>但這樣做完還是不夠好，所以我利用 CPU profiling 來測試我的程式的瓶頸到底在哪裡….<br>利用這樣的檢測，我陸續做了幾次優化:</p>
<table>
<thead>
<tr>
<th>原因及改善方法</th>
<th style="text-align:right"><code>Intersect()</code></th>
<th style="text-align:right">與未最佳化時比較</th>
</tr>
</thead>
<tbody>
<tr>
<td>未最佳化。</td>
<td style="text-align:right">90,274</td>
<td style="text-align:right">100.0%</td>
</tr>
<tr>
<td>發現 <code>ObjectBound()</code> 很慢，改在 Heightfield construction 時就先存 <code>minZ</code>, <code>maxZ</code>。</td>
<td style="text-align:right">82,731</td>
<td style="text-align:right">91.6%</td>
</tr>
<tr>
<td>發現在算 Voxel BBox 使用的 <code>Bbox(Union(Bbox, Bbox))</code> 超爆慢，改用 <code>Bbox(Point, Point)</code>。</td>
<td style="text-align:right">53,408</td>
<td style="text-align:right">59.1%</td>
</tr>
<tr>
<td>發現有不必要的坐標系轉換，由於在 Voxel 交點測試中會先測與 Voxel Bbox 交點，所以最好直接給他已轉好的 Ray(Object Space)。</td>
<td style="text-align:right">46,922</td>
<td style="text-align:right">51.9%</td>
</tr>
<tr>
<td>由於 <code>Bbox(Point, Point)</code> 建構時都要重新判斷 min max，改用先建構空的 Bbox 再直接給值 (<code>pmin</code>, <code>pmax</code>) 省去建構時間。</td>
<td style="text-align:right">36,768</td>
<td style="text-align:right">40.7%</td>
</tr>
<tr>
<td>把用不到的 Bbox 給 Voxel 交點測試中再利用，節省 Construction Time(避免重新 relocate 記憶體位置以及建構空 Bbox 的時間)。</td>
<td style="text-align:right">32,742</td>
<td style="text-align:right">36.2%</td>
</tr>
</tbody>
</table>
<ul>
<li><code>Intersect()</code> 欄的數字是指 CPU 採樣時落在這函式的總樣本數，越多表示執行時間越長</li>
<li>測試的是 <code>landsea-2.pbrt</code>，並且使用 <code>–ncores 1</code> 以減少多執行緒的誤差</li>
</ul>
<p>經過幾次最佳化後，成功壓低執行時間(單位為秒)，效能比較如下:</p>
<div><img src="/img/2016-10-10/5.png" alt="效能比較。[3]"><span class="image-caption">效能比較。[3]</span></div>


<h2 id="雜談"><a href="# 雜談" class="headerlink" title="雜談"></a>雜談 </h2><p> 說真的這大概是我做過數一數二難的作業了，而且竟然只是作業一….<br>其實寫的過程也不是我自己想到的，老師也有給提示，甚至網路上其實根本有答案….(不見得是最佳解就是了)<br>為了這作業我甚至還上 Stack overflow 問了人生第一個問題 哈哈 (雖然問題跟演算法沒關係)<br> 只能說不愧是 Stanford 的題目囉？</p>
<hr>
<p> 註:<br> [1]: 可以看 <a href="http://www.wsj.com/articles/SB10000872396390444508504577595414031195148" target="_blank" rel="external"> 這篇 </a> 介紹 IKEA 渲染型錄<br> [2]: 原圖來自 Physically Based Rendering, Second Edition<br> [3]: 執行時間用 <code>bash</code> 內建 <code>time</code> 指令來量測</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;pbrt 是一個基於物理的 ray-tracing libarary，他可以拿來產生接近現實的真實場景，據說 IKEA 的型錄都是用類似方法產生的，而不是真的把產品擺出來拍照。 哈哈&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;/img/2016-10-10/3.jpg&quot; alt=&quot;據說 IKEA 型錄的圖都是渲染出來的[1]&quot;&gt;&lt;/div&gt;
    
    </summary>
    
    
      <category term="pbrt" scheme="https://ssarcandy.tw/tags/pbrt/"/>
    
      <category term="c++" scheme="https://ssarcandy.tw/tags/c/"/>
    
      <category term="rendering" scheme="https://ssarcandy.tw/tags/rendering/"/>
    
  </entry>
  
  <entry>
    <title>一些 Python 筆記</title>
    <link href="https://ssarcandy.tw/2016/09/09/python-note/"/>
    <id>https://ssarcandy.tw/2016/09/09/python-note/</id>
    <published>2016-09-09T16:28:57.000Z</published>
    <updated>2016-12-17T19:12:41.582Z</updated>
    
    <content type="html"><![CDATA[<p>最近的專案需要用到 <a href="http://opencv.org/" target="_blank" rel="external">OpenCV</a>，官方有提供 C++ 以及 Python 的版本。我以前都用 C++，這次想說來換換口味使用 Python 好了，如果用的順手以後就都這樣搭配著用 (Python + OpenCV)。<br> 說是這樣說，但其實我對 Python 根本一竅不通，從來沒在比較大的專案中使用過，所以新手如我自然就遇到很多坑(?)<br><a id="more"></a></p>
<p>我這次專案是 Python 2.7 + OpenCV 3.1。<br>安裝 OpenCV 一直都是很麻煩的事情，C++ 的免不了要自己 build，詳細的方法在我之前寫的 <a href="https://ssarcandy.tw/2016/07/22/Setting-up-OpenCV-using-Cmake-GUI/"> 另一篇 </a> 有教學；<br>而 Python 安裝 OpenCV 稍微簡單一點，把 <code>cv2.pyd</code> 放到 <code>C:\Python27\Lib\site-packages</code> 就可以了 [1]。<br>在 Mac/Linux 上更簡單，可以使用 <a href="https://www.continuum.io/" target="_blank" rel="external">conda</a> [2] 來幫你安裝。</p>
<hr>
<p>好，接下來就是用到現在所做的一些筆記～</p>
<h1 id="Coding-style"><a href="#Coding-style" class="headerlink" title="Coding-style"></a>Coding-style</h1><p>Python 的 Coding-style 基本上就是參考 <a href="https://www.python.org/dev/peps/pep-0008/" target="_blank" rel="external">PEP8</a>，簡結一下重點:</p>
<ul>
<li>縮排用空格</li>
<li>一行不要超過 80 個字元，超過就換行。</li>
<li>除了 ClassName 以外，一律用 snake_case 為命名規則。</li>
<li>文件首行要加上編碼，一般 <code>utf-8</code> 就是加上這行 <code># -*- coding: utf-8 -*-</code></li>
</ul>
<h1 id="Division"><a href="#Division" class="headerlink" title="Division"></a>Division</h1><p>Python2 的除法很特別，竟然只除到整數，意思就是 <code>5 / 2 = 2</code>，不過這其實就跟 C++ 一樣嘛，強制轉型一下就好:</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">print(<span class="number">5</span> / <span class="number">2</span>)        <span class="comment"># 會無條件捨去小數點，印出 2</span></div><div class="line">print(<span class="number">5</span> / <span class="number">2.0</span>)      <span class="comment"># 2.5</span></div><div class="line">print(<span class="number">5</span> / float(<span class="number">2</span>)) <span class="comment"># 2.5</span></div></pre></td></tr></table></figure>
<p>不過這樣好麻煩，有沒有一勞永逸的方法？<br>有！就是用神奇的 <code>__future__</code></p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 在文件開頭處加上這行</span></div><div class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> division</div></pre></td></tr></table></figure>
<p><strong>future</strong> 是 Python2 很特別的東西，感覺上就是抓 Python3 的功能來用，而這邊 <code>import division</code> 就是使除法的行為與 Python3 一致，詳細運作原理可以參考 <a href="http://stackoverflow.com/questions/7075082/what-is-future-in-python-used-for-and-how-when-to-use-it-and-how-it-works" target="_blank" rel="external">stackoverflow</a> 上的說法:</p>
<blockquote>
<p>The internal difference is that without that import, <code>/</code> is mapped to the <code>__div__()</code> method, while with it, <code>__truediv__()</code> is used.</p>
</blockquote>
<h1 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h1><p>網路上有許多宣告 Class 的教學，不過好像大部分的都不對或過時了。<br>在 Python2 中，Class 宣告方式如下：</p>
<figure class="highlight py"><figcaption><span>class.py</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self.bar1 = <span class="string">'hello'</span></div><div class="line">        self.bar2 = <span class="string">'world'</span></div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hello_world</span><span class="params">(self)</span>:</span></div><div class="line">        print(self.bar1 + <span class="string">''</span> + self.bar2)</div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__private_func</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">'I am private function'</span>)</div><div class="line">  </div><div class="line">  </div><div class="line">foo = Foo()          <span class="comment"># new 一個新的 Foo</span></div><div class="line">foo.hello_world()    <span class="comment"># 不用帶任何參數</span></div><div class="line">foo.__private_func() <span class="comment"># 無法呼叫，會噴 Error: AttributeError:'Foo'object has no attribute'__private_func'</span></div></pre></td></tr></table></figure>
<ul>
<li>第一行的 <code>object</code> 是必須的。</li>
<li><code>__init__</code> 這個 function 也是必須的，這是 Class Constructor。</li>
<li>每個 function 的第一個參數必須放 <code>self</code>，這與 C++ Class 中的 <code>this</code> 相似，基本上就是拿來存取 <strong> 自己 </strong> 用的。<ul>
<li>例如 <code>hello_world()</code> 中就有存取 <code>bar1</code> 跟 <code>bar2</code>，而在呼叫時 <code>self</code> 會被跳過。</li>
</ul>
</li>
<li>如果要寫 private method [3]，就在 function name 前加上雙底線 <code>__</code>，如同上面的第 9 行處。</li>
</ul>
<h1 id="Path"><a href="#Path" class="headerlink" title="Path"></a>Path</h1><p>檔案路徑也是一個滿麻煩的事情，假設要讀一個檔案，一開始可能會這樣寫：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cv2.imread(<span class="string">'../data/foo.jpg'</span>) <span class="comment"># cv2.imread 是 opencv 的讀圖函式</span></div></pre></td></tr></table></figure>
<p>這樣當然可以讀的到，但當你換了一個工作環境，像是 Windows，這樣寫就炸了～(因為 Window 路徑是用反斜線 <code>\</code>)<br>Python 提供了個好工具 <code>os.path.join()</code>，簡單來說就是幫忙處理斜線。所以上面那個例子可以改寫成這樣：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> os</div><div class="line">cv2.imread(os.path.join(<span class="string">'..'</span>, <span class="string">'data'</span>, <span class="string">'foo.jpg'</span>))</div></pre></td></tr></table></figure>
<p>這樣的寫法就可以順利地在各平台運作～！</p>
<h1 id="Function-name-and-Variable-name"><a href="#Function-name-and-Variable-name" class="headerlink" title="Function name and Variable name"></a>Function name and Variable name</h1><p>每個程式語言都有保留字，像是 <code>for</code>, <code>while</code>, <code>if</code> 之類的都是常見的保留字，而 Python 也不例外，你可以在 <a href="https://docs.python.org/2.5/ref/keywords.html" target="_blank" rel="external"> 這邊 </a> 看到全部的保留字。<br>而通常 function name 也跟保留字一樣不能當作變數名稱 [4]。<br>特別的是 Python 允許變數名稱與 function 名稱一樣，像是：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sum = sum([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])  <span class="comment"># sum() is built-in function for python</span></div><div class="line">print(sum)              <span class="comment"># 15</span></div><div class="line">print(sum([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])) <span class="comment"># 15</span></div></pre></td></tr></table></figure>
<p>上面的例子可以看到，Python 能夠清楚的分辨這個 <code>sum</code> 是指變數還是內建函式。<br>javascript 就不行：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">btoa = btoa(<span class="string">'hello'</span>)       <span class="comment">// btoa() is built-in function for javascript</span></div><div class="line"><span class="built_in">console</span>.log(btoa)          <span class="comment">// aGVsbG8=</span></div><div class="line"><span class="built_in">console</span>.log(btoa(<span class="string">'hello'</span>)) <span class="comment">// Uncaught TypeError: btoa is not a function</span></div></pre></td></tr></table></figure>
<p>可以發現在第三行就噴錯了，因為 <code>btoa</code> 在第一行已經被蓋掉了，後面要用 <code>btoa()</code> 就會以為你是指那個變數，而變數當然不是 function 囉。</p>
<h1 id="The-Zen-of-Python"><a href="#The-Zen-of-Python" class="headerlink" title="The Zen of Python"></a>The Zen of Python</h1><p>Python 作者 Tim Peters 把一首詩藏在 <code>import this</code> 中，</p>
<blockquote>
<p>Beautiful is better than ugly.<br>Explicit is better than implicit.<br>Simple is better than complex.<br>Complex is better than complicated.<br>Flat is better than nested.<br>Sparse is better than dense.<br>Readability counts.<br>Special cases aren’t special enough to break the rules.<br>Although practicality beats purity.<br>Errors should never pass silently.<br>Unless explicitly silenced.<br>In the face of ambiguity, refuse the temptation to guess.<br>There should be one– and preferably only one –obvious way to do it.<br>Although that way may not be obvious at first unless you’re Dutch.<br>Now is better than never.<br>Although never is often better than <em>right</em> now.<br>If the implementation is hard to explain, it’s a bad idea.<br>If the implementation is easy to explain, it may be a good idea.<br>Namespaces are one honking great idea – let’s do more of those!</p>
</blockquote>
<p>寫 Python 就是要追求乾淨、易讀、簡單，這也是我這幾周使用 Python 所感覺到的。<br>再引用 David 老師所言，</p>
<blockquote>
<p>寫 Python 就像是在寫 pseudo-code 一樣爽！</p>
</blockquote>
<hr>
<p>註一： <code>cv.pyd</code> 可以在 build 好的 opencv 資料夾中找到。<br>註二： OpenCV 不能用 <code>pip</code> 安裝，而 <code>conda</code> 是類似 <code>pip</code> 的 Python 套件管理軟體。<br>註三： Python 是沒有 private function 的，只是在 runtime 藉由更改 function name 來達到這樣的效果，詳細可以參考 <a href="http：//stackoverflow.com/questions/17193457/private-method-in-python"> 這篇 </a>。<br> 註四： 函式名子 <strong> 不一定 </strong> 不能當作變數名稱，在 C/C++ 中會有 Compile-time Error，在 javascript 中是可以的，但是會覆蓋其內容。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近的專案需要用到 &lt;a href=&quot;http://opencv.org/&quot;&gt;OpenCV&lt;/a&gt;，官方有提供 C++ 以及 Python 的版本。我以前都用 C++，這次想說來換換口味使用 Python 好了，如果用的順手以後就都這樣搭配著用(Python + OpenCV)。&lt;br&gt;說是這樣說，但其實我對 Python 根本一竅不通，從來沒在比較大的專案中使用過，所以新手如我自然就遇到很多坑(?)&lt;br&gt;
    
    </summary>
    
    
      <category term="note" scheme="https://ssarcandy.tw/tags/note/"/>
    
      <category term="opencv" scheme="https://ssarcandy.tw/tags/opencv/"/>
    
      <category term="python2" scheme="https://ssarcandy.tw/tags/python2/"/>
    
  </entry>
  
  <entry>
    <title>談談 vim plugin-manager</title>
    <link href="https://ssarcandy.tw/2016/08/17/vim-plugin-manager/"/>
    <id>https://ssarcandy.tw/2016/08/17/vim-plugin-manager/</id>
    <published>2016-08-17T03:02:10.000Z</published>
    <updated>2016-12-17T19:12:41.582Z</updated>
    
    <content type="html"><![CDATA[<p>我用過了幾乎所有有名的 vim plugin-manager，包含 <a href="https://github.com/tpope/vim-pathogen" target="_blank" rel="external">Pathogen</a>, <a href="https://github.com/VundleVim/Vundle.vim" target="_blank" rel="external">Vundle</a> 以及比較新的 <a href="https://github.com/junegunn/vim-plug" target="_blank" rel="external">vim-plug</a>。<br>而以時間序來說也是 Pathogen -&gt; Vundle -&gt; vim-plug</p>
<p>先來談談用過這三個分別的感想好了：</p>
<a id="more"></a>
<h4 id="Pathogen"><a href="#Pathogen" class="headerlink" title="Pathogen"></a>Pathogen</h4><p>簡單好用，與其說是 plugin-manager，個人覺得比較像是個純粹的 run-time loader，沒有什麼其他的功能。<br>但已十分好用，要新增什麼 plugin，只需把 plugin 的資料夾放在 <code>bundle/</code> 底下就完工了！<br>刪除也是，直接砍掉 <code>bundle/</code> 底下對應資料夾就 OK</p>
<h4 id="Vundle"><a href="#Vundle" class="headerlink" title="Vundle"></a>Vundle</h4><p>目前應該是這三者中 github stars 最多的。<br>plugin 安裝方式是在 <code>.vimrc</code> 中寫你要的 plugin name</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Plugin <span class="string">'tpope/vim-fugitive'</span></div></pre></td></tr></table></figure>
<p>然後在 vim 中打 <code>:PluginInstall</code> 就會幫你安裝。</p>
<p>這樣的好處是你裝過什麼一目了然，而且到新環境要重新設置的時候也很方便，直接 <code>:PluginInstall</code> 就完成了。(如果用 Pathogen 就必須自己把要用的 plugins clone 下來。)</p>
<h4 id="vim-plug"><a href="#vim-plug" class="headerlink" title="vim-plug"></a>vim-plug</h4><p>我目前在使用的 plugin-manager ，給我的感覺就是 Vundle 的加強版。<br>新增 plugin 的方式跟 Vundle 很像(只是關鍵字不同)，都是在 <code>.vimrc</code> 中寫你要的 plugin name</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Plug <span class="string">'tpope/vim-fugitive'</span></div></pre></td></tr></table></figure>
<p>安裝也是跟 Vundle 差不多，關鍵字不一樣而已 (<code>:PlugInstall</code>)</p>
<p>比較厲害的是 vim-plug 可以 <strong>on-demand loading</strong>！<br>像是 <a href="https://github.com/fatih/vim-go" target="_blank" rel="external">vim-go</a>(強大的 Golang Dev-plugin)，這種只有在寫 golang 時候才要的 plugin，就應該只在副檔名是 <code>.go</code> 的時候載入就好；<br><a href="https://github.com/scrooloose/nerdtree" target="_blank" rel="external">NERDTree</a> 也是，有時候只是打開一個檔案要編輯而已，用不著這個套件，只有當真的觸發開啟 NERDTree 的時候再載入就好。<br>這些 vim-plug 都可以設定(設定方式詳見 <a href="https://github.com/junegunn/vim-plug" target="_blank" rel="external">readme</a>)，大幅提升 vim 開啟速度～</p>
<h3 id="效能"><a href="# 效能" class="headerlink" title="效能"></a>效能 </h3><p> 我從 Pathogen 換到 Vundle 是為了可以很容易的在新環境設定好 vim，<br>而從 Vundle 換到 vim-plug 則是為了他的 on-demand loading。</p>
<p>所以說到底效能差多少？<br>其實我並不是個重度 plugins 使用者，有在用的 plugins 大概 20 個吧。<br>所以從 Vundle 換到 vim-plug 說實在並沒有顯著效能差異。<br>不過還是可以看看別人的實驗</p>
<div><img src="/img/2016-08-17/1.png" alt="不同 plugin-manager 的開啟速度(plug = vim-plug)。圖片出自 vim-plugins-and-startup-time"><span class="image-caption">不同 plugin-manager 的開啟速度(plug = vim-plug)。圖片出自 vim-plugins-and-startup-time</span></div>

<p>不難發現，有 on-demand loading 的 plugin-manager 開啟速度會快不少，以圖中為例大概都可以快上個 30% ！<br>如果有興趣，也可以自己試試 vim 的開啟速度，可以用以下的方法測量。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ vim --startuptime vim.log</div></pre></td></tr></table></figure>
<p>詳細開啟資訊都會寫入 <code>vim.log</code></p>
<h5 id="ref"><a href="#ref" class="headerlink" title="ref:"></a>ref:</h5><ul>
<li><a href="http://junegunn.kr/2014/07/vim-plugins-and-startup-time/" target="_blank" rel="external">vim-plugins-and-startup-time</a></li>
<li><a href="https://www.facebook.com/groups/vim.tw/" target="_blank" rel="external">vim.tw</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我用過了幾乎所有有名的 vim plugin-manager，包含 &lt;a href=&quot;https://github.com/tpope/vim-pathogen&quot;&gt;Pathogen&lt;/a&gt;, &lt;a href=&quot;https://github.com/VundleVim/Vundle.vim&quot;&gt;Vundle&lt;/a&gt; 以及比較新的 &lt;a href=&quot;https://github.com/junegunn/vim-plug&quot;&gt;vim-plug&lt;/a&gt;。&lt;br&gt;而以時間序來說也是 Pathogen -&amp;gt; Vundle -&amp;gt; vim-plug&lt;/p&gt;
&lt;p&gt;先來談談用過這三個分別的感想好了：&lt;/p&gt;
    
    </summary>
    
    
      <category term="vim" scheme="https://ssarcandy.tw/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>用 Travis CI 自動部屬 hexo 到 GitHub</title>
    <link href="https://ssarcandy.tw/2016/07/28/hexo-auto-deploy/"/>
    <id>https://ssarcandy.tw/2016/07/28/hexo-auto-deploy/</id>
    <published>2016-07-28T16:51:43.000Z</published>
    <updated>2016-12-17T19:12:41.582Z</updated>
    
    <content type="html"><![CDATA[<p>其實 <a href="https://hexo.io/" target="_blank" rel="external">hexo</a> 作者 TC 已經有發過 <a href="https://zespia.tw/blog/2015/01/21/continuous-deployment-to-github-with-travis/" target="_blank" rel="external"> 一篇文章 </a> 在講這個主題了，也講得很清楚了，基本上 <del> 矇著眼睛 </del> 照做就行了。<br>而這篇主要是再補充幾個細節。</p>
<a id="more"></a>
<h2 id="SSH-KEY"><a href="#SSH-KEY" class="headerlink" title="SSH KEY"></a>SSH KEY</h2><p>  矇著眼照做 <a href="https://zespia.tw/blog/2015/01/21/continuous-deployment-to-github-with-travis/" target="_blank" rel="external"> 那篇</a>，到這行:<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ travis encrypt-file ssh_key --add</div></pre></td></tr></table></figure></p>
<p>  這邊會幫你上傳 ssh_key 到 Travis 上，<code>--add</code>這個 flag 可以幫你插入解密指令到 <code>.travis.yml</code> 的<code>before_install</code>。<br>  不過這 flag 真的很機車，會把你的 <code>.travis.yml</code> 排版全搞亂，順便把註解刪光光！<br>  建議不要加 <code>--add</code> 自己手動插入解密指令，排版就不會亂掉。<br>  另外，如果因某種天災人禍導致忘記或沒辦法用指令插入解密指令，還是可以上 Travis 上的設定中看到環境變數名稱。<br>  <img src="/img/2016-07-29/2.PNG" alt="repository &gt; more options 可以設定、看到 Travis 的環境變數"><span class="image-caption">repository &gt; more options 可以設定、看到 Travis 的環境變數</span></p>
<h2 id="USE-SSH"><a href="#USE-SSH" class="headerlink" title="USE SSH"></a>USE SSH</h2><p>  Travis 是用 GitHub 的 <a href="https://developer.github.com/guides/managing-deploy-keys/" target="_blank" rel="external">Deploy key</a> 來存取 repository 的，關於如何產生以及設定 Deploy key 都照著 TC <a href="https://zespia.tw/blog/2015/01/21/continuous-deployment-to-github-with-travis/" target="_blank" rel="external">那篇文章 </a> 做就可以了。<br>  如果不幸在 <code>hexo deploy</code> 時遇到錯誤如下:<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">remote: Invalid username or password.</div><div class="line">fatal: Authentication failed for &quot;....&quot;</div></pre></td></tr></table></figure></p>
<p>  那可以檢查一下 hexo 的 <code>_config.yml</code> <code>deploy</code> 的部分，要用 ssh 的形式設定 repository<br>  <figure class="highlight plain"><figcaption><span>_config.yml</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">deploy:</div><div class="line">  type: git</div><div class="line">  repo: git@github.com:SSARCandy/ssarcandy.github.io.git</div><div class="line">  branch: master</div></pre></td></tr></table></figure></p>
<h2 id="SETTING-UP-travis-yml"><a href="#SETTING-UP-travis-yml" class="headerlink" title="SETTING UP .travis.yml"></a>SETTING UP .travis.yml</h2><p>我這個網站結構如下:</p>
<blockquote>
<p>[develop] -&gt; default branch，我在這條 branch 新增文章、修改樣式等等<br>[master]  -&gt; 放 static-files，也就是 hexo generate 出來的東東</p>
</blockquote>
<p>讓 Travis 自動部屬時，Clone 的是 <code>develop</code> branch， 經過 <code>hexo generate</code> 後推到 <code>master</code> branch 上，為了避免 forced-update，在<code>.travis.yml</code> 中需要再設定一下。</p>
<p>附上我的 <code>.travis.yml</code>，基本上跟 TC 那篇 87% 像啦…<br><figure class="highlight bash"><figcaption><span>title: .travis.yml</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">language: node_js</div><div class="line">node_js:</div><div class="line">  - <span class="string">"4"</span></div><div class="line"> </div><div class="line">before_install:</div><div class="line">  <span class="comment"># Decrypt the private key</span></div><div class="line">  - openssl aes-256-cbc -K <span class="variable">$encrypted_d7634ff77415_key</span> -iv <span class="variable">$encrypted_d7634ff77415_iv</span> -in .travis/ssh_key.enc -out ~/.ssh/id_rsa <span class="_">-d</span></div><div class="line">  <span class="comment"># Set the permission of the key</span></div><div class="line">  - chmod 600 ~/.ssh/id_rsa</div><div class="line">  <span class="comment"># Start SSH agent</span></div><div class="line">  - <span class="built_in">eval</span> $(ssh-agent)</div><div class="line">  <span class="comment"># Add the private key to the system</span></div><div class="line">  - ssh-add ~/.ssh/id_rsa</div><div class="line">  <span class="comment"># Copy SSH config</span></div><div class="line">  - cp .travis/ssh_config ~/.ssh/config</div><div class="line">  <span class="comment"># Set Git config</span></div><div class="line">  - git config --global user.name <span class="string">"ssarcandy"</span></div><div class="line">  - git config --global user.email ssarcandy@gmail.com</div><div class="line">  <span class="comment"># Install Hexo</span></div><div class="line">  - npm install hexo -g</div><div class="line">  <span class="comment"># Clone the repository</span></div><div class="line">  - git <span class="built_in">clone</span> https://github.com/SSARCandy/ssarcandy.github.io .deploy_git</div><div class="line">  <span class="comment"># My static-files store on master branch</span></div><div class="line">  - <span class="built_in">cd</span> .deploy_git &amp;&amp; git checkout master</div><div class="line">  - <span class="built_in">cd</span> ..</div><div class="line"> </div><div class="line">script:</div><div class="line">  - hexo generate</div><div class="line">  - hexo deploy</div><div class="line"> </div><div class="line">branches:</div><div class="line">  only:</div><div class="line">  - develop</div></pre></td></tr></table></figure></p>
<p>比較需要解說的是這段<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Clone the repository</span></div><div class="line">- git <span class="built_in">clone</span> https://github.com/SSARCandy/ssarcandy.github.io .deploy_git</div><div class="line">- <span class="built_in">cd</span> .deploy_git &amp;&amp; git checkout master</div><div class="line">- <span class="built_in">cd</span> ..</div></pre></td></tr></table></figure></p>
<p><code>.deploy_git</code>是 hexo 會產生的資料夾，用於紀錄 git history，不過由於每次 clone 都是全新的，所以每次 <code>.deploy_git</code> 也都會是新的，這會導致每次更新都會是 forced-update。<br>所以，複製一份 repo (at <code>master</code> branch)，並改名叫 <code>.deploy_git</code> 就是為了讓新產生出的靜態檔案可以有之前的 git history，就可以避免 forced-update。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;其實 &lt;a href=&quot;https://hexo.io/&quot;&gt;hexo&lt;/a&gt; 作者 TC 已經有發過&lt;a href=&quot;https://zespia.tw/blog/2015/01/21/continuous-deployment-to-github-with-travis/&quot;&gt;一篇文章&lt;/a&gt;在講這個主題了，也講得很清楚了，基本上&lt;del&gt;矇著眼睛&lt;/del&gt;照做就行了。&lt;br&gt;而這篇主要是再補充幾個細節。&lt;/p&gt;
    
    </summary>
    
    
      <category term="hexo" scheme="https://ssarcandy.tw/tags/hexo/"/>
    
      <category term="CI" scheme="https://ssarcandy.tw/tags/CI/"/>
    
  </entry>
  
  <entry>
    <title>自動分享每日天文圖 (APOD) 到 Dcard</title>
    <link href="https://ssarcandy.tw/2016/07/26/bot-battle/"/>
    <id>https://ssarcandy.tw/2016/07/26/bot-battle/</id>
    <published>2016-07-26T16:16:45.000Z</published>
    <updated>2016-12-17T19:12:41.582Z</updated>
    
    <content type="html"><![CDATA[<p>原本其實只是要做個 <a href="https://api.slack.com/bot-users" target="_blank" rel="external">Slack bot</a>，<br>因為我懶得每天都上 <a href="http://www.phys.ncku.edu.tw/~astrolab/mirrors/apod/archivepix.html" target="_blank" rel="external">APOD</a> 官網看…<br>乾脆做個 bot 每天都會在中午 12:30 發今日的圖跟說明到 Slack channel 裡～<br><a id="more"></a><br><img src="/img/2016-07-27/1.PNG" alt="自動發文到 slack channel 裡，然後還隨機搭配內容農場風格的一句話。"><span class="image-caption">自動發文到 slack channel 裡，然後還隨機搭配內容農場風格的一句話。</span></p>
<p>不過除了我自己以外好像都沒什麼人捧場，幾乎都被無視 QQ<br><em>David 老師</em> 還表示很煩要我關掉 (明明一天才 Po 一次啊啊啊 ಠ_ಠ</p>
<p>所以我只好忍痛取消這個 Slack bot，改成直接用 Direct message 傳給 <em>David 老師</em> XD</p>
<p>結果 <em>David 老師 </em> 也做了個每半小時就發名言佳句給我的 bot，<br> 害我只好也把我的 bot 改成每十分鐘隨機發天文圖給他，看誰比較耐得住煩～<br><img src="/img/2016-07-27/2.PNG" alt="每半小時發給我一句名言佳句，真是世界煩。"><span class="image-caption">每半小時發給我一句名言佳句，真是世界煩。</span></p>
<p>當然這種互相毀滅的 bot 大戰持續沒多久就在雙方讓步之下都停止了…..</p>
<p>— 以上都是前言 —</p>
<p>即使 Slack 上都沒人要鳥我，<br>我還是秉持著推廣基礎天文教育的偉大理念，認為優質的每日天文圖的不應該被埋沒，要讓這樣優質的內容給更多人接觸到！<br>最後突然想到：「不然乾脆發在 Dcard 廢版好了，那邊最多人在看了而且不受版規限制」<br>可是懶人如我是不可能每天上去 Po 文的，所以又寫了個 bot 每天中午戳 Dcard API，發優質天文圖到廢版(廢文？</p>
<div><img src="/img/2016-07-27/3.PNG" alt="發廢文到廢版"><span class="image-caption">發廢文到廢版</span></div>

<p>結果意外反應還不錯？<br>還有人想要我整理系列文，不愧是廢版版友，就是有眼光！</p>
<div><img src="/img/2016-07-27/4.PNG" alt="大家都很捧場，覺得溫馨 ╰(〞︶〝) ╯"><span class="image-caption">大家都很捧場，覺得溫馨 ╰(〞︶〝) ╯</span></div>

<p><del>不知道要過多久才會有人會發現這都是 bot 在發文 XDD</del></p>
<p>–<br>最後自己推銷一下，由於 APOD 只有 NASA 有提供官方 <a href="https://api.nasa.gov/" target="_blank" rel="external">API</a>，除了英文以外其他語言的子站 (像是中文版) 都沒辦法簡單的取得內容，所以我寫了一個 npm 套件，專門處理取得指定日期、指定語言的 APOD 內容。<br>Github: <a href="https://github.com/SSARCandy/node-apod" target="_blank" rel="external">https://github.com/SSARCandy/node-apod</a><br>Demo: <a href="http://ssarcandy.tw/node-apod/demo.html">http://ssarcandy.tw/node-apod/demo.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原本其實只是要做個 &lt;a href=&quot;https://api.slack.com/bot-users&quot;&gt;Slack bot&lt;/a&gt;，&lt;br&gt;因為我懶得每天都上 &lt;a href=&quot;http://www.phys.ncku.edu.tw/~astrolab/mirrors/apod/archivepix.html&quot;&gt;APOD&lt;/a&gt; 官網看…&lt;br&gt;乾脆做個 bot 每天都會在中午 12:30 發今日的圖跟說明到 Slack channel 裡～&lt;br&gt;
    
    </summary>
    
    
      <category term="trashtalk" scheme="https://ssarcandy.tw/tags/trashtalk/"/>
    
  </entry>
  
  <entry>
    <title>Setting up OpenCV using Cmake GUI</title>
    <link href="https://ssarcandy.tw/2016/07/22/Setting-up-OpenCV-using-Cmake-GUI/"/>
    <id>https://ssarcandy.tw/2016/07/22/Setting-up-OpenCV-using-Cmake-GUI/</id>
    <published>2016-07-22T16:46:45.000Z</published>
    <updated>2016-12-17T19:12:41.582Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Build-OpenCV"><a href="#Build-OpenCV" class="headerlink" title="Build OpenCV"></a>Build OpenCV</h3><ol>
<li><p>Download <a href="https://github.com/Itseez/opencv" target="_blank" rel="external">OpenCV</a> and <a href="https://cmake.org/" target="_blank" rel="external">Cmake</a></p></li>
<li><p>Build opencv with cmake<br><div><img src="/img/2016-07-23/1.png" alt="Cmake configuration"><span class="image-caption">Cmake configuration</span></div></p>
<ul>
<li>Press <code>configure</code>, choose <code>visual studio 2015</code>, finish</li>
<li>Then press <code>generate</code> <a id="more"></a></li>
</ul>
</li>
<li><p>Open <code>OpenCV.sln</code> under <code>build/</code></p>
</li>
<li><p>Build it using <code>Debug</code>, <code>Release</code><br><div><img src="/img/2016-07-23/2.png" alt="Right click &gt; build"><span class="image-caption">Right click &gt; build</span></div></p>
<ul>
<li>right click &gt; build</li>
<li>switch to <code>Release</code> mode and build again</li>
</ul>
</li>
<li><p>[Windows] Setting up environment variable</p>
<ul>
<li>add <code>&lt;opencv&gt;/bin</code> into <code>PATH</code><div><img src="/img/2016-07-23/3.png" alt="Add new environment variable"><span class="image-caption">Add new environment variable</span></div></li>
<li>add new env named <code>OpenCV_DIR</code>, value as <code>&lt;opencv&gt;/build</code> </li>
<li>it may need logout to apply setting, you can check it by <code>echo %PATH%</code>, <code>echo %OpenCV_DIR%</code></li>
</ul>
</li>
</ol>
<hr>
<h3 id="Build-with-EXTRA-MODULES"><a href="#Build-with-EXTRA-MODULES" class="headerlink" title="Build with EXTRA MODULES"></a>Build with EXTRA MODULES</h3><ol>
<li>In step <code>2. Build opencv with cmake</code>, press <code>configure</code></li>
<li>Set up <code>OPENCV_EXTRA_MODULES_PATH</code> to proper path(<code>&lt;opencv_contrib&gt;/modules</code>)</li>
</ol>
<p><img src="/img/2016-07-23/4.png" alt="Set OPENCV_EXTRA_MODULES_PATH as opencv_contrib/modules"><span class="image-caption">Set OPENCV_EXTRA_MODULES_PATH as opencv_contrib/modules</span></p>
<ol>
<li>Press <code>configure</code> again, then <code>generate</code></li>
</ol>
<p>To see more details instructions, see <a href="https://github.com/Itseez/opencv_contrib#how-to-build-opencv-with-extra-modules" target="_blank" rel="external">opencv_contrib</a> README</p>
<hr>
<h3 id="Travis-yml-example"><a href="#Travis-yml-example" class="headerlink" title="Travis.yml example"></a>Travis.yml example</h3><figure class="highlight bash"><figcaption><span>title: travis.yml</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line">language:</div><div class="line">  - cpp</div><div class="line"> </div><div class="line">sudo: required</div><div class="line"> </div><div class="line">compiler:</div><div class="line">  - gcc</div><div class="line"> </div><div class="line"><span class="comment"># building opencv is time consuming, caching it is better</span></div><div class="line">cache:</div><div class="line">    apt: <span class="literal">true</span></div><div class="line">    ccache: <span class="literal">true</span></div><div class="line">    directories:</div><div class="line">        - opencv-3.1.0</div><div class="line">        - opencv_contrib-3.1.0</div><div class="line"> </div><div class="line">install:</div><div class="line"> </div><div class="line">  <span class="comment"># OpenCV dependencies - Details available at: http://docs.opencv.org/trunk/doc/tutorials/introduction/linux_install/linux_install.html</span></div><div class="line">  - sudo apt-get install -y build-essential</div><div class="line">  - sudo apt-get install -y cmake git libgtk2.0-dev pkg-config libavcodec-dev libavformat-dev libswscale-dev</div><div class="line">  - sudo apt-get install -y python-dev python-numpy libtbb2 libtbb-dev libjpeg-dev libpng-dev libtiff-dev libjasper-dev libdc1394-22-dev</div><div class="line"> </div><div class="line">  <span class="comment"># Download v3.1.0 .zip file and extract.</span></div><div class="line">  - curl <span class="_">-s</span>L https://github.com/Itseez/opencv/archive/3.1.0.zip &gt; opencv.zip</div><div class="line">  - unzip -n opencv.zip &gt; <span class="built_in">log</span>1</div><div class="line"> </div><div class="line">  <span class="comment"># Download EXTRA MODULES and extract.</span></div><div class="line">  - curl <span class="_">-s</span>L https://github.com/Itseez/opencv_contrib/archive/3.1.0.zip &gt; opencv_contrib.zip</div><div class="line">  - unzip -n opencv_contrib.zip &gt; <span class="built_in">log</span>2</div><div class="line"> </div><div class="line">  <span class="comment"># Create a new 'build' folder.</span></div><div class="line">  - <span class="built_in">cd</span> opencv-3.1.0</div><div class="line">  - mkdir -p build</div><div class="line">  - <span class="built_in">cd</span> build</div><div class="line"> </div><div class="line">  <span class="comment"># if Makefile is cached, then skip cmake opencv</span></div><div class="line">  <span class="comment"># Set build instructions for Ubuntu distro.</span></div><div class="line">  - cat Makefile &gt; l1 || cmake -D OPENCV_EXTRA_MODULES_PATH=../../opencv_contrib-3.1.0/modules CMAKE_BUILD_TYPE=RELEASE -D CMAKE_INSTALL_PREFIX=/usr/<span class="built_in">local</span> -D WITH_TBB=ON -D BUILD_NEW_PYTHON_SUPPORT=ON -D WITH_V4L=ON -D INSTALL_C_EXAMPLES=ON -D INSTALL_PYTHON_EXAMPLES=ON -D BUILD_EXAMPLES=ON -D WITH_QT=ON -D WITH_OPENGL=ON ..</div><div class="line"> </div><div class="line">  <span class="comment"># if Makefile is cached, then skip make opencv</span></div><div class="line">  <span class="comment"># Run 'make' with four threads.</span></div><div class="line">  - cat Makefile &gt; l2 ||make -j5 &gt; make_log</div><div class="line"> </div><div class="line">  <span class="comment"># Install to OS.</span></div><div class="line">  - sudo make install</div><div class="line"> </div><div class="line">  <span class="comment"># Add configuration to OpenCV to tell it where the library files are located on the file system (/usr/local/lib)</span></div><div class="line">  - sudo sh -c <span class="string">'echo"/usr/local/lib"&gt; /etc/ld.so.conf.d/opencv.conf'</span></div><div class="line"> </div><div class="line">  - sudo ldconfig</div><div class="line">  - <span class="built_in">echo</span> <span class="string">"OpenCV installed."</span></div><div class="line"> </div><div class="line">  <span class="comment"># We need to return to the repo "root" folder, so we can then 'cd' into the C++ project folder.</span></div><div class="line">  - <span class="built_in">cd</span> ../../</div><div class="line">  - ls -al</div><div class="line"> </div><div class="line">script:</div><div class="line">  - cmake CMakeLists.txt</div><div class="line">  - make</div><div class="line">  - <span class="string">"./a.out &gt; log1.txt"</span></div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Build-OpenCV&quot;&gt;&lt;a href=&quot;#Build-OpenCV&quot; class=&quot;headerlink&quot; title=&quot;Build OpenCV&quot;&gt;&lt;/a&gt;Build OpenCV&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Download &lt;a href=&quot;https://github.com/Itseez/opencv&quot;&gt;OpenCV&lt;/a&gt; and &lt;a href=&quot;https://cmake.org/&quot;&gt;Cmake&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Build opencv with cmake&lt;br&gt;&lt;div&gt;&lt;img src=&quot;/img/2016-07-23/1.png&quot; alt=&quot;Cmake configuration&quot;&gt;&lt;/div&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Press &lt;code&gt;configure&lt;/code&gt;, choose &lt;code&gt;visual studio 2015&lt;/code&gt;, finish&lt;/li&gt;
&lt;li&gt;Then press &lt;code&gt;generate&lt;/code&gt;
    
    </summary>
    
    
      <category term="note" scheme="https://ssarcandy.tw/tags/note/"/>
    
      <category term="opencv" scheme="https://ssarcandy.tw/tags/opencv/"/>
    
      <category term="cmake" scheme="https://ssarcandy.tw/tags/cmake/"/>
    
  </entry>
  
</feed>
