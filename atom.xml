<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SSARCandy&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://ssarcandy.tw/"/>
  <updated>2020-01-29T16:42:43.264Z</updated>
  <id>https://ssarcandy.tw/</id>
  
  <author>
    <name>許書軒</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Timing Attack in String Compare</title>
    <link href="https://ssarcandy.tw/2020/01/29/timing-attack/"/>
    <id>https://ssarcandy.tw/2020/01/29/timing-attack/</id>
    <published>2020-01-29T11:28:29.000Z</published>
    <updated>2020-01-29T16:42:43.264Z</updated>
    
    <content type="html"><![CDATA[<p>程式語言通常在執行的時候，為了要最佳化執行的速度，常常會利用所謂的 Early Return。<sup>[1]</sup><br>比如說條件式裡面 <code>if (a &amp;&amp; b)</code> 這種判斷式，假設已經知道 A == false，那其實就可以不需要知道 b 的值，如此就可以直接忽略 b 而達到更快的知道這個判斷式是否為真<sup>[2]</sup>。<br>同樣的這種作法其實會發生在很多地方，比方說像是比對兩個字串是否一樣：在很多程式語言中的實作其實就是遍歷兩個字串比對每一個字元，那只要過程中有一個字元不一樣那這兩個字串肯定就是不一樣，即可提早返回結果。<br><a id="more"></a></p><p>可以用以下的 C++ 程式碼片段實作比較兩個字串是否一樣：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">string_compare</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> s1, <span class="built_in">std</span>::<span class="built_in">string</span> s2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assume s1 and s2 have same length</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; s1.size(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s1[i] != s2[i]) &#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>從上面的邏輯可以看出來，如果第二個字元就不一樣的話，那我們馬上就可以結束整個邏輯然後返回兩個字串不一樣的結果，如此就能提升程式執行的速度。<br>而本文就是要來探討這種字串比對的方式所衍生的其他的安全性問題，也就是所謂的 Timing Attack</p><h1 id="Timing-Attack"><a href="#Timing-Attack" class="headerlink" title="Timing Attack"></a>Timing Attack</h1><blockquote><p>Timing Attack 其實就是所謂的時間差攻擊。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; s1.size(); ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (s1[i] != s2[i]) &#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再來看一下剛剛字串比對的實作中的迴圈，由於這個迴圈實作的關係我們可以知道不同字串比對其實會花不一樣的時間，這很合理因為有時候比較字串到一半的時候我們就已經知道這兩個字串不一樣，所以提早返回結果。<br>那這樣到底有什麼安全性的問題呢？</p><p>試想，今天在輸入密碼的時候輸入錯了，結果電腦告訴你：「喔你第三個字元錯了。」<br>這樣其實蠻奇怪的吧？這表示假設駭客想要猜你的密碼，基本上他就可以先亂猜第一個字元，猜對之後再繼續猜一個字元…以此類推，那勢必可以破解密碼。</p><p>這個例子跟我們剛剛的字串比對其實基本上是同一件事情，因為如果你輸入密碼是<strong>錯的</strong>其實會比輸入<strong>正確</strong>密碼來的<strong>花更少的時間</strong>，因為錯誤密碼可能前幾個字元就錯所以提早返還結果。<br>雖然這時間上的差異幾乎微乎其微，但是只要多做幾次然後再平均一下，還是可以得出有意義的結果。<br>底下是一段程式碼來證明，只要多跑幾次就可以發現字串中不一樣的那個字元如果越後面字串比對的時間就會明顯有差異，利用這樣的資訊就可以慢慢推出答案的字串。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; str&#123;</span><br><span class="line">    <span class="string">"x2345"</span>,</span><br><span class="line">    <span class="string">"1x345"</span>,</span><br><span class="line">    <span class="string">"12x45"</span>,</span><br><span class="line">    <span class="string">"123x5"</span>,</span><br><span class="line">    <span class="string">"1234x"</span>,</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> ss: str) &#123;</span><br><span class="line">    <span class="keyword">auto</span> start = <span class="built_in">std</span>::chrono::system_clock::now();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1e8</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">strcmp</span>(<span class="string">"12345"</span>, ss);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::chrono::duration&lt;<span class="keyword">double</span>&gt; diff&#123;<span class="built_in">std</span>::chrono::system_clock::now() - start&#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ss &lt;&lt; <span class="string">": "</span> &lt;&lt; diff.count() &lt;&lt; <span class="string">" s\n"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這段程式會吐出以下的結果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x2345: 4.07176 s</span><br><span class="line">1x345: 4.89044 s</span><br><span class="line">12x45: 5.79689 s</span><br><span class="line">123x5: 6.84836 s</span><br><span class="line">1234x: 7.37571 s</span><br></pre></td></tr></table></figure><p>可以發現，比較的字串越後面才不一樣，花費越長的時間。這就是 Timing Attack 的主要概念。</p><h1 id="In-Real-World"><a href="#In-Real-World" class="headerlink" title="In Real World"></a>In Real World</h1><p>那在實務上這個漏洞會出現在哪裡呢？<br>其實要先知道這個漏洞的意義：必須要是那個答案字串是敏感資料，像是密碼、或者某種 Token。 如果不是敏感資料那就算可以間接猜出來也是沒有什麼意義。</p><h2 id="Account-Password-Login"><a href="#Account-Password-Login" class="headerlink" title="Account/Password Login"></a>Account/Password Login</h2><p>那就先來說說看最常見的密碼比對好了，現在隨處可見什麼帳號密碼登入，這種東西會不會踩到這個漏洞呢？就我的知識來講：基本上是不會。<br>因為假設是一個正常的後端工程師，他們不會去做所謂的密碼明文儲存。密碼這種東西即使在資料庫裡面也不會是明文儲存的，少說也是會經過一次雜湊而且還要加鹽。<sup>[3]</sup></p><p>$$<br>hash = H(password + salt)<br>$$</p><p>在資料庫存的會是 \(hash\) 而非 \(password\) 。</p><p>使用者輸入帳號密碼的時候，伺服器端會透過同樣的雜湊邏輯，就可以得出跟資料庫儲存的一樣的雜湊，這樣就完成一個正常的密碼驗證。<br>也由於 hashing 會讓輸入的字串跟得到的雜湊有很不一樣的結果，即使只改輸入的密碼一個字元，得到的 hash 也會完全不一樣。這樣的機制導致 Timing Attack 在這個例子上就完全沒有用了，因為攻擊者根本不能預期真正在做字串比對的那個雜湊是不是如攻擊者預期的一個字元一個字元改變，那如此即使有時間上的差異，也跟第幾個字元比對失敗沒有直接的關係。</p><h2 id="Request-Signature"><a href="#Request-Signature" class="headerlink" title="Request Signature"></a>Request Signature</h2><p>那到底有沒有其他例子是真的會需要注意這個漏洞的呢？我能想到的大概就是像是某些加密貨幣交易所，他們的 API 幾乎都需要做所謂的簽章。概念如下：交易所需要透過 API key/secret 確保這個請求是來自合法的使用者，所以每個請求都必須附帶上簽章，公式大概是這樣：</p><p>$$<br>Signature = HMAC(params, private\ key)<br>$$</p><p>這個的用意是使用者利用自己的私鑰去加密請求的參數，來證明自己是真的自己。<br>伺服器端則會用使用者本次請求的參數加上使用者的私鑰來去重組 Signature，假設 Signature 跟請求端附帶的一樣，那就是合法的請求。<br>在駭客的角度，由於沒有使用者的私鑰所以沒有辦法用正規途徑得到 Signature，但是利用 Timing Attack 這招就可以猜出本次請求所對應的 Signature 從而達到偽造身份的效果。但這有幾個不實際的地方：</p><ol><li>利用 Timing Attack 需要大量的嘗試，但通常伺服器端會有 rate limit，根本沒辦法在合理的時間猜到答案。</li><li>再者，這種 Signature 加密機制都會再帶一個所謂的 nonce<sup>[4]</sup>，所以其實實務上也很難有辦法利用 Timing Attack。</li></ol><p>講白了這個攻擊手段我個人覺得看起來很厲害但其實沒這麼可怕。除非是菜鳥工程師，不然實務上不太可能做出會被這個攻擊手段影響的系統…</p><hr><p>Reference:<br>[1] Return early and clearly <a href="https://arne-mertz.de/2016/12/early-return/" target="_blank" rel="noopener">https://arne-mertz.de/2016/12/early-return/</a><br>[2] 這個例子其實是所謂的 Order of evaluation, 跟 Early return 有一點不同。<a href="https://en.cppreference.com/w/cpp/language/eval_order" target="_blank" rel="noopener">https://en.cppreference.com/w/cpp/language/eval_order</a><br>[3] <a href="https://auth0.com/blog/adding-salt-to-hashing-a-better-way-to-store-passwords/" target="_blank" rel="noopener">Adding Salt to Hashing: A Better Way to Store Passwords</a><br>[4] <a href="https://en.wikipedia.org/wiki/Cryptographic_nonce" target="_blank" rel="noopener">nonce</a> 可以有效避免重送攻擊。 (重送攻擊我常常用，可參考我的另一篇文章 <a href="/2019/10/02/game-design-from-perspective-of-hacker/">從奧客玩家視角看遊戲防禦性設計</a>)</p><p>另外補充一篇也是在介紹 Timing Attack 的文 <a href="https://snyk.io/blog/node-js-timing-attack-ccc-ctf/" target="_blank" rel="noopener">Using Node.js Event Loop for Timing Attacks</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;程式語言通常在執行的時候，為了要最佳化執行的速度，常常會利用所謂的 Early Return。&lt;sup&gt;[1]&lt;/sup&gt;&lt;br&gt;比如說條件式裡面 &lt;code&gt;if (a &amp;amp;&amp;amp; b)&lt;/code&gt; 這種判斷式，假設已經知道 A == false，那其實就可以不需要知道 b 的值，如此就可以直接忽略 b 而達到更快的知道這個判斷式是否為真&lt;sup&gt;[2]&lt;/sup&gt;。&lt;br&gt;同樣的這種作法其實會發生在很多地方，比方說像是比對兩個字串是否一樣：在很多程式語言中的實作其實就是遍歷兩個字串比對每一個字元，那只要過程中有一個字元不一樣那這兩個字串肯定就是不一樣，即可提早返回結果。&lt;br&gt;
    
    </summary>
    
    
      <category term="c++" scheme="https://ssarcandy.tw/tags/c/"/>
    
      <category term="note" scheme="https://ssarcandy.tw/tags/note/"/>
    
  </entry>
  
  <entry>
    <title>從奧客玩家視角看遊戲防禦性設計</title>
    <link href="https://ssarcandy.tw/2019/10/02/game-design-from-perspective-of-hacker/"/>
    <id>https://ssarcandy.tw/2019/10/02/game-design-from-perspective-of-hacker/</id>
    <published>2019-10-02T15:31:16.000Z</published>
    <updated>2020-01-29T16:42:43.264Z</updated>
    
    <content type="html"><![CDATA[<p>常常聽到某某遊戲外掛猖獗，作弊仔沒品、破壞遊戲樂趣等等行徑。身為一個好奇寶寶，總是很想知道其中奧秘，雖然我沒有厲害到開發出什麼外掛程式，但這幾年也陸續發現多款遊戲設計上的缺陷，成功用非正當的方式遊玩遊戲 (好含蓄…XD)。看著看著也發現其實這些遊戲的開發者理論上有辦法防止這類型的攻擊，所以只好用我不專業的見解寫下這篇文章。</p><p>對沒錯我就是奧客玩家！</p><blockquote><p>本文提及的遊戲只代表曾經可以作弊，不代表現在或未來也可以。</p></blockquote><a id="more"></a><p>說到這幾年陸續看到隙可趁的遊戲，方法不外乎是兩個，一是藉由封包攔截查看內容再藉由修改封包資訊重送來攻擊，二是直接更改記憶體位置的值，這兩個方法都是非常直接暴力，案例很多，容我一一介紹。</p><h1 id="Metal-Slug-Attack"><a href="#Metal-Slug-Attack" class="headerlink" title="Metal Slug Attack"></a>Metal Slug Attack</h1><div><img src="/img/2019-10-02/1.jpg" alt="這遊戲是我的啟蒙導師，他教會我好多網路傳輸知識。金幣 99999999+ 是基本" data-action="zoom"><span class="image-caption">這遊戲是我的啟蒙導師，他教會我好多網路傳輸知識。金幣 99999999+ 是基本</span></div><p>其實這遊戲我已經寫過一篇文章了，但容我再次鞭屍 🤣</p><p>這遊戲是十分經典只要會察看網路封包，一定有辦法使用重送攻擊。到底什麼是查看封包再重送呢？來看看他的遊戲模式：基本上是關卡制塔防遊戲，勝利可以拿到獎勵。所以當我攔截到<strong>開始</strong>跟<strong>結束</strong>的封包訊息之後，我就可以直接自動刷關了。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"Start event level=HELL......<span class="variable">$i</span>"</span></span><br><span class="line">send_request \</span><br><span class="line">    <span class="string">"cover=1&amp;deck_no=12&amp;stage_id=<span class="variable">$stage_id</span>&amp;unit_ids[]=604&amp;unit_ids[]=485&amp;unit_level[]=50&amp;unit_level[]=50"</span> \</span><br><span class="line">    <span class="string">"https://msattack.snkplaymore.info/event/marathon2nd/battle_start/?kpi1=<span class="variable">$stage_id</span>"</span>  &gt; /dev/null</span><br><span class="line"></span><br><span class="line">send_request \</span><br><span class="line">    <span class="string">"stage_id=<span class="variable">$stage_id</span>&amp;battle_time=25&amp;drop_num=<span class="variable">$drop_num</span>"</span> \</span><br><span class="line">    <span class="string">"https://msattack.snkplaymore.info/event/marathon2nd/battle_win/"</span> &gt; /dev/null</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Win event level=HELL........<span class="variable">$i</span>"</span></span><br></pre></td></tr></table></figure><p>可以看到所有的參數都是透過明文傳輸，唯一的保護是有使用 https，但這樣並無法防止封包被查看，因為只要建立 Proxy server 並自己簽署一個 SSL 憑證，還是可以偷看 https 的封包。<br>那如果我是開發者我會怎麼改善呢？比較基本的是加上 <code>nonce</code> 在 request 裡面並加密參數。<br><code>nonce</code> 本身是一個遞增數字，伺服器端須檢查 <code>nonce</code> 值要是遞增的不然就非合法。這種作法常見於加密貨幣交易所的 API 設計，這也是防止重送攻擊常見的手段。<sup>[1]</sup></p><h1 id="遊戲王-Duel-Links"><a href="#遊戲王-Duel-Links" class="headerlink" title="遊戲王 Duel Links"></a>遊戲王 Duel Links</h1><p>曾經風靡一陣子的遊戲王卡牌遊戲，同時也是伺服器設計有嚴重缺陷，嚴重到我覺得他們工程師可以東西收一收的程度。<br>這遊戲我開服三天就把全腳色練到滿等，同時集齊當時所有 UR SR 卡片，兩個禮拜後覺得太無聊直接棄坑，堪稱我玩過時間最短的遊戲。</p><div><img src="/img/2019-10-02/2.png" alt="Blue Eyes White Dragon!! 我有一打!!" data-action="zoom"><span class="image-caption">Blue Eyes White Dragon!! 我有一打!!</span></div><p>其實他們犯了常見的錯誤，就是所謂 Atomic 操作原則。<br>有些事情是必須一起完成的，否則就應當全部都不算數。比如說：「我用十元買了一枝筆」，那我的錢包應該要減少十元，並且增加一枝筆。這其中每個動作缺一不可：如果錢包沒扣錢，則整段交易應該都要失敗並回復到原本的狀態。這很基本很合理。<br>此遊戲一樣是遊玩扣體力的機制，藉由有限體力來使一般人無法狂練等。但查看封包後發現，他開始關卡跟扣體力是兩個不同的 API，是透過遊戲先發送<strong>開始</strong>再發送<strong>扣體力</strong>的訊息，這樣一來我只要一直狂重送開始但不送扣體力，我就可以無限遊玩刷等。真的太扯了…..</p><p>另外在設計 server side service 時，有一個大原則就是不可以相信客戶端送來的資料，永遠必須做驗證。</p><p>而且客戶端不該發送結果，應該只發送欲執行的操作。用剛剛的例子來說：<br>「我用十元買了一枝筆，我的錢包減少十元，並且增加一枝筆。」→ 由客戶端計算結果是不可以的。<br>「我要用十元買一枝筆。」→ 只發送欲執行的操作，實際結果應由伺服器端執行，才能確保合法性。</p><p>唉，本遊戲真的是奇觀。</p><h1 id="Messanger-籃球、足球"><a href="#Messanger-籃球、足球" class="headerlink" title="Messanger 籃球、足球"></a>Messanger 籃球、足球</h1><p>Messanger 兩年前推出可以在聊天室內玩籃球的彩蛋，浪費了我無數個小時在那邊投籃，其實也是有辦法作弊的。<br>前面提到我目前知道的方法不外乎是藉由封包攔截重送來攻擊或是直接更改記憶體位置的值，facebook 在中間人攻擊下了不少工夫，至少就我的觀察只要使用任何 Proxy server 似乎都會無法正常使用 Messanger，所以封包攔截重送這條路就很難走了。</p><p>剩下試試直接更改記憶體位置吧，基本上原理就是掃過全部此應用程式用到的記憶體位置並尋找指定的數值。比如說投籃好了，投進 1 分時先尋找記憶體中數值等於 1 的，再投進一次就進一步搜尋數值等於 2 的記憶體位置，以此類推直到精確地找到代表分數的記憶體位置，再修改其值。</p><div><img src="/img/2019-10-02/3.png" alt="找到對的記憶體位置，成為灌籃高手不成問題！" data-action="zoom"><span class="image-caption">找到對的記憶體位置，成為灌籃高手不成問題！</span></div><p>很遺憾的是如果遊戲是單機遊戲，基本上是不可能防止記憶體竄改的<sup>[2]</sup>，只能讓他變更難修改沒辦法完全防止。比較常見的做法是增加一個 dirty check 的檢查值，比如說分數的平方。在這樣的設計下，當你的分數被竄改成 \(X\) 時，你的檢查值如果不是 \(X^2\) ，那就代表本次分數不合法。但說實在的這種方式防君子不防小人，真的有耐心的還是找得出檢查值並加以修改…。</p><hr><p>不過其實這類的防禦性設計有時候根本不見得需要，以我上述提到的例子而言，除了遊戲王缺陷太嚴重以外，其實其他的都不見得需要做改善。像是 Metal Slug Attack 無法做到數據的篡改，能做到的只有自動花體力刷關；而 Messanger 的遊戲根本是類單機遊戲，就算拿高分也只是自爽。</p><p>所以到頭來，最有趣的還是尋找系統缺失的過程吧…😅</p><p>References:</p><p>[1] <a href="https://en.wikipedia.org/wiki/Cryptographic_nonce" target="_blank" rel="noopener">Cryptographic nonce</a><br>[2] <a href="https://gamedev.stackexchange.com/questions/48629/how-do-i-prevent-memory-modification-cheats" target="_blank" rel="noopener">How do I prevent memory-modification cheats?</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;常常聽到某某遊戲外掛猖獗，作弊仔沒品、破壞遊戲樂趣等等行徑。身為一個好奇寶寶，總是很想知道其中奧秘，雖然我沒有厲害到開發出什麼外掛程式，但這幾年也陸續發現多款遊戲設計上的缺陷，成功用非正當的方式遊玩遊戲 (好含蓄…XD)。看著看著也發現其實這些遊戲的開發者理論上有辦法防止這類型的攻擊，所以只好用我不專業的見解寫下這篇文章。&lt;/p&gt;
&lt;p&gt;對沒錯我就是奧客玩家！&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本文提及的遊戲只代表曾經可以作弊，不代表現在或未來也可以。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="trashtalk" scheme="https://ssarcandy.tw/tags/trashtalk/"/>
    
  </entry>
  
  <entry>
    <title>Ways to Access Internal Network</title>
    <link href="https://ssarcandy.tw/2019/08/12/Ways-to-Access-Internal-Network/"/>
    <id>https://ssarcandy.tw/2019/08/12/Ways-to-Access-Internal-Network/</id>
    <published>2019-08-11T19:02:06.000Z</published>
    <updated>2020-01-29T16:42:43.264Z</updated>
    
    <content type="html"><![CDATA[<p>一般的公司或者實驗室都會隔離內部資源，只留一個統一的對外出口來達到比較高的安全性以及讓系統管理者較好控管。但是較高的安全性總是會帶來不便，這種隔離內部資源的架構導致我們無法直接存取內部資源，要透過一些拐彎抹角的方式來存取。</p><a id="more"></a><p>從以前當網管到現在工作一陣子之後，因為常常在家工作(加班?)，也累積了不少存取內部資源的方式，本篇就是紀錄一下這些方式，以免我這個金魚腦以後又忘記….</p><h1 id="VPN"><a href="#VPN" class="headerlink" title="VPN"></a>VPN</h1><p>使用 VPN 來存取 LAN 資源我想是最簡單直覺的了，前提是公司或實驗室有提供 VPN server 嘿。<br>阿假設你是系統管理者且你們想提供 VPN 服務，我會推薦使用 OpenVPN server，簡單易用。然後我之前有看到一個大神寫了個一鍵架設 VPN server 的 <a href="https://github.com/Nyr/openvpn-install" target="_blank" rel="noopener">script</a><br>這個 script 從安裝，新增/刪除使用者， 應有盡有，堪稱無敵(?)</p><p>OpenVPN client 端設定很簡單，只要匯入預先產生的金鑰 (<code>.ovpn</code>) 至 client 端應用程式即可。<br>OpenVPN client 端應用程式也是十分完備，無論 Windows/Mac/Android/iOS 全都有！真的可以做到隨時隨地，手機拿起來就可以工作…?</p><h1 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h1><p>如果有時候你只是需要存取某台內部 server，只需要 terminal 環境，那其實直接使用 ssh 登入即可。如同引言所說，「通常一般的公司或者實驗室都會隔離內部資源，只留一個統一的對外出口」，那其實可以透過那台對望出口當作跳板，使用兩次 ssh 來做到登入你想要用的機器。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh -i ssh_key_path -p port username@office.domain.com</span><br><span class="line">ssh username@my_computer</span><br></pre></td></tr></table></figure><p>另外可以設定 ssh_config 來省去每次都要打一長串的指令，設定像這樣：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Host office</span><br><span class="line">    User username</span><br><span class="line">    HostName office.domain.com</span><br><span class="line">    Port 56789</span><br><span class="line">    IdentityFile ssh_key_path</span><br><span class="line"> </span><br><span class="line">Host my_computer_in_lan</span><br><span class="line">    User username</span><br><span class="line">    HostName 192.168.0.xx</span><br><span class="line">    ProxyJump  office</span><br><span class="line">    # If is Windows: use ProxyCommand:</span><br><span class="line">    #     ssh.exe office -W %h:%p</span><br></pre></td></tr></table></figure><p>這樣就只需要輸入 <code>ssh my_computer_in_lan</code> 即可。</p><p>然後給個小建議，系統管理者在設定對外 ssh 服務時，盡量設定成只允許 ssh-key 登入，並且把 ssh port 改成別的 (不要用預設 22)。網路世界很可怕 der~~ 用預設設定就不要抱怨天天被掃 port 或被暴力破解密碼 (想當初實驗室某伺服器 root 帳號被暴力破解，最後只好重灌QQ)。</p><h1 id="SSH-tunnel-browser-proxy"><a href="#SSH-tunnel-browser-proxy" class="headerlink" title="SSH tunnel + browser proxy"></a>SSH tunnel + browser proxy</h1><p>那假設你們的網管不願意提供 VPN 服務，你又想存取內部網頁之類的服務，匹如說內部自架的 GitLab，怎辦？<br>沒關係還是有招，這招叫做使用 ssh tunnel + browser proxy。聽起來很複雜？其實還好啦，這方法分為兩部分：</p><h2 id="打通-ssh-tunnel"><a href="#打通-ssh-tunnel" class="headerlink" title="打通 ssh tunnel"></a>打通 ssh tunnel</h2><p>ssh 其實是一個很強大的工具，藉由他其實可以做到打開一個通道，從你的電腦連通道組織的單一的對外出口，變成說只要透過這個 tunnel ，就等同連結到公司的那台對外的電腦上。指令如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ssh -i ssh_key_path \  <span class="comment"># As usual, use ssh key to access is better</span></span><br><span class="line">    -p 56789 \         <span class="comment"># Your ssh server port</span></span><br><span class="line">    -vvv \             <span class="comment"># robust logging</span></span><br><span class="line">    -NfD 12345 \       <span class="comment"># N: do nothing, f: in background, D: create socket5 proxy</span></span><br><span class="line">    username@office.domain.com</span><br></pre></td></tr></table></figure><p>這神奇指令幫你打通一個 socket5 的通道，然後再設定瀏覽器去使用這個 proxy，就可以達成跟 vpn 一樣的效果！</p><h2 id="設定瀏覽器"><a href="#設定瀏覽器" class="headerlink" title="設定瀏覽器"></a>設定瀏覽器</h2><p>我這邊列出在 Mac 跟 Windows 上設定 proxy 的方式，但我想其他瀏覽器一定也有對應的方式設定。</p><ul><li>Mac: <code>open -a &quot;Google Chrome&quot; --args --proxy-server=&quot;socks5://localhost:12345&quot;</code></li><li>Windows: 在 chrome 上案右鍵 &gt; 內容 &gt; 目標: <code>&quot;C:\Program Files (x86)\Google\Chrome\Application\chrome.exe&quot; --proxy-server=&quot;socks5://localhost:12345&quot;</code></li></ul><h1 id="Use-VSCode-to-access-remote-project"><a href="#Use-VSCode-to-access-remote-project" class="headerlink" title="Use VSCode to access remote project"></a>Use VSCode to access remote project</h1><p>有時候其實只是想用遠端電腦寫程式，用 ssh 當然也可，只是就是限制只能用 vim 之類的編輯器。<br>VSCode 最近推出了實用的 remote-ssh 功能，讓在家也可以使用遠端電腦開發。</p><p>可參考 ssh 那段來設定好 ssh_config，其他就如同平常使用 vscode 一樣，十分方便。</p><hr><p>雜談:</p><ul><li>最近很多想寫想留個紀錄的東西，但總是有點沒時間寫 (或懶?)</li><li>本站最近突破四萬瀏覽囉～！恭喜四萬人浪費了五分鐘 (平均網頁停留時間)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一般的公司或者實驗室都會隔離內部資源，只留一個統一的對外出口來達到比較高的安全性以及讓系統管理者較好控管。但是較高的安全性總是會帶來不便，這種隔離內部資源的架構導致我們無法直接存取內部資源，要透過一些拐彎抹角的方式來存取。&lt;/p&gt;
    
    </summary>
    
    
      <category term="unix" scheme="https://ssarcandy.tw/tags/unix/"/>
    
      <category term="note" scheme="https://ssarcandy.tw/tags/note/"/>
    
  </entry>
  
  <entry>
    <title>Monitoring: from Handcraft to Prometheus</title>
    <link href="https://ssarcandy.tw/2019/06/11/Monitoring-from-Handcraft-to-Prometheus/"/>
    <id>https://ssarcandy.tw/2019/06/11/Monitoring-from-Handcraft-to-Prometheus/</id>
    <published>2019-06-10T16:41:55.000Z</published>
    <updated>2020-01-29T16:42:43.264Z</updated>
    
    <content type="html"><![CDATA[<p>身為一個系統管理者，時常要花時間確保系統正常運行，這時一個好的監控系統就很重要，將所有必要的資訊統整在一個畫面上一目瞭然，既能節省時間，當有問題時又能快速找出問題所在，好處多多。</p><a id="more"></a><p>從前從前，在我還小的時候（大概三四年前），我租了一台小的 Ubuntu cloud server 來跑一些小專案，從那時候開始我就一直想要一個可以監控程式或者伺服器的狀態的東西，那時候查到了 <a href="https://github.com/Tjatse/pm2-gui" target="_blank" rel="noopener">pm2 monitor</a> 跟 <a href="https://github.com/netdata/netdata" target="_blank" rel="noopener">netdata</a> ，其中 netdata 那時候搞半天弄不好（現在有了 docker 大概一秒就搞定吧），再加上我比較在意我的 node.js 的程式狀態，最後選擇使用 pm2 monitor。</p><div><img src="/img/2019-06-11/01.png" alt="pm2 monitor screenshot" data-action="zoom"><span class="image-caption">pm2 monitor screenshot</span></div><p>過一陣子後，正好有機會成為 CMLab 的網管，一下子要管的機器從原本自己的一台變成超過二十台，又重新讓我思考該怎麼才能好好監控這些機器的狀態。那時候前人（學長姊吧?）留下來的一個網頁，採用 snmp 協定將各台資料彙整至 web server，實作上使用 perl 彙整並產生 HTML 檔，呈現如下：</p><div><img src="/img/2019-06-11/02.png" alt="" data-action="zoom"></div><p>老實說雖然簡陋，但完全可以一目瞭然各台機器狀況，可以稱做一個不錯的監控系統了，那時候我也基於這個網頁再實作額外的<a href="https://ssarcandy.tw/2016/11/17/cml-fb-bot/">自動警報系統</a>，當記憶體或 CPU 用量過高時，發警訊到我的 Facebook Messanger 群組。</p><p>從那時候之後我就秉持著要啥自己幹的原則，又利用類似 Pull Based 的方式由一台機器整合的作法，實作出另一套 <a href="https://ssarcandy.tw/2017/08/25/multi-server-gpu-status-monitor/">Multi-server GPU status monitor 暨用量檢舉系統</a>，實驗室大家看起來也是挺喜歡這個的，至今仍在運作。</p><div><img src="/img/2019-06-11/03.png" alt="Multi-server GPU status monitor 暨用量檢舉系統一隅" data-action="zoom"><span class="image-caption">Multi-server GPU status monitor 暨用量檢舉系統一隅</span></div><p>時間快轉到近期，又遇到一樣的狀況：同樣有一堆機器要監控。於是我就又再自幹了一套，只是這次實作方式並非是各自產生資料再由一台彙整的作法，而是一台機器主動去各台電腦撈取狀態。當然，這次重作絕對是做得比以前實驗室那用 perl 寫的來的好看許多，也比較漂亮～</p><div><img src="/img/2019-06-11/04.png" alt="示意圖。任何狀態: 機器死掉、閒置、目前使用狀況都顯示在同一個畫面上。" data-action="zoom"><span class="image-caption">示意圖。任何狀態: 機器死掉、閒置、目前使用狀況都顯示在同一個畫面上。</span></div><p>依舊是要啥自己做、高度客製化，整合所有我想知道的事情，稍微不一樣的是這次我將前後分離，資料搜集器負責蒐集我在意的資料 (metrics)，存成 JSON file 直接由前端抓取，資料形式大致如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"Server"</span>: <span class="string">"research01"</span>,</span><br><span class="line">        <span class="attr">"Uptime"</span>: <span class="string">"178 days"</span>,</span><br><span class="line">        <span class="attr">"Users"</span>: <span class="string">"2 users"</span>,</span><br><span class="line">        <span class="attr">"1m Load"</span>: <span class="string">"0.29"</span>,</span><br><span class="line">        <span class="attr">"5m Load"</span>: <span class="string">"0.34"</span>,</span><br><span class="line">        <span class="attr">"15m Load"</span>: <span class="string">"0.56"</span>,</span><br><span class="line">        <span class="attr">"CPU cores"</span>: <span class="string">"8"</span>,</span><br><span class="line">        <span class="attr">"MemTotal"</span>: <span class="string">"20440876"</span>,</span><br><span class="line">        <span class="attr">"MemAvailable"</span>: <span class="string">"12715432"</span>,</span><br><span class="line">        <span class="attr">"SwapTotal"</span>: <span class="string">"9389048"</span>,</span><br><span class="line">        <span class="attr">"SwapFree"</span>: <span class="string">"8332180"</span>,</span><br><span class="line">        <span class="attr">"DiskTotal"</span>: <span class="string">"531G"</span>,</span><br><span class="line">        <span class="attr">"DiskUsed"</span>: <span class="string">"264G"</span>,</span><br><span class="line">        <span class="attr">"Disk%"</span>: <span class="string">"52"</span>,</span><br><span class="line">        <span class="attr">"Update Time"</span>: <span class="string">"16:15"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    ...</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>這樣做的好處是這些 metrics 可以直接被其他人存取，像是我另外用 React Native 來做手機版的 Dashboard；以及一些 Alerter 就是直接讀取這個 JSON，有別於之前寫的 Facebook Messanger Alerter 去爬網頁才得到資料，少繞一圈。</p><hr><p>然而就在最近，有同事就說：阿幹嘛不用 <a href="https://prometheus.io/" target="_blank" rel="noopener">Prometheus</a> ? 研究一下才發現，嗯…這東西真的很厲害 XD<br>有 <a href="https://prometheus.io/" target="_blank" rel="noopener">Prometheus</a> 當 metric collector，加上 <a href="https://grafana.com/" target="_blank" rel="noopener">Grafana</a> 高度客製化的前端 Dashboard，要監控甚麼幾乎只剩要實作 exporter 而已（而且大部分狀況都有現成的）。</p><p>整個心路歷程走過來，從一開始用簡單的現成工具 =&gt; 自幹 =&gt; 自幹（前後端分離）=&gt; 到最後又回到使用現成但更成熟的工具… 有種繞了一圈的感覺哈哈。<br>但我還是認真覺得我自己做的 Dashboard 比 Grafana 好看…</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;身為一個系統管理者，時常要花時間確保系統正常運行，這時一個好的監控系統就很重要，將所有必要的資訊統整在一個畫面上一目瞭然，既能節省時間，當有問題時又能快速找出問題所在，好處多多。&lt;/p&gt;
    
    </summary>
    
    
      <category term="trashtalk" scheme="https://ssarcandy.tw/tags/trashtalk/"/>
    
      <category term="unix" scheme="https://ssarcandy.tw/tags/unix/"/>
    
  </entry>
  
  <entry>
    <title>Setup Slurm Cluster</title>
    <link href="https://ssarcandy.tw/2019/03/16/Setup-Slurm-Cluster/"/>
    <id>https://ssarcandy.tw/2019/03/16/Setup-Slurm-Cluster/</id>
    <published>2019-03-16T15:06:53.000Z</published>
    <updated>2020-01-29T16:42:43.264Z</updated>
    
    <content type="html"><![CDATA[<p>Slurm 是一個專門拿來做分散式平行運算的平台，已被各式超級運算電腦群集採用<sup>[1]</sup>。跟 Hadoop 其實有點像，但是我個人感覺是 Slurm 好用太多，更穩定更快速，而且不用會 Java…XD<br>最近剛好有機會需要建立以及管理一個 Slurm Cluster，就想說來記錄一下過程以及一些雷。</p><a id="more"></a><p>先來看一張 Slurm 架構的圖，基本上最重要的兩個東西就是 (1) Slurm Controller (slurmctld) 跟 (2) Slurm Compute Node (slurmd)，Controller 是拿來分配任務用的，他管理所有 Compute Node，負責決定哪個任務該去哪個 Node 執行，而 Compute Node 就是真的會執行任務的機器。</p><div><img src="/img/2019-03-16/1.png" alt="Slurm 架構圖。 <sup>[2]</sup>" data-action="zoom"><span class="image-caption">Slurm 架構圖。 <sup>[2]</sup></span></div><p>所以要建置一個 Slurm Cluster，最少要弄一個 Controller 跟多個 Compute Nodes，至於其他像是 slurmdbd 等等，就並不是必需的東西。</p><h1 id="Preparation"><a href="#Preparation" class="headerlink" title="Preparation"></a>Preparation</h1><p>在開始安裝 Controller 跟 Compute Node 之前，要先準備一些事情，</p><ol><li>需要安裝 <code>munge</code>，透過 <code>apt-get install libmunge-dev libmunge2 munge</code> 即可。</li><li>需要創一個 <code>slurm</code> 帳號跟一個 <code>munge</code> 帳號，並且要在所有機器上都有這些帳號 (uid 也必須一致)。</li></ol><p><code>munge</code> 是 slurm 拿來做 Authentication 的組件。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Create a slurm user, and change it to some id, the is must same across nodes.</span></span><br><span class="line">$ useradd slurm; usermod slurm -u 151; groupmod -g 151 slurm;</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Change the munge user id, the is must same across nodes.</span></span><br><span class="line">$ killall munged; usermod munge -u 150; groupmod -g 150 munge; chown munge:munge -R /var/<span class="built_in">log</span>/munge/ /run/munge /var/lib/munge /etc/munge</span><br></pre></td></tr></table></figure><h1 id="Setup-Slurm-Controller"><a href="#Setup-Slurm-Controller" class="headerlink" title="Setup Slurm Controller"></a>Setup Slurm Controller</h1><p>從 apt-get 安裝：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install slurm-wlm slurm-wlm-basic-plugins</span><br></pre></td></tr></table></figure><p>雖然 <code>apt-get install slurm</code> 有東西，但那個不是對的…</p><p>安裝好以後，可以透過一個網頁來設定基本的 config 檔，預設位置在 <code>/usr/share/doc/slurmctld/slurm-wlm-configurator.html</code>，設定好以後存檔並放至 <code>/etc/slurm-llnl/slurm.conf</code>。記得更改權限。然後就可以啟用。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo chown slurm /var/lib/slurm-llnl/slurmctld</span><br><span class="line">$ sudo /etc/init.d/slurmctld start</span><br></pre></td></tr></table></figure><h1 id="Setup-Slurm-Compute-Nodes"><a href="#Setup-Slurm-Compute-Nodes" class="headerlink" title="Setup Slurm Compute Nodes"></a>Setup Slurm Compute Nodes</h1><p>Slurm Compute Node 也可以透過 <code>apt</code> 安裝，但是由於我需要使用 slurm 的一些 api，所以這部分會使用從 source code 建置。</p><p>先安裝 <code>munge</code>，改 user id 以及複製 munge key:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Copy munge key from slurm controller</span></span><br><span class="line">$ scp controller:/etc/munge/munge.key /etc/munge/</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Change the permissions</span></span><br><span class="line">$ chown munge:munge /etc/munge/munge.key</span><br><span class="line">$ chmod 400 /etc/munge/munge.key</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Start munge service</span></span><br><span class="line">$ service munge start</span><br></pre></td></tr></table></figure><p>接下來先下載 slurm source code，並且 build</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Install slurm</span></span><br><span class="line">$ <span class="built_in">cd</span> /tmp; wget https://download.schedmd.com/slurm/slurm-18.08.2.tar.bz2; tar xvjf slurm-18.08.2.tar.bz2; <span class="built_in">cd</span> slurm-18.08.2/</span><br><span class="line">$ (./configure &amp;&amp; make &amp;&amp; make install) | tee /tmp/slurm.setup.log 2&gt;&amp;1</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Copy slurm.conf, and add slurm user</span></span><br><span class="line">$ mkdir /usr/etc /var/spool/slurmctld /var/spool/slurmd</span><br><span class="line">$ scp controller:/usr/etc/slurm.conf /usr/etc/slurm.conf</span><br><span class="line">$ useradd slurm; usermod slurm -u 151; groupmod -g 151 slurm; chown slurm:slurm -R /var/<span class="built_in">log</span>/slurm* /run/slurm* /var/lib/slurm* /etc/slurm* /var/spool/slurm*</span><br></pre></td></tr></table></figure><p>到此基本完成 Slurm Cluster 的設定，可以透過一些指令來檢查 slurm 的狀態。</p><p><strong>sinfo</strong>: 會顯示目前 cluster nodes 的狀態</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PARTITION AVAIL  TIMELIMIT  NODES  STATE NODELIST</span><br><span class="line">research*    up   infinite      1   idle research[01-10]</span><br><span class="line">research*    up   infinite      3  alloc research[11-15]</span><br></pre></td></tr></table></figure><p><strong>squeue</strong>: 顯示目前正在執行/等待執行的任務</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> JOBID PARTITION     NAME     USER ST       TIME  NODES NODELIST(REASON)</span><br><span class="line">578116  research     test  user123  R       0:06      1 research12</span><br><span class="line">578116  research     test  user123  R       0:06      1 research12</span><br><span class="line">578116  research     test  user123  R       0:06      1 research12</span><br><span class="line">578116  research     test  user123  R       0:13      1 research15</span><br><span class="line">578116  research     test  user123  R       0:16      1 research13</span><br></pre></td></tr></table></figure><p><strong>scancel</strong>: 取消任務</p><p>還有很多其他指令，可以看這張 <a href="https://slurm.schedmd.com/pdfs/summary.pdf" target="_blank" rel="noopener">Cheat sheet</a>。</p><h1 id="Some-Common-Issues"><a href="#Some-Common-Issues" class="headerlink" title="Some Common Issues"></a>Some Common Issues</h1><p>使用的過程中總是會遇到一些奇奇怪怪的問題，這邊就列舉一些我常見的:</p><h2 id="Zero-Bytes-were-transmitted-or-received"><a href="#Zero-Bytes-were-transmitted-or-received" class="headerlink" title="Zero Bytes were transmitted or received"></a>Zero Bytes were transmitted or received</h2><p>在使用 slurm 相關的指令時噴出的錯誤。<br>這個基本上是因為 Authentication 出錯，把所有 nodes 的 munge 重啟就會解決。</p><h2 id="Slurm-job-stock-in-CG-state"><a href="#Slurm-job-stock-in-CG-state" class="headerlink" title="Slurm job stock in CG state"></a>Slurm job stock in CG state</h2><p>有時候會發現有一些 Job 就是一直卡在 Completing (CG state)，這時候把那個 node 設為 down 再設為 resume 就會消失了。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ scontrol update nodename=research04 state=down reason=job_stuck;</span><br><span class="line">$ scontrol update nodename=research04 state=resume</span><br></pre></td></tr></table></figure><h2 id="Invalid-job-credential"><a href="#Invalid-job-credential" class="headerlink" title="Invalid job credential"></a>Invalid job credential</h2><p>這表示有些 node 沒有 slurm, munge user，或者他們的 uid 不一致，解決方法就是把他們設為一致。</p><hr><p>Reference:<br>[1] <a href="https://en.wikipedia.org/wiki/Slurm_Workload_Manager" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Slurm_Workload_Manager</a><br>[2] <a href="https://slurm.schedmd.com/overview.html" target="_blank" rel="noopener">https://slurm.schedmd.com/overview.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Slurm 是一個專門拿來做分散式平行運算的平台，已被各式超級運算電腦群集採用&lt;sup&gt;[1]&lt;/sup&gt;。跟 Hadoop 其實有點像，但是我個人感覺是 Slurm 好用太多，更穩定更快速，而且不用會 Java…XD&lt;br&gt;最近剛好有機會需要建立以及管理一個 Slurm Cluster，就想說來記錄一下過程以及一些雷。&lt;/p&gt;
    
    </summary>
    
    
      <category term="unix" scheme="https://ssarcandy.tw/tags/unix/"/>
    
  </entry>
  
  <entry>
    <title>Mac 維修小記</title>
    <link href="https://ssarcandy.tw/2018/08/18/mbpr2015-repair/"/>
    <id>https://ssarcandy.tw/2018/08/18/mbpr2015-repair/</id>
    <published>2018-08-17T20:13:08.000Z</published>
    <updated>2020-01-29T16:42:43.264Z</updated>
    
    <content type="html"><![CDATA[<p>前陣子我的 Macbook pro 13” (2015) 出現奇怪的問題，突然一直跳出訊息叫我連接藍芽滑鼠，內建觸控板跟鍵盤完全失靈，看著電腦登入畫面我卻什麼都做不了，超級崩潰…</p><p>後來稍微多重開機試幾次發現這種狀況有時候會消失，查一下網路發現大概有幾種可能，一是主機板壞了，二是鍵盤跟滑鼠的連接到主機板的排線壞了。但是這兩種壞法修的價格可差距不少，所以我就堅信只是排線壞了（Ｘ</p><a id="more"></a><p>既然都免不了要維修一趟了，又由於官方的螢幕脫膜更換計畫規定是購買日四年內可免費更換，我這台剛好接近過期，就想說順便將我螢幕也換掉。所以我打算維修的問題就有兩件：</p><ol><li>維修鍵盤滑鼠失靈</li><li>更換螢幕</li></ol><p>但由於我螢幕脫膜的情況非常輕微，大概只有一兩根細線般的脫落，所以我先跑去學校內的授權店詢問這種狀況是不是可以更換，結果馬上被打槍說這麼輕微不可能可以換，不信自己去直營店問。</p><p>既然都被這麼打槍了，我就只好轉戰 101 直營店拉…</p><p>久聞直營店非常難排到維修，我每天開 Genius Bar 預約維修，然後無論平日假日時段永遠是滿的，非常驚人…後來發現據說 iPhone 有 App 可以比網頁版多提前預約一天，根本歧視非 iPhone 用戶…難怪網頁版永遠預約不到。嘗試預約兩三天後我就放棄了，打算直接耗一整天去現場排候補維修名額。就這樣，我大約中午時刻到達 101 直營店，進門右手邊就是 Genius Bar 排隊的地方。排到以後會寄一封簡訊來，並在快輪到時會再寄一封來提醒，我自己大概是等了五個小時才輪到我…</p><p>輪到我之後就要我描述狀況，可以的話儘量直接重現問題給他們看，就會減少很多檢測，剛好我那天鍵盤滑鼠依舊是不能使用的狀況，所以他們只跑簡單的檢測就結束了。（為了跑檢測他們還跑去拿外接鍵盤跟滑鼠 XD）</p><p>另外關於螢幕脫膜的部分二話不說直接跟我說可以換～</p><p>後來在報價時跟我說可能要換主機板，我就說我只想換排線跟螢幕，如果要修主機板我就不修了。店員也就如實把我的需求寫進備註。</p><div><img src="/img/2018-08-18/01.png" alt="如果要換主機板我就不想修了。" data-action="zoom"><span class="image-caption">如果要換主機板我就不想修了。</span></div><p>送修之後雖然說 3-5 天會打給我告知維修情況，但根本沒打來…<br>過了大概 20 天之後才寄信來說可以取貨，也附上維修明細。</p><div><img src="/img/2018-08-18/02.png" alt="維修明細，只需支付排線的錢。" data-action="zoom"><span class="image-caption">維修明細，只需支付排線的錢。</span></div><p>總結來說 Apple 直營店的服務還算不錯，更換鍍膜完全不會阻撓，檢測維修時也十分迅速。缺點就是預約維修太難，現場排也要超久真的很花時間…</p><p>所以若需要去直營店維修的話有幾個建議：</p><ul><li>有 iPhone 的話可以用他們的 App 來預約，可以比其他人更容易約到。</li><li>沒有 iPhone 的話…乖乖早點去現場排吧…</li></ul><hr><p>雜談</p><ul><li>有點久沒新文章了…人就是這樣一怠墮就永無止盡QQ</li><li>理論上最近應該是滿閒的應該要提高產出…</li><li>時間都被 Slay the Spire 吃光光…</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前陣子我的 Macbook pro 13” (2015) 出現奇怪的問題，突然一直跳出訊息叫我連接藍芽滑鼠，內建觸控板跟鍵盤完全失靈，看著電腦登入畫面我卻什麼都做不了，超級崩潰…&lt;/p&gt;
&lt;p&gt;後來稍微多重開機試幾次發現這種狀況有時候會消失，查一下網路發現大概有幾種可能，一是主機板壞了，二是鍵盤跟滑鼠的連接到主機板的排線壞了。但是這兩種壞法修的價格可差距不少，所以我就堅信只是排線壞了（Ｘ&lt;/p&gt;
    
    </summary>
    
    
      <category term="trashtalk" scheme="https://ssarcandy.tw/tags/trashtalk/"/>
    
  </entry>
  
  <entry>
    <title>Use PyTorch to solve FizzBuzz</title>
    <link href="https://ssarcandy.tw/2018/01/15/use-pytorch-to-solve-fizzbuzz/"/>
    <id>https://ssarcandy.tw/2018/01/15/use-pytorch-to-solve-fizzbuzz/</id>
    <published>2018-01-14T17:13:49.000Z</published>
    <updated>2020-01-29T16:42:43.264Z</updated>
    
    <content type="html"><![CDATA[<p>FizzBuzz 是一個常見的程式考題，題目很簡單，就是給一個整數，如果可以被 15 整除就回傳 FizzBuzz；可以被 3 整除就回傳 Fizz；被 5 整除就回傳 Buzz；都不能整除就回傳原本的數字。</p><p>用 Python 可以簡單幾行就寫出來：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fizz_buzz</span><span class="params">(num)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> num % <span class="number">15</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'FizzBuzz'</span></span><br><span class="line">    <span class="keyword">elif</span> num % <span class="number">3</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Fizz'</span></span><br><span class="line">    <span class="keyword">elif</span> num % <span class="number">5</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Buzz'</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> str(num)</span><br></pre></td></tr></table></figure><p>不過有狂人就把這當作分類問題，用 tensorflow 來解這個問題，原文<a href="http://joelgrus.com/2016/05/23/fizz-buzz-in-tensorflow/" target="_blank" rel="noopener">在此</a>，是篇很有趣的文章 XD</p><a id="more"></a><p>由於原文是用 tensorflow 實作，我想我就來寫個 PyTorch 版練習一下吧！<br>基本上就是把 FizzBuzz 當作分類問題 (Classification) 來訓練，要做的事大概有這些：</p><ol><li>準備 training, testing data</li><li>定義 model</li><li>Training</li></ol><p>那就來一步一步看看</p><h1 id="準備資料"><a href="#準備資料" class="headerlink" title="準備資料"></a>準備資料</h1><p>雖然 FizzBuzz 輸入是一個整數，但是把他轉成二進位會比較好訓練，所以先來寫個轉二進位的函式：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encode</span><span class="params">(num)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> list(map(<span class="keyword">lambda</span> x: int(x), (<span class="string">'&#123;:010b&#125;'</span>).format(num)))</span><br></pre></td></tr></table></figure><p>因為我不想 <code>import numpy</code>，所以這邊轉二進位的方式是用 Python 的 format 來做。</p><p>另外還要把 FizzBuzz 改寫成回傳分類號碼：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fizz_buzz</span><span class="params">(num)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> num % <span class="number">15</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> <span class="comment"># 'FizzBuzz'</span></span><br><span class="line">    <span class="keyword">elif</span> num % <span class="number">3</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> <span class="comment"># 'Fizz'</span></span><br><span class="line">    <span class="keyword">elif</span> num % <span class="number">5</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> <span class="comment"># 'Buzz'</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span> <span class="comment"># num</span></span><br></pre></td></tr></table></figure><p>接下來要來產生資料拉</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_data</span><span class="params">(num_of_data, batch_size)</span>:</span></span><br><span class="line">    xs, ys = [], []</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(num_of_data):</span><br><span class="line">        x = random.randint(<span class="number">0</span>, <span class="number">2</span>**DIGITS<span class="number">-1</span>)</span><br><span class="line">        xs += [encode(x)]</span><br><span class="line">        ys += [fizz_buzz(x)]</span><br><span class="line">    <span class="keyword">return</span> xs, ys</span><br></pre></td></tr></table></figure><p>由於 training 的時候通常會是一批一批 (batch) 下去訓練的，所以在準備資料時就先一批一批放在一起會比較方便。</p><p>所以改一下，</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_data</span><span class="params">(num_of_data, batch_size)</span>:</span></span><br><span class="line">    xs, ys, data = [], [], []</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(num_of_data):</span><br><span class="line">        x = random.randint(<span class="number">0</span>, <span class="number">2</span>**DIGITS<span class="number">-1</span>)</span><br><span class="line">        xs += [encode(x)]</span><br><span class="line">        ys += [fizz_buzz(x)]</span><br><span class="line">    <span class="keyword">for</span> b <span class="keyword">in</span> range(num_of_data//batch_size):</span><br><span class="line">        xxs = xs[b*batch_size:(b+<span class="number">1</span>)*batch_size]</span><br><span class="line">        yys = ys[b*batch_size:(b+<span class="number">1</span>)*batch_size]</span><br><span class="line">        data += [(xxs, yys)]</span><br><span class="line">    <span class="keyword">return</span> data</span><br></pre></td></tr></table></figure><p>前置步驟都弄好之後，終於可以來產生訓練跟測試資料拉，Batch size 就訂個 32 好了：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">training_data = make_data(<span class="number">1000</span>, <span class="number">32</span>)</span><br><span class="line">testing_data = make_data(<span class="number">100</span>, <span class="number">32</span>)</span><br></pre></td></tr></table></figure><h1 id="定義-Model"><a href="#定義-Model" class="headerlink" title="定義 Model"></a>定義 Model</h1><p>其實我對於如何設計 model 還是沒有很了解，不過這問題應該是挺簡單的，弄個幾層 fully-connected layer 應該就夠了吧?</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FizzBuzz</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, in_channel, out_channel)</span>:</span></span><br><span class="line">        super(FizzBuzz, self).__init__()</span><br><span class="line">        self.layers = nn.Sequential(</span><br><span class="line">            nn.Linear(in_channel, <span class="number">1024</span>),</span><br><span class="line">            nn.ReLU(), <span class="comment"># Activation function</span></span><br><span class="line">            nn.Linear(<span class="number">1024</span>, <span class="number">1024</span>),</span><br><span class="line">            nn.ReLU(), <span class="comment"># Activation function</span></span><br><span class="line">            nn.Linear(<span class="number">1024</span>, out_channel)</span><br><span class="line">        )</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        x = self.layers(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Input 10 digits vector (binary format), output 4 classes vector</span></span><br><span class="line">model = FizzBuzz(<span class="number">10</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure><p>我用了一層隱藏層，1024 個神經元，activation function 則都是最基本的 ReLU 。<br><code>in_channel</code>, <code>out_channel</code> 分別是輸入數字是長度多少的二進位 (10)，以及輸出幾種分類 (4)。<br>PyTorch 的 model 是繼承 <code>torch.nn.Module</code> 來寫個 class，通常只要定義 <code>__init()__</code> 跟 <code>forward()</code>就好，如果要自己做特殊的 backward 的話，也可以實作 <code>backward()</code>。</p><h1 id="Training"><a href="#Training" class="headerlink" title="Training"></a>Training</h1><p>整個訓練的過程基本就是按照一般的分類問題流程做，把資料丟進 model 的到預測，把預測跟正確答案做 cross entropy 當作 loss ，然後去最小化這個 loss</p><p>用 PyTorch 寫大概是這樣：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">training</span><span class="params">(model, optimizer, training_data)</span>:</span></span><br><span class="line">    model.train()</span><br><span class="line">    <span class="keyword">for</span> data, label <span class="keyword">in</span> training_data:</span><br><span class="line">        data = Variable(torch.FloatTensor(data))</span><br><span class="line">        label = Variable(torch.LongTensor(label))</span><br><span class="line">        optimizer.zero_grad() <span class="comment"># Clear gradient</span></span><br><span class="line">        out = model(data) <span class="comment"># predict by model</span></span><br><span class="line">        classification_loss = F.cross_entropy(out, label) <span class="comment"># Cross entropy loss</span></span><br><span class="line">        classification_loss.backward() <span class="comment"># Calculate gradient</span></span><br><span class="line">        optimizer.step() <span class="comment"># Update model parameters</span></span><br></pre></td></tr></table></figure><p>由於 要是 <code>Variable</code> 才能自動算 back propagation ，所以 data 跟 label 都要變成 <code>Variable</code>。<br>這邊我用的 optimize 方法是 Stochastic Gradient Descent (SGD)，記得每次都要先清空 gradient 再做 backward。</p><h1 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h1><p>萬事皆備，可以開始來看看結果如何了，來 train 300 個 Epoch 好了，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">==== Start Training ====</span><br><span class="line">Epoch  50/300, Loss: 0.78973, Accuracy: 64.58%</span><br><span class="line">Epoch 100/300, Loss: 0.29299, Accuracy: 91.67%</span><br><span class="line">Epoch 150/300, Loss: 0.14616, Accuracy: 93.75%</span><br><span class="line">Epoch 200/300, Loss: 0.10606, Accuracy: 96.88%</span><br><span class="line">Epoch 250/300, Loss: 0.09937, Accuracy: 96.88%</span><br><span class="line">Epoch 300/300, Loss: 0.06472, Accuracy: 98.96%</span><br></pre></td></tr></table></figure><p>哇！才 98% 準確率呢… 拿去 online judge 解題大概不會過呢 XD</p><hr><p>如果想要玩玩看我的 code，這邊可以看：<br><a href="https://github.com/SSARCandy/pytorch_fizzbuzz" target="_blank" rel="noopener">https://github.com/SSARCandy/pytorch_fizzbuzz</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;FizzBuzz 是一個常見的程式考題，題目很簡單，就是給一個整數，如果可以被 15 整除就回傳 FizzBuzz；可以被 3 整除就回傳 Fizz；被 5 整除就回傳 Buzz；都不能整除就回傳原本的數字。&lt;/p&gt;
&lt;p&gt;用 Python 可以簡單幾行就寫出來：&lt;/p&gt;
&lt;figure class=&quot;highlight py&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;fizz_buzz&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(num)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; num % &lt;span class=&quot;number&quot;&gt;15&lt;/span&gt; == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;FizzBuzz&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;elif&lt;/span&gt; num % &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt; == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;Fizz&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;elif&lt;/span&gt; num % &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt; == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;Buzz&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; str(num)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;不過有狂人就把這當作分類問題，用 tensorflow 來解這個問題，原文&lt;a href=&quot;http://joelgrus.com/2016/05/23/fizz-buzz-in-tensorflow/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;在此&lt;/a&gt;，是篇很有趣的文章 XD&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="https://ssarcandy.tw/tags/python/"/>
    
      <category term="pytorch" scheme="https://ssarcandy.tw/tags/pytorch/"/>
    
      <category term="machine learning" scheme="https://ssarcandy.tw/tags/machine-learning/"/>
    
  </entry>
  
  <entry>
    <title>搞懂 JavaScript 原型鍊</title>
    <link href="https://ssarcandy.tw/2017/12/06/javascript-prototype-chain/"/>
    <id>https://ssarcandy.tw/2017/12/06/javascript-prototype-chain/</id>
    <published>2017-12-06T00:40:01.000Z</published>
    <updated>2020-01-29T16:42:43.264Z</updated>
    
    <content type="html"><![CDATA[<p>最近突然看到許多關於 js 原型鍊的介紹，這東西我從來沒搞懂過也沒認真想要搞懂過 XD<br>說真的好像不懂也不會影響甚麼，畢竟實戰上基本用不到這些比較底層的東西…<br>但是當作是邊緣冷知識來看看也是挺不錯的~</p><a id="more"></a><h1 id="歷史"><a href="#歷史" class="headerlink" title="歷史"></a>歷史</h1><p>JavaScript，一個為了網頁互動而誕生的腳本語言，最早是因為 Netscape 開發了一個比較成熟的瀏覽器 Navigator，但由於沒有可以讓網頁與使用者互動的方式，所以他們就開發了 JavaScript 來當作網頁的腳本語言，其中主要開發者是 <em>Brendan Eich</em>。<br>由於當時物件導向正夯，Brendan Eich 也決定讓 JavaScript 所有東西都是 Object。<br>如此用途明確的語言，似乎不太需要非常完整的底層架構吧？用不著像 C++, Java 這種泛用式程式語言一樣完整，所以 Brendan Eich 並不打算引入 Class 的概念。但又由於JavaScript 所有東西都是 Object，勢必要有種方法做到類似<strong>繼承</strong>這件事。<br>所以原型鍊就出現了！</p><h1 id="JavaScript-語法背後的運作"><a href="#JavaScript-語法背後的運作" class="headerlink" title="JavaScript 語法背後的運作"></a>JavaScript 語法背後的運作</h1><p>JavaScript 要建構一個 instance 會用 <code>new</code> 關鍵字，但實際上這 <code>new</code> 跟 C++, Java 的不一樣。<br>JavaScript 的 new 其實後面接的是一個 function，類似於 C++ constroctor</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.sayHi = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Hi'</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">var</span> man1 = <span class="keyword">new</span> Person(<span class="string">'Jack'</span>);</span><br><span class="line"><span class="keyword">var</span> man2 = <span class="keyword">new</span> Person(<span class="string">'Andy'</span>);</span><br><span class="line">  </span><br><span class="line"><span class="built_in">console</span>.log(man1.sayHi === man2.sayHi); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>上面這段例子是 JavaScript 創造實例的方式。<br>可以看到 <code>Person</code> 中有兩個東西，一個是 name, 另一個是 Person 的 method <code>sayHi</code>，雖然這樣很好了，但是這樣 <code>man1</code>, <code>man2</code> 中其實包含了一樣的 <code>sayHi</code> function，浪費記憶體空間。</p><p>所以如果要做一個類別共用的方法可以這樣:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">Person.prototype.sayHi = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hi'</span>);</span><br><span class="line">&#125;;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">var</span> man1 = <span class="keyword">new</span> Person(<span class="string">'Jack'</span>);</span><br><span class="line"><span class="keyword">var</span> man2 = <span class="keyword">new</span> Person(<span class="string">'Andy'</span>);</span><br><span class="line">  </span><br><span class="line"><span class="built_in">console</span>.log(man1.sayHi === man2.sayHi); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>把類別共用的 function 寫在 <code>prototype</code> 中就可以達成共用的效果，而其實這個 <code>prototype</code> 就是原型鍊。</p><h1 id="用原型鍊模擬繼承"><a href="#用原型鍊模擬繼承" class="headerlink" title="用原型鍊模擬繼承"></a>用原型鍊模擬繼承</h1><p>我們用瀏覽器偵錯模式印變數的時候，相信經常看到 <code>__proto__</code> 藏在變數裡，那個東東就是原型鍊。<br>JavaScript 中有幾個預設的類別，像是 Object, Array 等等，我們在宣告變數的時候其實裡面都會藉由原型鍊 <strong>串</strong> 到預設的類別。</p><div><img src="/img/2017-12-06/01.PNG" alt="a 的 __proto__ 指向 Object" data-action="zoom"><span class="image-caption">a 的 __proto__ 指向 Object</span></div><p>所以其實在創造實例時，JavaScript 會把 <code>__proto__</code> 指向他的原型，以空物件 <code>{}</code> 而言，就是預設類別 <code>Object</code>。<br>回到上面 Person 的例子，他的原型鍊就會是長這樣:</p><div><img src="/img/2017-12-06/02.PNG" alt="man 的 sayHi 是定義在他的 __proto__ 中" data-action="zoom"><span class="image-caption">man 的 sayHi 是定義在他的 __proto__ 中</span></div><p>可以發現寫在 <code>Person.prototype</code> 的 <code>sayHi</code> ，實際上是定義在 <code>man.__proto__.sayHi</code> ，也就是 Person 的原型，而在呼叫 <code>man.sayHi()</code> 時，由於找不到，所以 JavaScript 會藉由<code>__proto__</code>嘗試往上找，就會在 <code>man.__proto__</code> 中找到。</p><p>而這個一直往上一層原型找的過程，其實就模擬了繼承的效果。</p><h1 id="ES6-語法糖與原型鍊"><a href="#ES6-語法糖與原型鍊" class="headerlink" title="ES6 語法糖與原型鍊"></a>ES6 語法糖與原型鍊</h1><p>雖說 JavaScript 當初沒有 Class 的概念，但在 ES6 中其實出現 class 關鍵字了，但其實這只是一個語法糖而已，可以藉由幾個例子發現 ES6 背後還是透過原型鍊來運作。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">level1</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.x = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  getX() &#123; <span class="keyword">return</span> <span class="keyword">this</span>.x; &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">level2</span> <span class="keyword">extends</span> <span class="title">level1</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">this</span>.y = <span class="number">10</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  getY() &#123; <span class="keyword">return</span> <span class="keyword">this</span>.y; &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> l2 = <span class="keyword">new</span> level2();</span><br></pre></td></tr></table></figure><p>上面這個例子是用 ES6 寫的繼承小程式， level2 繼承 level1 。直接來看看創造出的實例 <code>l2</code> 裡面是什麼:</p><div><img src="/img/2017-12-06/03.PNG" alt="ES6 的繼承其實也是用原型鍊串起來的。" data-action="zoom"><span class="image-caption">ES6 的繼承其實也是用原型鍊串起來的。</span></div><p>又看到原型鍊了！<br><code>l2</code> 的原型鍊串成這樣: <code>l2</code> → <code>level1</code> → <code>Object</code>。<br>看看 <code>getX</code>, <code>getY</code> 就會發現他們定義在不同層級，因為 <code>getX</code> 是父類別的方法，所以在原型鍊中的更上一層。<br>由此就可以看出 ES6 雖然有 class 關鍵字，但其實原理還是原型鍊。</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p>[1] <a href="http://www.ruanyifeng.com/blog/2011/06/designing_ideas_of_inheritance_mechanism_in_javascript.html" target="_blank" rel="noopener">Javascript继承机制的设计思想</a><br>[2] <a href="http://blog.techbridge.cc/2017/04/22/javascript-prototype/" target="_blank" rel="noopener">該來理解 JavaScript 的原型鍊了</a></p><hr><p><strong>雜談</strong><br>除了學校教的 C/C++ 以外，我似乎沒去搞懂過其他語言背後的邏輯，秉持者會用就好的心態活到現在(X<br>這次稍微理解原型鍊以後，好像又更了解一點 JavaScript 了呢～！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近突然看到許多關於 js 原型鍊的介紹，這東西我從來沒搞懂過也沒認真想要搞懂過 XD&lt;br&gt;說真的好像不懂也不會影響甚麼，畢竟實戰上基本用不到這些比較底層的東西…&lt;br&gt;但是當作是邊緣冷知識來看看也是挺不錯的~&lt;/p&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="https://ssarcandy.tw/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>Deep CORAL: Correlation Alignment for Deep Domain Adaptation</title>
    <link href="https://ssarcandy.tw/2017/10/31/deep-coral/"/>
    <id>https://ssarcandy.tw/2017/10/31/deep-coral/</id>
    <published>2017-10-31T13:18:50.000Z</published>
    <updated>2020-01-29T16:42:43.264Z</updated>
    
    <content type="html"><![CDATA[<p>雖然現在可以透過 Deep neural networks 來訓練出非常強大的能力，但卻難以學到比較通用的知識，通常最後訓練出的 model 會只適合處理類似於 training data 的資料。<br>Domain adaption 是目前在 machine learning 比較新的問題，是希望可以讓 network 學到比較跨領域的 features ，進而使訓練出來的模型可以應用在不同 domain 的資料上。</p><p>這篇論文<sup>[1]</sup> (Deep CORAL: Correlation Alignment for Deep Domain Adaptation, B Sun, K Saenko, ECCV 2016) 提出一個 CORAL loss，通過對 source domain 和 target domain 進行線性變換來將他們各自的的二階統計量對齊 (minimizing the difference between source/target correlations).</p><a id="more"></a><h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><ul><li>作者引入了 CORAL<sup>[2]</sup> 這一方法，並且將其擴展成一 differentiable loss function。</li><li>作者藉由 CORAL loss 來做 unsupervised learning，並達到了 state-of-the-art 的 performance。</li><li>CORAL loss 十分簡單並且可以輕易地整合至一般的神經網路中。</li></ul><h1 id="Architecture"><a href="#Architecture" class="headerlink" title="Architecture"></a>Architecture</h1><div><img src="/img/2017-10-31/1.png" alt="作者將 CORAL loss 加進一分類問題的網路架構中。 <sup>[1]</sup>" data-action="zoom"><span class="image-caption">作者將 CORAL loss 加進一分類問題的網路架構中。 <sup>[1]</sup></span></div><p>作者將 Deep CORAL 應用在一般的分類問題上，整個神經網路架構如圖。從中間 <code>cov1</code> ~ <code>fc8</code> 其實就是一般的 AlexNet，只是稍作修改改成有兩個 input (source data &amp; target data) 以及兩個 output。</p><p>在訓練的過程中，每個 batch 都包含了 source data &amp; target data，其中 source data 是包含 label 資料的；而 target data 則完全沒有 label 資料。<br>source data &amp; target data 各自經過一 shared weight 的 networks 之後會有兩個 output，其中:</p><ul><li>source task 會算一個 classification loss</li><li>source 的 <code>fc8</code> 及 target 的 <code>fc8</code> 會再拿來算 CORAL loss</li></ul><p>而總和 loss 為兩者相加:<br>$$<br>loss = l_{CLASS} + \lambda l_{CORAL}<br>$$</p><h1 id="CORAL-Loss"><a href="#CORAL-Loss" class="headerlink" title="CORAL Loss"></a>CORAL Loss</h1><p>作者提出的 CORAL loss 是在計算 source &amp; target covariance matrix 之間的 distance。</p><blockquote><p>We define the CORAL loss as the distance between the second-order statistics<br>(covariances) of the source and target features.</p></blockquote><h2 id="Forward"><a href="#Forward" class="headerlink" title="Forward"></a>Forward</h2><p>而這個 loss function 定義如下:</p><p>$$l_{CORAL} = \frac {1} {4d^{2}} \lVert C_S - C_T \rVert ^{2}_F$$</p><p>其中，<br>\(C_S\), \(C_T\) 為 source, target 的 covariance matrix，其定義如下:</p><p>$$\ C_S = \frac{1}{n_S - 1}(D^{\intercal}_S D_S-\frac {1} {n_S} (\textbf{l}^{\intercal}D_S )^\intercal(\textbf{l}^\intercal D_S))$$</p><p>$$\ C_T = \frac{1}{n_T - 1}(D^{\intercal}_T D_T-\frac {1} {n_T} (\textbf{l}^{\intercal}D_T )^\intercal(\textbf{l}^\intercal D_T))$$</p><p>詳細符號定義可以參考 paper<sup>[1]</sup> section 3.1</p><h2 id="Backward-gradient"><a href="#Backward-gradient" class="headerlink" title="Backward (gradient)"></a>Backward (gradient)</h2><p>至於 gradient 可以由 chain rule 算出來，如下:</p><p>$$<br>\ \frac{\partial l_{CORAL}}{\partial D^{ij}_S}=\frac {1}{d^{2}(n_S-1)} (D^{\intercal}_S-\frac{1}{n_S}((\textbf{l}^{\intercal}D_S )^\intercal\textbf{l}^{\intercal})^{\intercal}(C_S - C_T))^{ij}<br>$$</p><p>$$<br>\ \frac{\partial l_{CORAL}}{\partial D^{ij}_T}=-\frac {1}{d^{2}(n_T-1)} (D^{\intercal}_T-\frac{1}{n_T}((\textbf{l}^{\intercal}D_T )^\intercal\textbf{l}^{\intercal})^{\intercal}(C_S - C_T))^{ij}<br>$$</p><p>注意 target 那邊是有個負號的，當初在實作時忘記這個負號而搞半天…</p><h1 id="Experiment"><a href="#Experiment" class="headerlink" title="Experiment"></a>Experiment</h1><p>作者做的實驗也是在分類問題上，架構如同上面提及的神經網路架構圖。<br>實驗採用 Office31 dataset<sup>[3]</sup>，這是一個專門拿來做 domain adaption 的資料集，裡面有三種不同 domain 的影像: Amazon, DSLR, and Webcam<br>裡面都有相同的 31 種類別，也就是說這三大類唯一不同的點就是圖片的樣貌:</p><ul><li>Amazon 就是去背的圖片(背景都是白色的)</li><li>DSLR 就是用單眼拍的圖片(背景就是真實場景的背景)</li><li>Webcam 跟 DSLR 很相近，差別比較大的部分是 webcam 的畫質比較差，有的還有色偏</li></ul><p>在實驗進行過程中，source data 會有 label；而 target data 則沒有。<br>且在開始之前會先預載 ImageNet pre-trained model。</p><p>由於 Office31 有三種 domain data，所以作者就做了所有 domain adaption 的組合，以下是結果圖:</p><div><img src="/img/2017-10-31/2.png" alt="各種方法比較圖。螢光的是作者的方法。<sup>[1]</sup>" data-action="zoom"><span class="image-caption">各種方法比較圖。螢光的是作者的方法。<sup>[1]</sup></span></div><p>可以看到 D-CORAL 在大部分的 domain adaption tasks 中都取得了最好的成績。</p><p>再來看看其中一個實驗 Amazon → Webcam 的詳細結果:</p><div><img src="/img/2017-10-31/3.png" alt="Amazon → Webcam 的詳細結果圖。<sup>[1]</sup>" data-action="zoom"><span class="image-caption">Amazon → Webcam 的詳細結果圖。<sup>[1]</sup></span></div><p>圖 (a) 比較了有 CORAL loss 與沒有 CORAL loss 的差別，可以看到當加入CORAL loss 之後，target (test) task 有顯著的提升，而且並未使得 source (training) task 的準確率下降太多。</p><p>圖 (b) 則可以看出，classification loss 跟 CORAL loss 其實是扮演互相抗衡的腳色，隨著訓練的進行會讓兩者到達一穩定的狀態。</p><h1 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h1><p>我也試著用 PyTorch 實做了此篇論文的方法，最重要的其實就是新增一 loss function 到整個網路架構中，其中 forward and backward 的算法剛好也有詳細說明。</p><p>Forward 的部分大概如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, source, target)</span>:</span></span><br><span class="line">    d = source.shape[<span class="number">1</span>]</span><br><span class="line">    ns, nt = source.shape[<span class="number">0</span>], target.shape[<span class="number">0</span>]</span><br><span class="line">    cs = feature_covariance_mat(ns, source)</span><br><span class="line">    ct = feature_covariance_mat(nt, target)</span><br><span class="line">    self.saved = (source, target, cs, ct, ns, nt, d)</span><br><span class="line">    res = forbenius_norm(cs - ct)**<span class="number">2</span>/(<span class="number">4</span>*d*d)</span><br><span class="line">    res = torch.FloatTensor([res])</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>Backward 則如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backward</span><span class="params">(self, grad_output)</span>:</span></span><br><span class="line">    source, target, cs, ct, ns, nt, d = self.saved</span><br><span class="line">    ones_s_t = torch.ones(ns).view(<span class="number">1</span>, <span class="number">-1</span>)</span><br><span class="line">    ones_t_t = torch.ones(nt).view(<span class="number">1</span>, <span class="number">-1</span>)</span><br><span class="line">    s_gradient = (source.t() - (ones_s_t.matmul(source).t().matmul(ones_s_t)/ns)).t().matmul(cs - ct) / (d*d*(ns - <span class="number">1</span>))</span><br><span class="line">    t_gradient = (target.t() - (ones_t_t.matmul(target).t().matmul(ones_t_t)/nt)).t().matmul(cs - ct) / (d*d*(nt - <span class="number">1</span>))</span><br><span class="line">    t_gradient = -t_gradient</span><br><span class="line">    <span class="keyword">return</span> s_gradient*grad_output, t_gradient*grad_output</span><br></pre></td></tr></table></figure><p>寫起來公式的部分又臭又長 XD</p><p>我也實際跑了 Amazon → Webcam 的例子，做了個圖:</p><div><img src="/img/2017-10-31/4.png" alt="我做出來的 Amazon → Webcam 的詳細結果圖。" data-action="zoom"><span class="image-caption">我做出來的 Amazon → Webcam 的詳細結果圖。</span></div><p>可以看出有 CORAL loss 的確使得 target task 的準確率提升一些。<br>不過我做出來的整體準確率並沒有與論文上的一樣有 60% 左右，而是大概在 50% 左右，不知道為甚麼… QQ</p><h1 id="Update"><a href="#Update" class="headerlink" title="Update"></a>Update</h1><p>經過 <a href="https://github.com/redhat12345" target="_blank" rel="noopener">redhat12345</a> 的建議後，修正了一下 CORAL Loss 的算法，終於使 Target accuracy 提升到原論文的程度。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">CORAL</span><span class="params">(source, target)</span>:</span></span><br><span class="line">    d = source.data.shape[<span class="number">1</span>]</span><br><span class="line">    <span class="comment"># source covariance</span></span><br><span class="line">    xm = torch.mean(source, <span class="number">1</span>, keepdim=<span class="keyword">True</span>) - source</span><br><span class="line">    xc = torch.matmul(torch.transpose(xm, <span class="number">0</span>, <span class="number">1</span>), xm)</span><br><span class="line">    <span class="comment"># target covariance</span></span><br><span class="line">    xmt = torch.mean(target, <span class="number">1</span>, keepdim=<span class="keyword">True</span>) - target</span><br><span class="line">    xct = torch.matmul(torch.transpose(xmt, <span class="number">0</span>, <span class="number">1</span>), xmt)</span><br><span class="line">    <span class="comment"># frobenius norm between source and target</span></span><br><span class="line">    loss = torch.mean(torch.mul((xc - xct), (xc - xct)))</span><br><span class="line">    loss = loss/(<span class="number">4</span>*d*d)</span><br><span class="line">    <span class="keyword">return</span> loss</span><br></pre></td></tr></table></figure></p><div><img src="/img/2017-10-31/5.png" alt="修正過後的結果。" data-action="zoom"><span class="image-caption">修正過後的結果。</span></div><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p>[1] Sun, B., Saenko, K.: Deep CORAL: Correlation Alignment for Deep Domain Adaptation. In: ECCV (2016)<br>[2] Sun, B., Feng, J., Saenko, K.: Return of frustratingly easy domain adaptation. In: AAAI (2016)<br>[3] <a href="https://people.eecs.berkeley.edu/~jhoffman/domainadapt/#datasets_code" target="_blank" rel="noopener">Domain Adaptation Project</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;雖然現在可以透過 Deep neural networks 來訓練出非常強大的能力，但卻難以學到比較通用的知識，通常最後訓練出的 model 會只適合處理類似於 training data 的資料。&lt;br&gt;Domain adaption 是目前在 machine learning 比較新的問題，是希望可以讓 network 學到比較跨領域的 features ，進而使訓練出來的模型可以應用在不同 domain 的資料上。&lt;/p&gt;
&lt;p&gt;這篇論文&lt;sup&gt;[1]&lt;/sup&gt; (Deep CORAL: Correlation Alignment for Deep Domain Adaptation, B Sun, K Saenko, ECCV 2016) 提出一個 CORAL loss，通過對 source domain 和 target domain 進行線性變換來將他們各自的的二階統計量對齊 (minimizing the difference between source/target correlations).&lt;/p&gt;
    
    </summary>
    
    
      <category term="paper" scheme="https://ssarcandy.tw/tags/paper/"/>
    
      <category term="python" scheme="https://ssarcandy.tw/tags/python/"/>
    
      <category term="pytorch" scheme="https://ssarcandy.tw/tags/pytorch/"/>
    
      <category term="machine learning" scheme="https://ssarcandy.tw/tags/machine-learning/"/>
    
  </entry>
  
  <entry>
    <title>Using PyTorch in Windows 10</title>
    <link href="https://ssarcandy.tw/2017/09/27/using-pytorch-in-windows/"/>
    <id>https://ssarcandy.tw/2017/09/27/using-pytorch-in-windows/</id>
    <published>2017-09-27T14:17:32.000Z</published>
    <updated>2020-01-29T16:42:43.264Z</updated>
    
    <content type="html"><![CDATA[<p>最近開始在使用 PyTorch 寫些東東，他支援 MacOS/Linux 使用，唯獨 Windows 不支援…<br>所以我一直都是使用 Mac 寫相關的東西。</p><p>但是我的桌機都是 Windows，在可以用桌機的環境下卻必須使用小小的 Mac 打字真的不是很高興…<br>正好最近從學長那邊得知有個方法可以讓 Windows 使用 PyTorch ，就趕緊來試試！</p><a id="more"></a><p>Window 10 現在有個東西叫 Windows Subsystem for Linux (WSL) ，是一個在 Windows 下的 Ubuntu 子系統，這個子系統可以做到任何正常 Ubuntu 做得到的事。<br>那我就可以在 WSL 中按照 Linux 的流程設定好 PyTorch 的相關環境，然後在 Windows 中使用 WSL 的 Python 環境，就可以達到目的 (讓 Windows 使用 PyTorch)。</p><p>所以基本上環境設置步驟：</p><ol><li>啟用 Windows Subsystem for Linux 。</li><li>弄好 WSL 中的環境，包含 Python 以及 ssh server 的設定。</li><li>讓 Windows 使用遠端 (WSL) 的 Python 環境。</li></ol><h1 id="Install-Windows-Subsystem-for-Linux"><a href="#Install-Windows-Subsystem-for-Linux" class="headerlink" title="Install Windows Subsystem for Linux"></a>Install Windows Subsystem for Linux</h1><ol><li>開啟<strong>開發人員模式</strong></li><li>用系統管理員開啟 cmd，輸入 <code>OptionalFeatures</code> 指令，會跳出一個視窗</li></ol><div><img src="/img/2017-09-27/01.png" alt="勾選「適用於 Linux 的 Windows 子系統」" data-action="zoom"><span class="image-caption">勾選「適用於 Linux 的 Windows 子系統」</span></div><p>完成以後可能需要重開機。</p><h1 id="Install-PyTorch-in-WSL"><a href="#Install-PyTorch-in-WSL" class="headerlink" title="Install PyTorch in WSL"></a>Install PyTorch in WSL</h1><p>接下來是要在 WSL 中設置 Python 以及 PyTorch 的相關環境。<br>如果沒有 Python 記得先安裝。</p><p>然後安裝 PyTorch，基本上按照 <a href="http://pytorch.org" target="_blank" rel="noopener">PyTorch 官方網站</a> 教學操作：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ pip install http://download.pytorch.org/whl/cu75/torch-0.2.0.post3-cp27-cp27mu-manylinux1_x86_64.whl</span><br><span class="line">$ pip install torchvision</span><br></pre></td></tr></table></figure><h1 id="Install-Python-IDE-PyCharm"><a href="#Install-Python-IDE-PyCharm" class="headerlink" title="Install Python IDE (PyCharm)"></a>Install Python IDE (PyCharm)</h1><p>PyCharm 是一個可以寫 Python 的 IDE，雖然專業版要錢，不過學生免費～YA！</p><p>安裝就不贅述了，反正就是一直下一步…</p><h2 id="設定使用遠端-Python"><a href="#設定使用遠端-Python" class="headerlink" title="設定使用遠端 Python"></a>設定使用遠端 Python</h2><p>由於要用 WSL 裡面的 python，所以必須設定 Remote Python Interpreter</p><ol><li>Project setting &gt; Project interpreter</li><li>Add Remote</li><li>填入 ssh 資訊</li></ol><div><img src="/img/2017-09-27/02.png" alt="填一填 ssh 相關資訊。" data-action="zoom"><span class="image-caption">填一填 ssh 相關資訊。</span></div><p>由於是要透過 ssh 去存取 WSL 中的 Python ，所以 WSL 那邊要開啟 ssh service 好讓 PyCharm 連線。</p><p>在 WSL 中:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo service ssh start</span><br><span class="line">  * Starting OpenBSD Secure Shell server sshd [ OK ]</span><br></pre></td></tr></table></figure><h2 id="設定-Path-mappings"><a href="#設定-Path-mappings" class="headerlink" title="設定 Path mappings"></a>設定 Path mappings</h2><p>WSL 其實是可以存取本機 (Windows) 的資料的，預設 C 槽是掛載在 <code>/mnt/c</code><br>這也要設定一下才能讓 PyCharm 運作正常：</p><ol><li>Project setting &gt; Project interpreter</li><li>新增 mapping <code>C: → /mnt/c</code></li></ol><div><img src="/img/2017-09-27/03.png" alt="設定 Path mapping 的地方也是在 Project setting > Project interpreter" data-action="zoom"><span class="image-caption">設定 Path mapping 的地方也是在 Project setting > Project interpreter</span></div><h1 id="Misc"><a href="#Misc" class="headerlink" title="Misc"></a>Misc</h1><h2 id="開啟-ssh-service-時噴錯"><a href="#開啟-ssh-service-時噴錯" class="headerlink" title="開啟 ssh service 時噴錯"></a>開啟 ssh service 時噴錯</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo service ssh start</span><br><span class="line">initctl: Unable to connect to Upstart</span><br><span class="line">Bind to port 22 on 0.0.0.0 failed: Address already <span class="keyword">in</span> use.</span><br></pre></td></tr></table></figure><p>去更改 <code>/etc/ssh/sshd_config</code> :</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PasswordAuthentication yes</span><br><span class="line">UsePrivilegeSeparation no</span><br><span class="line">Port &lt;random number&gt;</span><br></pre></td></tr></table></figure><p>基本上最重要的就是換個 Port 了，會沒辦法啟動大概是本機 (Windows) 有程式已經占用 Port 22 了。</p><h2 id="不能安裝-PyTorch"><a href="#不能安裝-PyTorch" class="headerlink" title="不能安裝 PyTorch"></a>不能安裝 PyTorch</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ pip install torch-xxx.whl</span><br><span class="line">torch-xxx.whl is not a supported wheel on this platform.</span><br></pre></td></tr></table></figure><p>請檢察 <code>pip -V</code> 版本，起碼要是 9.0 以上，可以用以下方法更新 <code>pip</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip install --upgrade pip</span><br></pre></td></tr></table></figure><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p>[1] <a href="https://blog.birkhoff.me/bash_on_windows_installation/" target="_blank" rel="noopener">Windows Subsystem for Linux (WSL) 安裝教學 &amp; 初體驗</a><br>[2] <a href="https://www.jetbrains.com/help/pycharm/configuring-remote-interpreters-via-wsl.html" target="_blank" rel="noopener">Configuring Remote Interpreters via WSL</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近開始在使用 PyTorch 寫些東東，他支援 MacOS/Linux 使用，唯獨 Windows 不支援…&lt;br&gt;所以我一直都是使用 Mac 寫相關的東西。&lt;/p&gt;
&lt;p&gt;但是我的桌機都是 Windows，在可以用桌機的環境下卻必須使用小小的 Mac 打字真的不是很高興…&lt;br&gt;正好最近從學長那邊得知有個方法可以讓 Windows 使用 PyTorch ，就趕緊來試試！&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="https://ssarcandy.tw/tags/python/"/>
    
      <category term="unix" scheme="https://ssarcandy.tw/tags/unix/"/>
    
      <category term="note" scheme="https://ssarcandy.tw/tags/note/"/>
    
      <category term="pytorch" scheme="https://ssarcandy.tw/tags/pytorch/"/>
    
  </entry>
  
  <entry>
    <title>Multi-server GPU status monitor</title>
    <link href="https://ssarcandy.tw/2017/08/25/multi-server-gpu-status-monitor/"/>
    <id>https://ssarcandy.tw/2017/08/25/multi-server-gpu-status-monitor/</id>
    <published>2017-08-25T15:29:39.000Z</published>
    <updated>2020-01-29T16:42:43.264Z</updated>
    
    <content type="html"><![CDATA[<p>隨著實驗室 GPU 資源日益增加，<br>有越來越多人在抱怨搶不到 GPU、不知道哪台有空的 GPU 、有人佔用太多 GPU 資源等等問題，<br>這些問題似乎跟沒有一個方法可以「一目瞭然的知道所有 GPU 的狀況」有關。</p><p>對，就像是 <a href="https://www.cmlab.csie.ntu.edu.tw/status/" target="_blank" rel="noopener">cml-status</a> 一樣，<br>假設有個 GPU 版的 <a href="https://www.cmlab.csie.ntu.edu.tw/status/" target="_blank" rel="noopener">cml-status</a>，應該就可以讓大家更輕易地找到閒置的 GPU，如果有人佔用過多運算資源也容易發現。</p><p>於是 <a href="https://www.cmlab.csie.ntu.edu.tw/status-gpu/" target="_blank" rel="noopener">CMLab GPU Status</a> 就誕生拉~</p><a id="more"></a><h1 id="現況"><a href="#現況" class="headerlink" title="現況"></a>現況</h1><p>由於我們有數台伺服器是有 GPU 資源的，所以要做出一個網頁版的監控系統大概要有兩個步驟:</p><ol><li>彙整各台資訊到某一台 server</li><li>將這些資訊轉成網頁形式呈現</li></ol><p>對於第一點大概有兩種做法，一是主動去取得資訊，也就是透過 ssh 登入到各個有 GPU 的伺服器詢問資訊；二是各個有 GPU 的伺服器各自回報資訊給某一台來彙整。</p><p>而主動去取得資訊的方法有幾個缺點，</p><ul><li>透過 ssh 登入需要密碼，當然可以透過建立 ssh 認證來省去這一步，但好麻煩 _:(´□`」 ∠):_</li><li>這種方法會使得事情都是一台伺服器在做(又要登入各台又要彙整資訊)，感覺不是很人道…</li></ul><p>另一個方法則是「各自回報，統一呈現」，<br>就是大家各自回報 GPU 狀況，<br>然後由 web server 統一彙整資訊，<br>這種感覺就比較人道一點，大家一起分擔工作~</p><h1 id="各自回報，統一呈現"><a href="#各自回報，統一呈現" class="headerlink" title="各自回報，統一呈現"></a>各自回報，統一呈現</h1><p>決定了大方向的做法以後，可以繼續切分整件事情的流程:</p><ol><li>各台機器如何回報?回報去哪?</li><li>如何彙整?</li><li>如何以網頁呈現?</li></ol><h2 id="各台機器如何回報、回報去哪？"><a href="#各台機器如何回報、回報去哪？" class="headerlink" title="各台機器如何回報、回報去哪？"></a>各台機器如何回報、回報去哪？</h2><div><img src="/img/2017-08-25/1.jpg" alt="實驗室每台伺服器都有共用一個 NFS" data-action="zoom"><span class="image-caption">實驗室每台伺服器都有共用一個 NFS</span></div><p>幸好我們的 server 都有用 NFS ，所以各自回報到 NFS 上就可以讓其他台存取到資訊了。<br>那獲得 GPU 資訊的方法不外乎就是下 <code>nvidia-smi</code> 來取得囉，但說真的這指令太豐富了，所以我改用別的神人做的指令 <a href="https://github.com/wookayin/gpustat" target="_blank" rel="noopener">gpustat</a>，輸出就乾淨多了~</p><div><img src="/img/2017-08-25/2.jpg" alt="gpustat sample output" data-action="zoom"><span class="image-caption">gpustat sample output</span></div><p>所以每一台 GPU server 要做的是「每分鐘回報一次 GPU status 並存至 NFS」，可以透過 <code>crontab</code> 註冊:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># crontab on each GPU server</span></span><br><span class="line">* * * * * /usr/<span class="built_in">local</span>/bin/gpustat -pcu &gt; /NFS/status-gpu/$(hostname)</span><br></pre></td></tr></table></figure><h2 id="如何彙整？"><a href="#如何彙整？" class="headerlink" title="如何彙整？"></a>如何彙整？</h2><p>剛好我們 server 名子都是很沒創意的 cml*，所以彙整相當簡單。<br>由於各自回報的關係，在 NFS 上會有如下的檔案:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-rw-r--r-- 1 root root 875 Aug 25 23:04 cml10</span><br><span class="line">-rw-r--r-- 1 root root 940 Aug 25 23:04 cml11</span><br><span class="line">-rw-r--r-- 1 root root 169 Aug 25 23:04 cml14</span><br><span class="line">-rw-r--r-- 1 root root 682 Aug 25 23:04 cml16</span><br><span class="line">-rw-r--r-- 1 root root 746 Aug 25 23:04 cml19</span><br><span class="line">-rw-r--r-- 1 root root 364 Aug 25 23:04 cml21</span><br><span class="line">-rw-r--r-- 1 root root 169 Aug 25 23:04 cml22</span><br><span class="line">-rw-r--r-- 1 root root 620 Aug 25 23:04 cml23</span><br><span class="line">-rw-r--r-- 1 root root 748 Aug 25 23:04 cml24</span><br><span class="line">-rw-r--r-- 1 root root 747 Aug 25 23:04 cml25</span><br></pre></td></tr></table></figure><p>那要彙整就下個 <code>cat cml*</code> 就解決了。</p><h2 id="如何以網頁呈現？"><a href="#如何以網頁呈現？" class="headerlink" title="如何以網頁呈現？"></a>如何以網頁呈現？</h2><p>最後有了彙整後的資訊後該如何呈現置網頁上呢?<br>由於我們的 web server 有 apache，所以基本上只要多搞個資料夾底下有 <code>index.html</code>就可以了。<br>所以只要想辦法將彙整的資訊轉成 html 即可。</p><p>網路上大神很多，我又發現了 <a href="http://www.pixelbeat.org/scripts/ansi2html.sh" target="_blank" rel="noopener">ansi2html.sh</a> ，這工具可以把 terminal output 轉成 html ，並且連顏色都幫你轉成 css ，太神拉~</p><p>所以要變成網頁呈現就可以註冊個 <code>crontab</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># crontab on web server</span></span><br><span class="line">* * * * * cat /status-gpu/cml* | /bin/sh ansi2html.sh &gt; index.html</span><br></pre></td></tr></table></figure><p>每分鐘重新刷新 <code>index.html</code></p><h1 id="BUG"><a href="#BUG" class="headerlink" title="BUG"></a>BUG</h1><p>做好以後還是逃不掉 BUG 的摧殘QQ<br>有時候會發現彙整的資訊會缺少某幾台 GPU server 的資訊</p><p>查來查去發現原來是因為 <code>crontab</code> 註冊的時間一樣(都是每分鐘)，再加上 NFS 是透過網路傳輸所以會比較慢，導致各自機器每分鐘回報狀況時檔案還沒寫入，web server 就執行彙整動作，就會出現缺檔的情形。<br>解決方式很簡單，就是彙整時間稍微延遲一點，讓各自回報有時間完成。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># crontab on web server</span></span><br><span class="line">* * * * * sleep 30 &amp;&amp; cat /status-gpu/cml* | /bin/sh ansi2html.sh &gt; index.html</span><br></pre></td></tr></table></figure><p>用 sleep 即可延遲指令。</p><hr><p>雜談</p><ul><li>差點這個月就要開天窗了…</li><li>大力募集網管中!</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;隨著實驗室 GPU 資源日益增加，&lt;br&gt;有越來越多人在抱怨搶不到 GPU、不知道哪台有空的 GPU 、有人佔用太多 GPU 資源等等問題，&lt;br&gt;這些問題似乎跟沒有一個方法可以「一目瞭然的知道所有 GPU 的狀況」有關。&lt;/p&gt;
&lt;p&gt;對，就像是 &lt;a href=&quot;https://www.cmlab.csie.ntu.edu.tw/status/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;cml-status&lt;/a&gt; 一樣，&lt;br&gt;假設有個 GPU 版的 &lt;a href=&quot;https://www.cmlab.csie.ntu.edu.tw/status/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;cml-status&lt;/a&gt;，應該就可以讓大家更輕易地找到閒置的 GPU，如果有人佔用過多運算資源也容易發現。&lt;/p&gt;
&lt;p&gt;於是 &lt;a href=&quot;https://www.cmlab.csie.ntu.edu.tw/status-gpu/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CMLab GPU Status&lt;/a&gt; 就誕生拉~&lt;/p&gt;
    
    </summary>
    
    
      <category term="unix" scheme="https://ssarcandy.tw/tags/unix/"/>
    
  </entry>
  
  <entry>
    <title>接案三兩事</title>
    <link href="https://ssarcandy.tw/2017/07/21/about-taking-case/"/>
    <id>https://ssarcandy.tw/2017/07/21/about-taking-case/</id>
    <published>2017-07-21T11:06:10.000Z</published>
    <updated>2020-01-29T16:42:43.264Z</updated>
    
    <content type="html"><![CDATA[<p>最近終於結束了一個搞了很久的 case 。<br>我其實沒什麼接案經驗，這次也是剛好算是學校單位找我做個活動的宣傳網站，我心想既然是學校的應該也不太容易被騙，就來試試看所謂的接案。<br>在這次經驗中其實也是學到不少東西、踩了很多雷，大部份都是因為沒什麼經驗導致踩到的很多很多算專案管理相關的雷。<br>如果還有下次的話，一定要注意一些事情才可以讓整個案子的進行更加順利。</p><a id="more"></a><h1 id="一定要寫好合約"><a href="#一定要寫好合約" class="headerlink" title="一定要寫好合約"></a>一定要寫好合約</h1><p>這看起來是基本中的基本，但我當初就是沒做(掩面<br>當初只有口頭說好而已。<br>這件事情之所以重要，是因為這是個最基本的保障，不論是對我們或是對客戶方，<br>和約可以說清楚講明白我們到底要做什麼?哪些是我們的負責範圍、哪些不是?<br>然後當然還有其他的細節，包含價格，時程等等都應該要寫在合約。</p><h1 id="一定要訂好時程"><a href="#一定要訂好時程" class="headerlink" title="一定要訂好時程"></a>一定要訂好時程</h1><p>在這次的案子中我遇到最大的問題就是：我們開發好了 ，但是客戶卻一直沒時間驗收，導致每次來回 feedback 就可能拖了好幾個月。</p><p>這樣造成很多問題一個是實在是拖太久了，隔好幾個月才又重起專案做起來真的很煩；另一方面客戶方也會覺得我們做得很慢。因為我們做出來的東西不一定是客戶想要的，一來一回修正就花掉太多時間，整體而言就會有我們也開發得很慢的感覺。</p><p>如果當初可以在合約中訂好幾次 check point 的時間點，至少就可以確保不會無限期拖延下去。</p><h1 id="一定要找好對口"><a href="#一定要找好對口" class="headerlink" title="一定要找好對口"></a>一定要找好對口</h1><p>我這邊指得對口是指:「 可以快速獲得 feedback 的人」。<br>因為我們這一次的開發包含了所有的設計，都是我們負責。但是呢，扯到設計這種比較主觀的東西，我們做出來的並不一定客戶接受。所以與其等到 check point 再來被客戶打槍要求重做，不如當初就先確保一個客戶方的對口，才可以在我們做 prototype 時就迅速的確認到底是不是符合他們想要的。</p><p>簡單來說，確認對口就是可以使我們少做很多白工。</p><h1 id="不要使用別人不熟悉的工具"><a href="#不要使用別人不熟悉的工具" class="headerlink" title="不要使用別人不熟悉的工具"></a>不要使用別人不熟悉的工具</h1><p>這個點其實跟上一點有一點關係。案子開發到後期勢必是有一些 BUG 或其他要調整的部分。所以也是必須要追蹤這些 issue。<br>那當然大家都認為 github issue tracker 很好用很棒，但事實上客戶這邊根本不會使用這種工具，最後就會變成他們根本沒在看。<br>所以與其用我們工程師覺得好用的工具，不如使用大家都會用的工具。像是在這一次的案子裡我的 issue tracker 是簡單的用 Google sheet 拉一拉表格，這樣反而更能讓客戶清楚知道我們的進度。</p><p>即時通訊也是，工程師可能覺得 Slack 很棒很適合案子的溝通，但事實上就是客戶那邊永遠都不會上線 XD<br>所以反而使用私人的 Facebook Messanger 還比較有效率。</p><h1 id="錢的事情要講清楚"><a href="#錢的事情要講清楚" class="headerlink" title="錢的事情要講清楚"></a>錢的事情要講清楚</h1><p>有一件事情我體會深刻，就是「錢的事情一定要講清楚」。<br>也不要覺得自己的開價會不會太貴，因為會不會太貴是客戶那邊該煩惱的 XD<br>雖然每一個案子可能順利的程度不同，但是我個人認為接案一定會比想像中的麻煩。<br>所以在錢的方面一定要開一個確保自己不會做到覺得「很不划算」。<br>具體而言大概就是你覺得可以的價格再乘以 1.5 倍，到時候你會覺得這才只是「剛剛好的價格」。</p><p>另外，錢也是應該要有先付、後付的部分，才比較有點保障，至少不會一毛錢都拿不到的風險。<br>像我這一次的案子就因為也沒有寫合約所以最後變成是結案了才要付錢，那這樣子其實對於接案方非常虧，因為他們隨時可以突然說案子不要做了，然後我就會變成做一堆但啥都拿不到。</p><p>總而言之，錢的事情就幾個原則：</p><ol><li>開一個比自己覺得 ok 的價格高一點的價格，因為接案的過程肯定會比想像中的麻煩。</li><li>先付後付、怎麼分配都應該於一開始的合約中訂好。</li></ol><hr><p>雜談</p><ul><li>自從決定要弄個部落格以後，就一直督促自己一個月起碼要寫個一篇文章，自今也滿一年了，可喜可賀～</li><li>最近剛修正了身體的一個 BUG，看來要痛苦一陣子了。</li><li>正事依舊沒啥進展，果然我吃草吃太久了QQ</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近終於結束了一個搞了很久的 case 。&lt;br&gt;我其實沒什麼接案經驗，這次也是剛好算是學校單位找我做個活動的宣傳網站，我心想既然是學校的應該也不太容易被騙，就來試試看所謂的接案。&lt;br&gt;在這次經驗中其實也是學到不少東西、踩了很多雷，大部份都是因為沒什麼經驗導致踩到的很多很多算專案管理相關的雷。&lt;br&gt;如果還有下次的話，一定要注意一些事情才可以讓整個案子的進行更加順利。&lt;/p&gt;
    
    </summary>
    
    
      <category term="trashtalk" scheme="https://ssarcandy.tw/tags/trashtalk/"/>
    
  </entry>
  
  <entry>
    <title>Coherent Line Drawing</title>
    <link href="https://ssarcandy.tw/2017/06/26/Coherent-Line-Drawing/"/>
    <id>https://ssarcandy.tw/2017/06/26/Coherent-Line-Drawing/</id>
    <published>2017-06-25T16:14:38.000Z</published>
    <updated>2020-01-29T16:42:43.260Z</updated>
    
    <content type="html"><![CDATA[<p>線條藝術畫(line drawing) 是最簡單的一種視覺呈現圖畫的方式，僅僅是幾條線條即能清楚的表示出圖片中的物件。<br>這篇論文(Coherent Line Drawing’ by Kang et al, Proc. NPAR 2007)提出一個全自動的方法，可以將相片轉換成簡單、高品質的線條畫風格圖片。</p><div><img src="/img/2017-06-26/01.jpg" alt="輸入一張影像，即可產生出一張線條藝術風格畫。" data-action="zoom"><span class="image-caption">輸入一張影像，即可產生出一張線條藝術風格畫。</span></div><a id="more"></a><h1 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h1><p>本篇論文的方法主要流程如下：</p><ol><li>由輸入影像產生邊緣向量流場</li><li>反覆的精煉、平滑化邊緣向量流場</li><li>藉由邊緣向量流場的資訊，對原圖套用高斯差以產生特徵線條</li></ol><div><img src="/img/2017-06-26/02.jpg" alt="整個方法的流程圖： 由原圖產生邊緣向量流場，再藉由流場資訊套用高斯差產生線條畫。" data-action="zoom"><span class="image-caption">整個方法的流程圖： 由原圖產生邊緣向量流場，再藉由流場資訊套用高斯差產生線條畫。</span></div><h2 id="Edge-Tangent-Flow"><a href="#Edge-Tangent-Flow" class="headerlink" title="Edge Tangent Flow"></a>Edge Tangent Flow</h2><p>由於線條畫的特性希望是能夠保留原圖重要的特徵邊緣，所以對應的邊緣向量流場(Edge Tangent Flow)必須滿足幾個條件：</p><ol><li>可以描述重要邊緣的流向。</li><li>鄰近的向量必須要平滑(避免鄰近的向量方向差太多)，除非是角落。</li><li>重要的邊緣必須要維持它原本的方向。</li></ol><h3 id="Generate-initial-ETF"><a href="#Generate-initial-ETF" class="headerlink" title="Generate initial ETF"></a>Generate initial ETF</h3><p>而本篇產生 ETF 的方法是藉由反覆的平滑化流場來得到一個符合上述各個條件的 ETF。<br>首先，藉由 原圖產生灰階梯度流場 (Gradient Vector Field)，再逆時鐘旋轉 90 度來 產生初始的邊 緣向量流場 (ETF)。</p><div><img src="/img/2017-06-26/03.jpg" alt="對原圖做適當模糊後即可取得灰階梯度向量(GVF)，再旋轉 90 度可得一個初始的 ETF。" data-action="zoom"><span class="image-caption">對原圖做適當模糊後即可取得灰階梯度向量(GVF)，再旋轉 90 度可得一個初始的 ETF。</span></div><h3 id="Refining-ETF"><a href="#Refining-ETF" class="headerlink" title="Refining ETF"></a>Refining ETF</h3><p>再將這個初始的 ETF 做平滑化，方法如下：</p><p>$$<br>t^{new}=\dfrac {1} {k}\sum _{y\in \Omega \left( x\right) }\phi \left( x,y\right) t^{cur}\left(y\right)w_{s}\left( x,y\right)w_{m}\left( x,y\right)w_{d}\left( x,y\right)<br>$$</p><p>其中，<br>\(w_{s}\left( x,y\right)\) 是一個圓形 box filter function，落在外面的向量權重為零<br>\(w_{m}\left( x,y\right)\) 為 magnitude weight function，用於確保重要的邊緣方向會被保留<br>\(w_{d}\left( x,y\right)\) 為 direction weight function，用於使得鄰居的向量方向不會差距過大<br>\(\phi \left( x,y\right)\) 則是當兩向量夾角過大時會反轉方向以確保夾角不會大於 90 度</p><p>透過以上的方法，只須要決定 kernel size 即可反覆平滑化 即可反覆平滑化 邊緣向量流場 直至夠平 滑為止 。</p><div><img src="/img/2017-06-26/04.jpg" alt="由左至右：原圖、用 GVF 得到之初始 ETF、經過一次平滑化、經過兩次平滑化。 kernel size=7" data-action="zoom"><span class="image-caption">由左至右：原圖、用 GVF 得到之初始 ETF、經過一次平滑化、經過兩次平滑化。 kernel size=7</span></div><h2 id="Line-construction"><a href="#Line-construction" class="headerlink" title="Line construction"></a>Line construction</h2><p>有了 ETF 之後就可以進入下一步：產生線條。<br>比起一般邊緣偵測的方法如 Sobel、Canny 等等固定 kernel size，這篇論文的方法則是使用 flow-based kernel ，也就是 kernel 會沿著流場有著不一樣的形狀。</p><div><img src="/img/2017-06-26/05.jpg" alt="(a)原圖、(b)ETF、(c)沿著流場的 kernel。<sup>[1]</sup>" data-action="zoom"><span class="image-caption">(a)原圖、(b)ETF、(c)沿著流場的 kernel。<sup>[1]</sup></span></div><h3 id="Flow-based-Difference-of-Gaussians"><a href="#Flow-based-Difference-of-Gaussians" class="headerlink" title="Flow-based Difference-of-Gaussians"></a>Flow-based Difference-of-Gaussians</h3><p>根據 flow-based kernel 來進行 Difference-of-Gaussians(DoG) ，藉此來找出足夠符合重要線條的像素們。</p><div><img src="/img/2017-06-26/06.jpg" alt="(d)kernel 詳細圖示、(e)高斯差示意圖。<sup>[1]</sup>" data-action="zoom"><span class="image-caption">(d)kernel 詳細圖示、(e)高斯差示意圖。<sup>[1]</sup></span></div><p>首先先對每個像素沿著 ETF 垂直方向做一維的 DoG，亦即對圖中 -T~T 做 DoG：</p><p>$$<br>F\left( s\right) =\int _{-T}^{T}I\left( l_{s}\left( t\right) \right) f\left( t\right) dt<br>$$</p><p>其中 \(f\left( t\right) = G_{\sigma_{c}}\left( t \right)-\rho G_{\sigma_{s}}\left( t \right)\) 就是高斯差的部分。</p><p>再來再沿著 -S~S 做一維的高斯加權：</p><p>$$<br>G\left( x\right) =\int _{-S}^{S}G_{\sigma}\left( s \right) F\left( s\right) ds<br>$$</p><p>這樣的方法除了可以使邊緣更有一致性(不會有太多短線)並且又可以抑制雜訊，使得產生出的結果很符合線條畫的特性。這即是這篇所提出的 Flow-based Difference of Gaussians(FDoG)。</p><h3 id="Iterative-FDoG-filtering"><a href="#Iterative-FDoG-filtering" class="headerlink" title="Iterative FDoG filtering"></a>Iterative FDoG filtering</h3><p>有時候做一次 FDoG 效果並不夠好，所以可以藉由反覆做 FDoG 來達到更良好的效果。<br>要反覆套用 FDoG 也很容易，只要將原圖與 FDoG 的輸出疊合，然後以這新的圖片當作原圖再次套用一次 FDoG 即可。</p><div><img src="/img/2017-06-26/07.jpg" alt="藉由將結果疊合回原圖再做一次 FDoG，可以使的結果品質越來越好。" data-action="zoom"><span class="image-caption">藉由將結果疊合回原圖再做一次 FDoG，可以使的結果品質越來越好。</span></div><p>實作上也很簡單，就是把結果的黑色部分直接覆蓋在原圖然後拿這再做 FDoG。注意雖然原圖改變了，但是使用的 ETF 並沒有重新計算。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Superimposing the black edge pixels of the previous binary output</span></span><br><span class="line"><span class="comment"> * upon the original image</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; originalImg.rows; y++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; originalImg.cols; x++) &#123;</span><br><span class="line">        <span class="keyword">float</span> H = result.at&lt;uchar&gt;(y, x);</span><br><span class="line">        <span class="keyword">if</span> (H == <span class="number">0</span>) &#123;</span><br><span class="line">            originalImg.at&lt;uchar&gt;(y, x) = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Results"><a href="#Results" class="headerlink" title="Results"></a>Results</h1><p>基本上圖片在 512x512 左右的大小可以在 3 秒內產生結果，若平行化則即使是更大張的圖片也可達到 real time。</p><div style="display:flex; align-items:center;"><br><div><img src="/img/2017-06-26/08.jpg" alt="輸入影像。由左上至右下：蔣公、廟、燈塔、老鷹。" data-action="zoom"><span class="image-caption">輸入影像。由左上至右下：蔣公、廟、燈塔、老鷹。</span></div><br><div><img src="/img/2017-06-26/09.jpg" alt="輸出結果。由左上至右下：蔣公、廟、燈塔、老鷹。" data-action="zoom"><span class="image-caption">輸出結果。由左上至右下：蔣公、廟、燈塔、老鷹。</span></div><br></div><h1 id="Source-code"><a href="#Source-code" class="headerlink" title="Source code"></a>Source code</h1><p>You can find my implementation source code at <a href="https://github.com/SSARCandy/Coherent-Line-Drawing" target="_blank" rel="noopener">github</a><br>Or download pre-build version <a href="https://github.com/SSARCandy/Coherent-Line-Drawing/releases" target="_blank" rel="noopener">here</a></p><div><img src="/img/2017-06-26/10.jpg" alt="Screenshot of my system user interface" data-action="zoom"><span class="image-caption">Screenshot of my system user interface</span></div><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p>[1] Image from ‘Coherent Line Drawing’ by Kang et al, Proc. NPAR 2007</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;線條藝術畫(line drawing) 是最簡單的一種視覺呈現圖畫的方式，僅僅是幾條線條即能清楚的表示出圖片中的物件。&lt;br&gt;這篇論文(Coherent Line Drawing’ by Kang et al, Proc. NPAR 2007)提出一個全自動的方法，可以將相片轉換成簡單、高品質的線條畫風格圖片。&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;/img/2017-06-26/01.jpg&quot; alt=&quot;輸入一張影像，即可產生出一張線條藝術風格畫。&quot; data-action=&quot;zoom&quot;&gt;&lt;/div&gt;
    
    </summary>
    
    
      <category term="c++" scheme="https://ssarcandy.tw/tags/c/"/>
    
      <category term="opencv" scheme="https://ssarcandy.tw/tags/opencv/"/>
    
      <category term="rendering" scheme="https://ssarcandy.tw/tags/rendering/"/>
    
      <category term="paper" scheme="https://ssarcandy.tw/tags/paper/"/>
    
  </entry>
  
  <entry>
    <title>Panorama image stitching</title>
    <link href="https://ssarcandy.tw/2017/05/26/panorama-image-stitching/"/>
    <id>https://ssarcandy.tw/2017/05/26/panorama-image-stitching/</id>
    <published>2017-05-25T17:28:09.000Z</published>
    <updated>2020-01-29T16:42:43.264Z</updated>
    
    <content type="html"><![CDATA[<p>全景照(panorama) 現在已普遍存在手機的相機軟體中，是一種可以拍攝數張照片然後接在一起使整個視野變更大的方法，全景照常比較常見的是往同一方向拍攝的，但也是有上下左右都全景的那種(Photo Sphere)。<br>以一般往同方向拍攝的一系列照片來說，要合出一張完整的全景照理論上就是將這一系列的照片重疊的部分對齊就可以了。<br>但實際上還是需要經過一系列的方法，才能接合出比較良好的全景照。</p><a id="more"></a><h1 id="Warp-images-to-cylinder"><a href="#Warp-images-to-cylinder" class="headerlink" title="Warp images to cylinder"></a>Warp images to cylinder</h1><p>由於360全景影像的特性，是利用相機旋轉拍攝出環場影像，所以在做偵測特徵點或將照片接起來之前，必須先投影到圓柱體上才會有比較好的效果。</p><div><img src="/img/2017-05-26/01.jpg" alt="內圈的黑線分別代表六張照片的成像平面，紅線則是要投影到的圓柱面。<sup>[1]</sup>" data-action="zoom"><span class="image-caption">內圈的黑線分別代表六張照片的成像平面，紅線則是要投影到的圓柱面。<sup>[1]</sup></span></div><p>如同上圖所示，真正拍到的影像是內圈的黑線，分別代表六張照片，但是要接起來必須重新投影到外圈紅色才會接得上。</p><div><img src="/img/2017-05-26/02.jpg" alt="右邊的圖木紋的直線都變成有個曲率的彎線。" data-action="zoom"><span class="image-caption">右邊的圖木紋的直線都變成有個曲率的彎線。</span></div><p>這是我將影像投影至圓柱前後的差別，可以看見右邊的圖木紋的直線都變成有個曲率的彎線，這就是投影之後造成的差異。</p><h1 id="Feature-detection"><a href="#Feature-detection" class="headerlink" title="Feature detection"></a>Feature detection</h1><p>要找出兩兩照片中的特徵點才好找出照片間的相對位置，所以首先要找出特徵點，這邊我實作的是 Harris corner detector。</p><div><img src="/img/2017-05-26/03.jpg" alt="左:用棋盤圖來當作測試資料；右: corner response image" data-action="zoom"><span class="image-caption">左:用棋盤圖來當作測試資料；右: corner response image</span></div><p>這是利用 Harris corner 找出的 corner response image，可以看到交叉點的值都比較高(紅色點)，而這些就是應該要挑出來的特徵點。</p><h1 id="Feature-descriptor"><a href="#Feature-descriptor" class="headerlink" title="Feature descriptor"></a>Feature descriptor</h1><p>Descriptor 是用來描述特徵點的東西，通常是以高維度的向量來表示，我則是使用 Harris corner 算出 corner response image 之後，將最高的 1% 的點抓出來，以一個 5x5 的 window 來表示成 25 維的向量。</p><div><img src="/img/2017-05-26/04.jpg" alt="以周邊像素的值當作 descriptor。<sup>[1]</sup>" data-action="zoom"><span class="image-caption">以周邊像素的值當作 descriptor。<sup>[1]</sup></span></div><p>這是一個 3x3 window 所表示的9維向量，實作上我是使用 5x5。</p><p>找出來以後，我還做了一些處理來減少 feature points 的數目:</p><ol><li>只挑選corner response 最高的 1%</li><li>切掉上下邊緣(因為投影到圓柱之後會有黑邊)</li><li>做 local suppression</li></ol><div><img src="/img/2017-05-26/05.jpg" alt="由左至右分別是: 前 1% 的features、切掉上下邊緣、以一個 window size 掃過整張圖，每個 window 中只保留最強的 feature。" data-action="zoom"><span class="image-caption">由左至右分別是: 前 1% 的features、切掉上下邊緣、以一個 window size 掃過整張圖，每個 window 中只保留最強的 feature。</span></div><p>減少 feature 數目最主要的原因是因為希望加快運算速度。</p><h1 id="Feature-matching"><a href="#Feature-matching" class="headerlink" title="Feature matching"></a>Feature matching</h1><p>再來就是match出兩兩圖片中對應的點，我用的方法很簡單，就是將兩個影像中找出的 feature descriptors 互相算出向量距離，找出對應的組合。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(descriptor1)):</span><br><span class="line">    min_distance = inf</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(len(descriptor2)):</span><br><span class="line">        distance = ((descriptor1[i]-descriptor2[j])**<span class="number">2</span>).sum() </span><br><span class="line">        <span class="keyword">if</span> distance &lt; min_distance:</span><br><span class="line">            min_distance = distance</span><br></pre></td></tr></table></figure><p>以 psudo-code 來表示的話就是兩個 for loop 一個一個算距離找出最小的那組合。是最暴力最直覺的方式 XDDD</p><p>其實我也有嘗試對 descriptors 建立 KD-tree 來加速整個 matching 的過程，但是由於 descriptor 是個 25 維的向量，使用 KD-tree 幾乎沒有速度上的優勢，所以最後還是只用這種最單純的算法。<br>另外，為了達到更好以及更快的 matching 效果，我有定一個假設:「前後兩張影像的垂直差異不會過大」，雖說這假設並不一定成立，但是在 360 環場影像的狀況下還算符合。</p><div><img src="/img/2017-05-26/06.jpg" alt="兩張影像中對應的點，以紅色連線來表示。" data-action="zoom"><span class="image-caption">兩張影像中對應的點，以紅色連線來表示。</span></div><h1 id="Find-best-warp-model-using-RANSAC"><a href="#Find-best-warp-model-using-RANSAC" class="headerlink" title="Find best warp model using RANSAC"></a>Find best warp model using RANSAC</h1><p>再來就是要找出最好的 translation model，進而移動影像來讓兩張影像中相同的部分疊在一起，這邊我用 RANSAC 來找出最佳的 translation model。<br>RANSAC 基本精神就是隨機挑兩個點的相對位置當作最好的 translation model，然後讓所有 matched pair 都套用這個 model，再來計算有多少個 pair 套用這 model 之後也是有落在可接受的範圍之內。這樣的過程重複跑個幾百次，就有很高的機率可以找出最佳的 translation model。</p><p>另外，有時候找出的 matched pair 其實並沒有很多，這時候比起使用隨機選點的方式，直接窮盡所有組合相對快上許多。</p><h1 id="Stitch-image-with-Blending"><a href="#Stitch-image-with-Blending" class="headerlink" title="Stitch image with Blending"></a>Stitch image with Blending</h1><p>有了兩張圖的相對位置之後就可以來連接兩張影像，但是直接連起來會有很明顯的縫，所以需要做blending。<br>我實作了兩種blend method:</p><ol><li>Linear blend</li><li>Linear blend with constant width</li></ol><p>Linear blend 是最簡單的方式，重疊的部分的顏色由兩張影像加權平均得出，加權的比重如下圖所示，x軸位置接近哪張影像則權重就比較高。</p><div><img src="/img/2017-05-26/07.jpg" alt="x軸位置接近哪張影像則權重就比較高" data-action="zoom"><span class="image-caption">x軸位置接近哪張影像則權重就比較高</span></div><p>不過這樣會有一個問題，如果重疊的區域有棵樹在動，那這樣blend就會出現鬼影的問題。<br>所以我就改成第二種方法，Linear blend with constant width，先找出兩張影像重疊部分的中心線，以此左右取個固定寬度再做 linear blend，這樣就能避免鬼影的問題。</p><div><img src="/img/2017-05-26/08.jpg" alt="只在兩張影像重疊部分的中心線左右一點點區間做 linear blend" data-action="zoom"><span class="image-caption">只在兩張影像重疊部分的中心線左右一點點區間做 linear blend</span></div><p>以下是分別用兩種方法所接合的圖，可以看到用第一種方法的左邊的樹明顯糊糊的，右邊的則幾乎沒有鬼影。</p><div><img src="/img/2017-05-26/09.jpg" alt="左:第一種方法，可看到樹葉糊糊的；右:第二種方法，沒有鬼影現象。" data-action="zoom"><span class="image-caption">左:第一種方法，可看到樹葉糊糊的；右:第二種方法，沒有鬼影現象。</span></div><h1 id="End-to-end-alignment-and-Crop"><a href="#End-to-end-alignment-and-Crop" class="headerlink" title="End to end alignment and Crop"></a>End to end alignment and Crop</h1><p>完成所有影像接合之後，會有一些上下的誤差，這時候可以直接將誤差平均分配給每張影像，就可以得出一張比較平的圖片。</p><p>原始的接起來的影像，可以看到這一張有嚴重的上下飄移。</p><div><img src="/img/2017-05-26/15.jpg" alt="接完以後的原始影像" data-action="zoom"><span class="image-caption">接完以後的原始影像</span></div><p>把誤差平均分配給大家，可以變成比較平的影像。<br><div><img src="/img/2017-05-26/15-aligned.jpg" alt="經過 end to end alignment 修正之後的圖" data-action="zoom"><span class="image-caption">經過 end to end alignment 修正之後的圖</span></div></p><p>最後再把上下的黑邊切除掉，就可以得出一張完整的影像。<br><div><img src="/img/2017-05-26/15-cropped.jpg" alt="裁減掉黑邊的圖。" data-action="zoom"><span class="image-caption">裁減掉黑邊的圖。</span></div></p><h1 id="Results"><a href="#Results" class="headerlink" title="Results"></a>Results</h1><p>這邊展示幾個結果，一張綜覽全貌、一張是原始尺寸（可拖曳）</p><div><img src="/img/2017-05-26/15-cropped.jpg" alt="大雪山登山口。" data-action="zoom"><span class="image-caption">大雪山登山口。</span></div><div class="pano" style="position:relative;"><div style="background-image:url('/img/2017-05-26/15-cropped.jpg'); width:5103px; height:921px;"></div></div><hr><div><img src="/img/2017-05-26/13-cropped.jpg" alt="台大總圖後面。" data-action="zoom"><span class="image-caption">台大總圖後面。</span></div><div class="pano" style="position:relative;"><div style="background-image:url('/img/2017-05-26/13-cropped.jpg'); width:4634px; height:744px;"></div></div><hr><div><img src="/img/2017-05-26/17-cropped.jpg" alt="Testing image from internet" data-action="zoom"><span class="image-caption">Testing image from internet</span></div><div class="pano" style="position:relative;"><div style="background-image:url('/img/2017-05-26/17-cropped.jpg'); width:4556px; height:497px;"></div></div><hr><div><img src="/img/2017-05-26/cropped.jpg" alt="Testing image from internet" data-action="zoom"><span class="image-caption">Testing image from internet</span></div><div class="pano" style="position:relative;"><div style="background-image:url('/img/2017-05-26/cropped.jpg'); width:4120px; height:492px;"></div></div><p><link href="https://cdnjs.cloudflare.com/ajax/libs/jquery.perfect-scrollbar/0.7.0/css/perfect-scrollbar.min.css" rel="stylesheet"></p><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery.perfect-scrollbar/0.7.0/js/perfect-scrollbar.min.js"></script><script>window.onload = function() {    var panoramas = document.getElementsByClassName('pano');    Array.prototype.map.call(panoramas, function(pano) {        Ps.initialize(pano);    });};</script><hr><p>Reference:<br>[1] Image from Digital Visual Effects(NTU) slides</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;全景照(panorama) 現在已普遍存在手機的相機軟體中，是一種可以拍攝數張照片然後接在一起使整個視野變更大的方法，全景照常比較常見的是往同一方向拍攝的，但也是有上下左右都全景的那種(Photo Sphere)。&lt;br&gt;以一般往同方向拍攝的一系列照片來說，要合出一張完整的全景照理論上就是將這一系列的照片重疊的部分對齊就可以了。&lt;br&gt;但實際上還是需要經過一系列的方法，才能接合出比較良好的全景照。&lt;/p&gt;
    
    </summary>
    
    
      <category term="opencv" scheme="https://ssarcandy.tw/tags/opencv/"/>
    
      <category term="python" scheme="https://ssarcandy.tw/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Migrate mail server to Gmail - migration strategy</title>
    <link href="https://ssarcandy.tw/2017/04/29/migrate-to-gmail-migration-strategy/"/>
    <id>https://ssarcandy.tw/2017/04/29/migrate-to-gmail-migration-strategy/</id>
    <published>2017-04-29T14:56:05.000Z</published>
    <updated>2020-01-29T16:42:43.264Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇講了如何使用 google 提供的 migration tool 來遷移郵件，但需要知道大家的密碼才能用 IMAP 存取郵件資料。<br>一般來說即使是 root 也是看不到密碼的，就算能也只是看到加密過後的密碼。<br>而本篇要紀錄的就是我們遷移策略，包含我們怎麼繞過(?)密碼這關。</p><a id="more"></a><h1 id="概況"><a href="#概況" class="headerlink" title="概況"></a>概況</h1><p>我們的伺服器是透過 LDAP 集中管理身分認證資訊，大致架構如下:</p><div><img src="/img/2017-04-29/01.JPG" alt="伺服器架構: 由 LDAP 來統一管理身分資訊。" data-action="zoom"><span class="image-caption">伺服器架構: 由 LDAP 來統一管理身分資訊。</span></div><p>除了一般工作站以外，郵件伺服器也同樣是利用 LDAP 的資訊來登入，簡單來說就是使用者只須要記得一個密碼，就可以登入各工作站以及郵件伺服器。</p><h1 id="繞過密碼"><a href="#繞過密碼" class="headerlink" title="繞過密碼"></a>繞過密碼</h1><p>想來想去最後想到兩種方法，一是從 LDAP 下手，一是從郵件伺服器下手。</p><h2 id="從-LDAP-下手"><a href="#從-LDAP-下手" class="headerlink" title="從 LDAP 下手"></a>從 LDAP 下手</h2><p>雖然 root 看不到大家的密碼，但是能直接更改別人的密碼 XD<br>所以呢，我們可以複製出一個假的 LDAP server，就專給郵件伺服器用。</p><div><img src="/img/2017-04-29/02.JPG" alt="複製一個 LDAP，專門給郵件伺服器使用。" data-action="zoom"><span class="image-caption">複製一個 LDAP，專門給郵件伺服器使用。</span></div><p>要複製一個 LDAP 並不困難，只需要安裝好 LDAP 之後把資料 dump 過來就完成了。<br>創造好一個 fake LDAP 之後就要來改改郵件伺服器的設定，讓他改用 fake LDAP 的資訊來做身分認證。</p><p>首先要先更改 <code>/etc/hosts</code> ，把 LDAP 對應的 ip address 改對(如果有的話)，<br>如果沒有用 <code>/etc/hosts</code> 的話，則記得要更改 roundcube 設定:</p><p><strong>更改 roundcube ldap</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vim /etc/roundcube/main.inc.php</span><br></pre></td></tr></table></figure><p>把 <code>hosts</code> 改成 fake LDAP:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$config[<span class="string">'ldap_public'</span>][<span class="string">'public'</span>] = <span class="keyword">array</span>(</span><br><span class="line">    <span class="string">'name'</span>              =&gt; <span class="string">'Public LDAP Addressbook'</span>,</span><br><span class="line">    <span class="string">'hosts'</span>             =&gt; <span class="keyword">array</span>(<span class="string">'fake LDAP'</span>),</span><br><span class="line">    <span class="string">'port'</span>              =&gt; <span class="number">389</span>,</span><br><span class="line">    <span class="string">'user_specific'</span>     =&gt; <span class="keyword">false</span>,</span><br><span class="line">    <span class="string">'base_dn'</span>           =&gt; <span class="string">'ou=public,ou=rcabook,dc=localhost'</span>,</span><br><span class="line">    <span class="string">'bind_dn'</span>           =&gt; <span class="string">'cn=rcuser,ou=rcabook,dc=localhost'</span>,</span><br><span class="line">    <span class="string">'bind_pass'</span>         =&gt; <span class="string">'rcpass'</span>,</span><br><span class="line">    <span class="string">'filter'</span>            =&gt; <span class="string">'(objectClass=inetOrgPerson)'</span>,</span><br><span class="line">    <span class="string">'groups'</span>            =&gt; <span class="keyword">array</span>(</span><br><span class="line">        <span class="string">'base_dn'</span>         =&gt; <span class="string">''</span>,</span><br><span class="line">        <span class="string">'filter'</span>          =&gt; <span class="string">'(objectClass=groupOfNames)'</span>,</span><br><span class="line">        <span class="string">'object_classes'</span>  =&gt; <span class="keyword">array</span>(<span class="string">"top"</span>, <span class="string">"groupOfNames"</span>),</span><br><span class="line">    ),</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>詳細可以看 roundcube 說明文件。</p><p>弄好之後記得要刷新 <code>nslcd</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ /etc/init.d/nslcd force-reload <span class="comment"># maybe need to reload</span></span><br></pre></td></tr></table></figure><p>接下來就是要更改大家密碼啦~<br>由於郵件伺服器現在是使用 fake LDAP 驗證資訊了，所以這時候更改密碼只會改到 fake LDAP 上的資訊，而不影響大家登入使用其他工作站。也就是說使用這種方法的壞處只有在遷移的過程中不能登入原郵件伺服器。<br>不過由於收發信件都已經轉移去 gmail 了，暫時不能登入原郵件伺服器其實影響應該不會太大了。</p><p><strong>更改 ldap user password</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ldappasswd -h &lt;ldap_ip&gt; -x -ZZ \</span><br><span class="line">        -D <span class="string">"cn=admin,dc=your_base_dn"</span> \</span><br><span class="line">        <span class="string">"user_distinguished_name"</span> \</span><br><span class="line">        <span class="_">-s</span> &lt;new_password&gt; \</span><br><span class="line">        -w &lt;ldap_admin_password&gt;</span><br></pre></td></tr></table></figure><p>以上是更改一個人 LDAP 密碼的方式，那要批次更改全部人的密碼可以這樣:</p><p>先去 <code>/var/spool/mail/</code> 找誰有郵件帳戶，然後組合成 ldap dn ，輸出到一個檔案:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ls /var/spool/mail/ <span class="_">-l</span> \</span><br><span class="line">        | grep rw \</span><br><span class="line">        | awk &#123;<span class="string">'print $3'</span>&#125; \</span><br><span class="line">        | xargs -I &#123;&#125; <span class="built_in">echo</span> <span class="string">"uid=&#123;&#125;,ou=people,dc=cmlab,dc=csie,dc=ntu,dc=edu,dc=tw"</span> &gt; ~/mail_all.txt</span><br></pre></td></tr></table></figure><p>再組合出改密碼的指令並輸出到 <code>change_password.sh</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cat mail_all.txt \</span><br><span class="line">    | xargs -I &#123;&#125; <span class="built_in">echo</span> <span class="string">"ldappasswd -x -ZZ -D cn=admin,dc=your_base_dn &#123;&#125; -s &lt;new_password&gt; -w &lt;ldap_password&gt;"</span> &gt; change_passwd.sh</span><br></pre></td></tr></table></figure><p>然後就可以:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./change_password.sh</span><br></pre></td></tr></table></figure><h2 id="從-Mail-Account-下手"><a href="#從-Mail-Account-下手" class="headerlink" title="從 Mail Account 下手"></a>從 Mail Account 下手</h2><p>從 LDAP 下手的基本上就可以解決密碼的問題，不過就是會在遷移的期間讓大家無法登入看舊信件(因為大家密碼被改掉了)，雖說影響應該不大，不過依舊是有影響的。</p><p>另一個繞過密碼的方式是從郵件帳戶下手，先創建一個假帳號，再把信件都複製到假帳號那邊，就可以用假帳號存取那個人的信件。</p><p>假設有個帳號 <code>ssarcandy</code>，實際方法如下:</p><ol><li>Add a fake user into ldap, i.e. <code>ssarcandy_fake</code></li><li>Create home dir for it, change the owner to <code>ssarcandy_fake</code></li><li>Copy <code>/var/spool/mail/ssarcandy</code> to <code>/var/spool/mail/ssarcandy_fake</code>, and chage owner</li><li>Copy <code>~ssarcandy/mail/</code> to <code>~ssarcandy_fake/mail/</code> if it exist, and chage owner</li></ol><p>寫成 script 大致如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># $1=new fake user   -&gt; i.e. ssarcandy_fake</span></span><br><span class="line"><span class="comment"># $2=correspond user -&gt; i.e. ssarcandy</span></span><br><span class="line"> </span><br><span class="line">PASSWORD=<span class="string">'some_password'</span></span><br><span class="line">HOME_DIR_BASE=<span class="string">'/data/mail_migrate_tmp'</span></span><br><span class="line">LDAP_BASE=<span class="string">'base dn'</span></span><br><span class="line">LDAP_DN=<span class="string">'ldap admin dn'</span></span><br><span class="line">LDAP_PASS=<span class="string">'ldap admin password'</span></span><br><span class="line">LDAP_HOST=<span class="string">'ip address'</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">echo</span> <span class="string">"dn: uid=<span class="variable">$1</span>,ou=people,<span class="variable">$LDAP_BASE</span></span></span><br><span class="line"><span class="string">uid: <span class="variable">$1</span></span></span><br><span class="line"><span class="string">sn: lastname</span></span><br><span class="line"><span class="string">cn: complete name</span></span><br><span class="line"><span class="string">mail: <span class="variable">$1</span>@cmlab.csie.ntu.edu.tw</span></span><br><span class="line"><span class="string">objectClass: person</span></span><br><span class="line"><span class="string">objectClass: organizationalPerson</span></span><br><span class="line"><span class="string">objectClass: inetOrgPerson</span></span><br><span class="line"><span class="string">objectClass: posixAccount</span></span><br><span class="line"><span class="string">objectClass: top</span></span><br><span class="line"><span class="string">objectClass: shadowAccount</span></span><br><span class="line"><span class="string">userPassword: &#123;crypt&#125;12345</span></span><br><span class="line"><span class="string">shadowMax: 99999</span></span><br><span class="line"><span class="string">shadowWarning: 7</span></span><br><span class="line"><span class="string">loginShell: /bin/bash</span></span><br><span class="line"><span class="string">uidNumber: 6577</span></span><br><span class="line"><span class="string">gidNumber: 1000</span></span><br><span class="line"><span class="string">homeDirectory: <span class="variable">$HOME_DIR_BASE</span>/<span class="variable">$1</span>"</span>&gt; tmp.ldif</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Create fake account</span></span><br><span class="line">ldapadd -h <span class="variable">$LDAP_HOST</span> -ZZ -x -w <span class="variable">$LDAP_PASS</span> -D <span class="variable">$LDAP_DN</span> <span class="_">-f</span> tmp.ldif</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Change fake account password</span></span><br><span class="line">ldappasswd -h <span class="variable">$LDAP_HOST</span> -ZZ -x \</span><br><span class="line">    -w <span class="variable">$LDAP_PASS</span> -D <span class="variable">$LDAP_DN</span> \</span><br><span class="line">    <span class="string">"uid=<span class="variable">$1</span>,ou=people,<span class="variable">$LDAP_BASE</span>"</span> <span class="_">-s</span> <span class="variable">$PASSWORD</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># Create home dir for fake account</span></span><br><span class="line">mkdir -p <span class="variable">$HOME_DIR_BASE</span></span><br><span class="line">mkdir <span class="variable">$HOME_DIR_BASE</span>/<span class="variable">$1</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># Copy mails to fake account.</span></span><br><span class="line">cp /var/spool/mail/<span class="variable">$2</span> /var/spool/mail/<span class="variable">$1</span></span><br><span class="line">cp -r $(<span class="built_in">eval</span> <span class="built_in">echo</span> ~<span class="variable">$2</span>)/mail $(<span class="built_in">eval</span> <span class="built_in">echo</span> ~<span class="variable">$1</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Change owner of copied mails</span></span><br><span class="line">chown 6577:1000 /var/spool/mail/<span class="variable">$1</span></span><br><span class="line">chown -R 6577:1000 <span class="variable">$HOME_DIR_BASE</span>/<span class="variable">$1</span></span><br></pre></td></tr></table></figure><p>這就是另一個繞過密碼的方式，這方式的優點是可以不影響使用者的帳戶，也就是在遷移過程中依舊可以登入舊郵件伺服器。<br>但也是有缺點的，就是必須複製一份使用者的 mails，在遷移期間會浪費兩倍的容量。</p><h1 id="遷移策略"><a href="#遷移策略" class="headerlink" title="遷移策略"></a>遷移策略</h1><p>我們要遷移的郵件說多不多，但也不太少，以容量來說大概 600 GB 左右。<br>不過空間上稍微尷尬一點，只剩 50 GB 可以使用。<br>所以基本上是沒辦法讓大家都使用第二種方法(創假帳號並複製郵件)，先使用 fake LDAP 轉移大部分人會是比較適當的方式。</p><p>以時間軸的方式來呈現整個遷移的過程，大致如下:</p><ul class="timeline"><li><div class="direction-r"><div class="flag-wrapper"><span class="flag">設定 MX record</span></div><div class="desc">信件收發轉至 Gmail</div></div></li><li><div class="direction-l"><div class="flag-wrapper"><span class="flag">建立 fake LDAP 讓 mail server 使用</span></div><div class="desc">開始遷移大部分使用者，遷移期間使用者無法登入原郵件伺服器(因密碼不同)。</div></div></li><li><div class="direction-r"><div class="flag-wrapper"><span class="flag">讓 mail server 使用原 LDAP</span></div><div class="desc">使用者可以正常登入原郵件伺服器。</div></div></li><li><div class="direction-l"><div class="flag-wrapper"><span class="flag">針對重要使用者建立假帳號</span></div><div class="desc">開始轉移那些信件特多的使用者，使用建立假帳號的方式。</div></div></li><li><div class="direction-r"><div class="flag-wrapper"><span class="flag">善後</span></div><div class="desc">完成轉移，刪除假帳號。</div></div></li></ul><p>開始遷移信件的時間點是在已將 MX record 設定完，收發功能已轉至 gmail 之後才開始的。<br>我們基本上分兩階段轉移信件，<br>第一階段是用 fake LDAP 的方式轉移大部分的使用者；<br>第二階段則是用假帳號的方式轉移最重要(信件特多)的使用者。</p><p>首先我們先對使用者的信件用量做分群，找出哪些人用量相似、哪些人用量特多等等。<br>可以利用 dovecot 的 admin 工具查詢:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查詢 ssarcandy 的總信件數目</span></span><br><span class="line">$ doveadm search -u ssarcandy ALL | wc <span class="_">-l</span></span><br><span class="line">14990</span><br></pre></td></tr></table></figure><p>把大家的郵件數目分佈畫成圖表:</p><div><img src="/img/2017-04-29/04.JPG" alt="帳戶郵件分佈圖" data-action="zoom"><span class="image-caption">帳戶郵件分佈圖</span></div><p>可以看到基本上大部分人都沒甚麼信，只有少數人有超大量的信，而這些少數人會是遷移的 bottleneck，所以應該要挑出來用假帳號的方式轉移信件，才能避免讓原郵件伺服器不能登入的時間拉太長。</p><p>另外，由於 G Suite 遷移工具是一批一批遷移的，所以同一批最好大家的郵件數目都要差不多，才可以減少總體等待時間。</p><hr><p>我們用以上的遷移策略，總共耗時約十天完成大家的所有信件遷移。<br>當初預估一周真是太天真了阿QQ</p><style>.timeline,.timeline li{padding:1em 0}.timeline{position:relative;width:660px;margin:20px auto 0;list-style-type:none}.timeline:before{position:absolute;left:50%;top:0;content:' ';display:block;width:6px;height:100%;margin-left:-3px;background:#505050;background:-moz-linear-gradient(top,rgba(80,80,80,0) 0,#505050 8%,#505050 92%,rgba(80,80,80,0) 100%);background:-webkit-gradient(linear,left top,left bottom,color-stop(0,rgba(30,87,153,1)),color-stop(100%,rgba(125,185,232,1)));background:-webkit-linear-gradient(top,rgba(80,80,80,0) 0,#505050 8%,#505050 92%,rgba(80,80,80,0) 100%);background:-o-linear-gradient(top,rgba(80,80,80,0) 0,#505050 8%,#505050 92%,rgba(80,80,80,0) 100%);background:-ms-linear-gradient(top,rgba(80,80,80,0) 0,#505050 8%,#505050 92%,rgba(80,80,80,0) 100%);background:linear-gradient(to bottom,rgba(80,80,80,0) 0,#505050 8%,#505050 92%,rgba(80,80,80,0) 100%);z-index:5}.direction-l,.direction-r{width:300px;position:relative}.timeline li:after{content:"";display:block;height:0;clear:both;visibility:hidden}.direction-l{float:left;text-align:right}.direction-r{float:right}.flag-wrapper{position:relative;display:inline-block;text-align:center}.flag{position:relative;display:inline;background:#eee;padding:6px 10px;border-radius:5px;font-weight:600;text-align:left}.direction-l .flag{-webkit-box-shadow:-1px 1px 1px rgba(0,0,0,.15),0 0 1px rgba(0,0,0,.15);-moz-box-shadow:-1px 1px 1px rgba(0,0,0,.15),0 0 1px rgba(0,0,0,.15);box-shadow:-1px 1px 1px rgba(0,0,0,.15),0 0 1px rgba(0,0,0,.15)}.direction-r .flag{-webkit-box-shadow:1px 1px 1px rgba(0,0,0,.15),0 0 1px rgba(0,0,0,.15);-moz-box-shadow:1px 1px 1px rgba(0,0,0,.15),0 0 1px rgba(0,0,0,.15);box-shadow:1px 1px 1px rgba(0,0,0,.15),0 0 1px rgba(0,0,0,.15)}.direction-l .flag:before,.direction-r .flag:before{position:absolute;top:50%;right:-36px;content:' ';display:block;width:12px;height:12px;margin-top:-10px;background:#eee;border-radius:10px;border:4px solid #ff5050;z-index:10}.direction-l .flag:after,.direction-r .flag:after{content:"";position:absolute;top:50%;height:0;width:0;margin-top:-8px;pointer-events:none}.direction-r .flag:before{left:-36px}.direction-l .flag:after{left:100%;border:solid transparent;border-left-color:#eee;border-width:8px}.direction-r .flag:after{right:100%;border:solid transparent;border-right-color:#eee;border-width:8px}.time-wrapper{display:inline;line-height:1em;font-size:.66666em;color:#fa5050;vertical-align:middle}.direction-l .time-wrapper{float:left}.direction-r .time-wrapper{float:right}.time{display:inline-block;padding:4px 6px;background:#eee}.desc{margin:1em .75em 0 0;line-height:1.5em}.direction-r .desc{margin:1em 0 0 .75em}@media screen and (max-width:660px){.timeline{width:100%;padding:4em 0 1em}.timeline li{padding:2em 0}.direction-l,.direction-r{float:none;width:100%;text-align:center}.flag-wrapper{text-align:center}.flag{background:#eee;z-index:15}.direction-l .flag:before,.direction-r .flag:before{position:absolute;top:-30px;left:calc(50% + 3px);content:' ';display:block;width:12px;height:12px;margin-left:-9px;background:#eee;border-radius:10px;border:4px solid #ff5050;z-index:10}.direction-l .flag:after,.direction-r .flag:after{content:"";position:absolute;left:50%;top:-8px;height:0;width:0;margin-left:-8px;border:solid transparent;border-bottom-color:#eee;border-width:8px;pointer-events:none}.time-wrapper{display:block;position:relative;margin:4px 0 0;z-index:14}.direction-l .time-wrapper,.direction-r .time-wrapper{float:none}.desc{position:relative;margin:1em 0 0;padding:1em;background:#f5f5f5;-webkit-box-shadow:0 0 1px rgba(0,0,0,.2);-moz-box-shadow:0 0 1px rgba(0,0,0,.2);box-shadow:0 0 1px rgba(0,0,0,.2);z-index:15}.direction-l .desc,.direction-r .desc{position:relative;margin:1em 1em 0;padding:1em;z-index:15}}@media screen and (min-width:400px ?? max-width:660px){.direction-l .desc,.direction-r .desc{margin:1em 4em 0}}</style>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一篇講了如何使用 google 提供的 migration tool 來遷移郵件，但需要知道大家的密碼才能用 IMAP 存取郵件資料。&lt;br&gt;一般來說即使是 root 也是看不到密碼的，就算能也只是看到加密過後的密碼。&lt;br&gt;而本篇要紀錄的就是我們遷移策略，包含我們怎麼繞過(?)密碼這關。&lt;/p&gt;
    
    </summary>
    
    
      <category term="unix" scheme="https://ssarcandy.tw/tags/unix/"/>
    
      <category term="note" scheme="https://ssarcandy.tw/tags/note/"/>
    
  </entry>
  
  <entry>
    <title>Migrate mail server to Gmail - using migration tool</title>
    <link href="https://ssarcandy.tw/2017/04/23/migrate-to-gmail-using-migration-tool/"/>
    <id>https://ssarcandy.tw/2017/04/23/migrate-to-gmail-using-migration-tool/</id>
    <published>2017-04-23T11:36:51.000Z</published>
    <updated>2020-01-29T16:42:43.264Z</updated>
    
    <content type="html"><![CDATA[<p>最近 CMLab 終於申請到 G Suite for Education 了～<br>也就是我們不用再維護自己的 mail server 了～灑花～</p><p>但這也就又多了一件事：Migration…<br>我們要做的事情有以下幾件：</p><ol><li>讓 MX record 指到新的位置</li><li>遷移群組</li><li>遷移舊信</li></ol><p>其中 2, 3 並非必須做的，但為了讓大家可以無痛轉移，我們才決定要搬信以及同步群組。<br>1, 2 十分容易，就照著說明就可以完成，真的不會的話還可以打給 Google 救援 XD<br>而本篇要紀錄的是 <strong>遷移舊信</strong> 的部分，這是其中最麻煩也最繁瑣的部分…</p><a id="more"></a><h1 id="設定資料遷移工具"><a href="#設定資料遷移工具" class="headerlink" title="設定資料遷移工具"></a>設定資料遷移工具</h1><p>G Suite 中有提供資料遷移的工具，其中包含遷移舊信件，<br>他的方法是透過 IMAP 下載 dovecot 信件再匯入至 Gmail.</p><p>遷移設定中，要設定以下幾個東西：</p><ul><li>原郵件伺服器類型 → 我們的例子要選 <strong>其他電子郵件伺服器</strong></li><li>原本的 IMAP server</li><li>管理者帳號 → 這好像沒甚麼重要的，只是他會收到遷移報告書</li></ul><h1 id="Password-mismatch"><a href="#Password-mismatch" class="headerlink" title="Password mismatch"></a>Password mismatch</h1><p>這邊可能會遇到問題(帳號密碼不正確/password mismatch?)，可以查看 <code>/var/log/mail.log</code> 中的詳細錯誤訊息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Mar 16 19:00:54 cml2 dovecot: auth-worker(10594): pam(ssarcandy@cmlab.csie.ntu.edu.tw,173.194.90.100):</span><br><span class="line">pam_authenticate() failed: Authentication failure (password mismatch?)</span><br></pre></td></tr></table></figure><p>這是因為這邊使用 full email address 去登入 IMAP server，而原本我們 dovecot 的設定是只要打 user name 就好(不用加 @domain)，才會造成帳密不正確的問題。</p><p>為了迎合 G suite 的格式，去原郵件伺服器更改 dovecot 設定：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ vim /etc/dovecot/conf.d/10-auth.conf</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 找到 auth_username_format</span></span><br><span class="line"><span class="comment"># 反註解並改成 auth_username_format = %n</span></span><br></pre></td></tr></table></figure><p>其中 <code>auth_username_format</code> 是指登入的 username 格式，預設是只有 @ 前面的部分。<br>由於 G suite 那邊就是要用 full address 登入，故這邊改成 <code>%n</code> ，亦即捨棄 @ 後面的東西，只留下 @ 前面的部分 。</p><p>改完之後記得重啟 dovecot</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ service dovecot restart</span><br><span class="line">[ ok ] Restarting IMAP/POP3 mail server: dovecot.</span><br></pre></td></tr></table></figure><h1 id="設定遷移範圍"><a href="#設定遷移範圍" class="headerlink" title="設定遷移範圍"></a>設定遷移範圍</h1><p>下一步是要設定要遷移的時間、資料夾等，<br>以我們的例子而言：</p><ul><li>時間選到 cmlab 創立以來的全部 ～(遷移！全都遷移！</li><li>資料夾則選擇忽略幾個特定資料夾，像是 <code>virus-mail</code> , <code>trash-mail</code>, <code>spam-mail</code> 等等</li></ul><div><img src="/img/2017-04-23/01.jpg" alt="完整的資料遷移設定" data-action="zoom"><span class="image-caption">完整的資料遷移設定</span></div><h1 id="選取遷移的使用者"><a href="#選取遷移的使用者" class="headerlink" title="選取遷移的使用者"></a>選取遷移的使用者</h1><p>接下來可以直接上傳一個 csv 檔，其中包含：</p><ul><li>原郵件伺服器帳號</li><li>原郵件伺服器密碼</li><li>對應的 gmail 帳號</li></ul><p>上傳時有個潛規則，csv 檔不可以超過 500 行，超過它就會說未知錯誤(對，這是我們試出來的…</p><p>另外，在遷移時有幾個常見的錯誤：</p><h2 id="驗證失敗"><a href="#驗證失敗" class="headerlink" title="驗證失敗"></a>驗證失敗</h2><p>錯誤(18017)：驗證失敗。<br>這表示所提供的原郵件伺服器帳號、密碼不正確，<br>也就是可能這個人不存在原郵件伺服器，或者提供的密碼不正確。</p><p>如果原郵件伺服器的驗證是像我們一樣透過 LDAP 的話，可以用 <code>ldapsearch</code> 確認這人在不在：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ldapsearch -x <span class="string">"uid=??,dc=base_dn"</span></span><br></pre></td></tr></table></figure><h2 id="連線至來源郵件伺服器時發生錯誤"><a href="#連線至來源郵件伺服器時發生錯誤" class="headerlink" title="連線至來源郵件伺服器時發生錯誤"></a>連線至來源郵件伺服器時發生錯誤</h2><p>錯誤(18002)：連線至來源郵件伺服器時發生錯誤。<br>這錯誤是對應到 roundcube 的 <strong>連線到 imap 伺服器失敗</strong> 錯誤，有兩個可能：</p><ol><li>因為那個人沒有家目錄</li><li>uid mismatch → <code>/var/spool/mail/username</code> 的擁有者是錯誤的</li></ol><p>會發生沒有家目錄的情況在我們的狀況而言就是那個人已被停權，那就根本不用遷移了。<br>而 uid mismatch 則是去 <code>/var/spool/mail/username</code> 更改成正確的擁有者就好了。</p><h2 id="信箱錯誤。無法開啟資料夾或郵件"><a href="#信箱錯誤。無法開啟資料夾或郵件" class="headerlink" title="信箱錯誤。無法開啟資料夾或郵件"></a>信箱錯誤。無法開啟資料夾或郵件</h2><p>錯誤(18006)：信箱錯誤。無法開啟資料夾或郵件。<br>這應該是屬於暫時性的錯誤，晚一點再重試看看。</p><p>Google 其實有提供一份錯誤一覽表 → <a href="https://support.google.com/a/answer/6254288?hl=zh-Hant&amp;ref_topic=6245212" target="_blank" rel="noopener">錯誤一覽表</a> (雖然有些有寫跟沒寫一樣…</p><h1 id="怎麼得到大家的密碼"><a href="#怎麼得到大家的密碼" class="headerlink" title="怎麼得到大家的密碼"></a>怎麼得到大家的密碼</h1><p>我想看到這邊應該會發現一個問題：<br>遷移的 csv 檔其中一欄要提供大家的密碼，這是即使是有 root 權限也沒辦法知道的資訊欸！<br>雖然我們最後還是有想到辦法，不過那過程也很繁瑣，就留到下一次介紹吧…</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近 CMLab 終於申請到 G Suite for Education 了～&lt;br&gt;也就是我們不用再維護自己的 mail server 了～灑花～&lt;/p&gt;
&lt;p&gt;但這也就又多了一件事：Migration…&lt;br&gt;我們要做的事情有以下幾件：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;讓 MX record 指到新的位置&lt;/li&gt;
&lt;li&gt;遷移群組&lt;/li&gt;
&lt;li&gt;遷移舊信&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;其中 2, 3 並非必須做的，但為了讓大家可以無痛轉移，我們才決定要搬信以及同步群組。&lt;br&gt;1, 2 十分容易，就照著說明就可以完成，真的不會的話還可以打給 Google 救援 XD&lt;br&gt;而本篇要紀錄的是 &lt;strong&gt;遷移舊信&lt;/strong&gt; 的部分，這是其中最麻煩也最繁瑣的部分…&lt;/p&gt;
    
    </summary>
    
    
      <category term="unix" scheme="https://ssarcandy.tw/tags/unix/"/>
    
      <category term="note" scheme="https://ssarcandy.tw/tags/note/"/>
    
  </entry>
  
  <entry>
    <title>High Dynamic Range Imaging</title>
    <link href="https://ssarcandy.tw/2017/04/16/High-Dynamic-Range-Imaging/"/>
    <id>https://ssarcandy.tw/2017/04/16/High-Dynamic-Range-Imaging/</id>
    <published>2017-04-15T17:34:44.000Z</published>
    <updated>2020-01-29T16:42:43.260Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>高動態範圍成像（英語：High Dynamic Range Imaging，簡稱HDRI或HDR），在電腦圖形學與電影攝影術中，是用來實現比普通數點陣圖像技術更大曝光動態範圍（即更大的明暗差別）的一組技術。高動態範圍成像的目的就是要正確地表示真實世界中從太陽光直射到最暗的陰影這樣大的範圍亮度。<br>   – from wikipedia</p></blockquote><p>由於一般數位相機的影像就是每個 pixel 8 bits，能夠表現的能量範圍就是這麼窄(過暴就全白，太暗就全黑)。<br>然而真實世界的能量範圍是非常廣的，為了能夠在 0~255 之間表現出最豐富的細節(亮部即暗部的細節)，才有所謂的 HDR 技術。<br>HDR Image 可以從多張不同曝光時間的照片中組合出來，而整個流程大致包含了:</p><ol><li>影像對齊</li><li>計算出真實能量分佈</li><li>把影像壓縮回低動態範圍成像(一般螢幕才能顯示)</li></ol><a id="more"></a><h1 id="Image-Alignment"><a href="#Image-Alignment" class="headerlink" title="Image Alignment"></a>Image Alignment</h1><p>拍攝時，即使有用腳架固定，也無法確保每張照片拍到的都完全沒有晃到，如果晃到的話，到時候的結果就會糊糊的。<br>所以，第一步就是要先對其各張影像。<br>我們可以以第一張照片為標準，其餘的照片都想辦法對齊他。</p><h2 id="Naive-Alignment"><a href="#Naive-Alignment" class="headerlink" title="Naïve Alignment"></a>Naïve Alignment</h2><p>最 naïve 的演算法，就是在一個範圍內移動找出差值最小的offset，pseudo-code如下:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">offset = (<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">difference = infinity</span><br><span class="line"><span class="keyword">for</span> y <span class="keyword">in</span> [min..max]:</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> [min..max]:</span><br><span class="line">        diff = find_diff(img[<span class="number">0</span>], offset(img[i], (y, x))</span><br><span class="line">        <span class="keyword">if</span> diff &lt; difference:</span><br><span class="line">            difference = diff</span><br><span class="line">            offset = (y, x)</span><br></pre></td></tr></table></figure><p>如何訂 min, max 值是個難題，太大會效率差，太小可能會沒找最好的解。<br>不過依據我的經驗，拍攝的時候有搭配腳架以及快門線的話，其實誤差差不多都在 5 pixels 之間，所以可以把 \((min, max) = (-2, 2)\)</p><h2 id="Median-Threshold-Bitmap"><a href="#Median-Threshold-Bitmap" class="headerlink" title="Median Threshold Bitmap"></a>Median Threshold Bitmap</h2><p>Median Threshold Bitmap Alignment<sup>[1]</sup> 演算法，是利用金字塔的方式(每層圖片都為上一層的四倍)從最小的開始比對，在九個鄰居內做移動，累計各方向的誤差選擇最小的方向移動之，再向上傳遞到兩倍的圖再做一次。基本上每一張都是去對齊第一張。</p><p>實作的流程大略如下:</p><ol><li><p>產生 binary-threshold image<br>這邊的閾值由影像的中位數值決定。</p> <div><img src="/img/2017-04-16/01.PNG" alt="我實作的 MTB 所產生的 binary-threshold image" data-action="zoom"><span class="image-caption">我實作的 MTB 所產生的 binary-threshold image</span></div></li><li><p>產生 exclude mask<br>由於那些太接近閾值的像素有可能會造成誤差，故將太接近閾值的像素標示出來，在比對時就直接跳過不比對。<br>假設要忽略的是 <strong>閾值 ± 10</strong> ，可以用 opencv 的 <code>cv2.inRange()</code>達成</p> <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mask_img = cv2.inRange(img, median - <span class="number">10</span>, median + <span class="number">10</span>)</span><br></pre></td></tr></table></figure> <div><img src="/img/2017-04-16/02.PNG" alt="這是用於跳過過於接近閾值的像素的 MASK" data-action="zoom"><span class="image-caption">這是用於跳過過於接近閾值的像素的 MASK</span></div></li><li><p>由最小至最大的順序比對影像差異<br>在每一個層級中，都是往九個鄰居移動，看哪個最小，再往上傳遞繼續做這個比對。<br>由於影像都是 binary image，所以要比對影像差異挺容易的:<br>影像差異 = <code>img1 XOR img2 AND mask</code><br>越小層級的移動的權重越大。</p></li></ol><h1 id="Construct-HDR"><a href="#Construct-HDR" class="headerlink" title="Construct HDR"></a>Construct HDR</h1><p>由於一般數位相機的影像就是每個 pixel 8 bits，所以每台數位相機其實都有自己對應的 response curve<br>Response curve 是在決定接收到多少能量該轉成多少的值(此值是 [0~255])。<br>那我就可以透過多張不同曝光時間的影像來反推出這個 response curve，有了 response curve 之後就可以進一步算出真實能量分佈圖。</p><h2 id="Solving-response-curve"><a href="#Solving-response-curve" class="headerlink" title="Solving response curve"></a>Solving response curve</h2><p>我建立 HDR 影像的方法為 1997 Debevec<sup>[2]</sup> 的方法。<br>由於論文很佛心的有提供 MatLab Code，所以我就直接拿他為基底改寫成 python 程式碼，<br>並利用 numpy 提供的 <code>np.linalg.lstsq(A, b)</code> 解 \(Ax = b\) 的 \(x\) 解。</p><p>我將 RGB channel 分別計算 response curve，並全部畫在一圖表上檢視，以下是我做的幾個例子。</p><div style="display: flex; align-items: center;"><br><div><img src="/img/2017-04-16/memorial0062.png" alt="" data-action="zoom"></div><br><div><img src="/img/2017-04-16/test-response-curve.png" alt="" data-action="zoom"></div><br></div><div style="display: flex; align-items: center;"><br><div><img src="/img/2017-04-16/DSC_0126.png" alt="" data-action="zoom"></div><br><div><img src="/img/2017-04-16/street2-response-curve.png" alt="" data-action="zoom"></div><br></div><p>另外，Debevec 論文<sup>[2]</sup>所提及的 \(L\) (控制 response curve smoothness 程度)，並不好掌握最好的值，不過依據實驗 \(L\) 值大約在 30~50 就還不錯。</p><hr><p>關於 smaple 點的方式，我試了兩種:</p><ol><li><p><strong>Random 取 50 個點</strong><br>好處是很直覺且容易實作，但我發現做出來的 response curve 有時會有很不一樣的結果，比較不可靠。以下圖為例，可以看到在綠色的 channel 就有比較怪異的結果，藍色在頂部也是怪怪的。</p> <div style="display: flex; align-items: center;"><br> <div><img src="/img/2017-04-16/04.PNG" alt="Random sampling 50 points" data-action="zoom"><span class="image-caption">Random sampling 50 points</span></div><br> <div><img src="/img/2017-04-16/05.PNG" alt="Response curve" data-action="zoom"><span class="image-caption">Response curve</span></div><br> </div></li><li><p><strong>把圖片縮成 10x10，全部拿去算</strong><br>由於縮小圖片基本上還是能保有圖片的特徵(特亮的、特暗之類的)，所以做出來的效果也比較好一點，左圖是縮放到 10x10 的影像，右為 response curve:</p> <div style="display: flex; align-items: center;"><br> <div><img src="/img/2017-04-16/03.PNG" alt="Shrink original img to 10x10 and use all pixels" data-action="zoom"><span class="image-caption">Shrink original img to 10x10 and use all pixels</span></div><br> <div><img src="/img/2017-04-16/test-response-curve2.png" alt="Response curve" data-action="zoom"><span class="image-caption">Response curve</span></div><br> </div></li></ol><p>所以最後我採用第二種方法。</p><h2 id="Construct-radiance-map"><a href="#Construct-radiance-map" class="headerlink" title="Construct radiance map"></a>Construct radiance map</h2><p>再藉由 Debevec 論文<sup>[2]</sup>上 Equation(6) 所提的 construct radiance map:<br>透過剛剛產生的 response curve 帶入公式來得到 radiance map。</p><p>$$<br>\ln E_{i}=\dfrac {\sum _{j=1}^{P} w\left( Zij\right) \left( g\left( Zij\right) -\ln \Delta t_{j}\right)} {\sum _{j=1}^{P} w\left( Zij\right)}<br>$$</p><p>其中 \(g\) 函式就是剛剛產生的 response curve。<br>有了 radiance map之後，就可以套用假色來顯示出真實能量分佈圖，以下是我做的幾的例子(這邊的值都是log value)</p><div style="display: flex; align-items: center;"><br><div><img src="/img/2017-04-16/test-radiance-map.png" alt="" data-action="zoom"></div><br><div><img src="/img/2017-04-16/taipei-radiance-map.png" alt="" data-action="zoom"></div><br></div><div style="display: flex; align-items: center;"><br><div><img src="/img/2017-04-16/street2-radiance-map.png" alt="" data-action="zoom"></div><br><div><img src="/img/2017-04-16/living_room2-radiance-map.png" alt="" data-action="zoom"></div><br></div><h1 id="Tone-mapping"><a href="#Tone-mapping" class="headerlink" title="Tone mapping"></a>Tone mapping</h1><p>到此已經重建出 Radiance map 了，也就是已經知道真實能量分佈了，但這能量範圍太廣，沒辦法直接顯示到一般的顯示器上(0~255)<br>所以需要再把這樣<strong>高動態範圍成像</strong>壓回<strong>低動態範圍成像</strong>，不過這壓縮的方式有其學問，如何才能讓低動態範圍成像<strong>看起來</strong>像高動態範圍成像就是 Tone mapping 在做的事。</p><p>根據不同的 Cases，最適合的演算法不見得相同，所以就是要看情況決定。<br>這邊展示幾個 Tone mapping 之後的結果:</p><div style="display: flex; align-items: center;"><br><div><img src="/img/2017-04-16/test-ashikhmin.jpg" alt="" data-action="zoom"></div><br><div><img src="/img/2017-04-16/taipei-drago.jpg" alt="" data-action="zoom"></div><br></div><div style="display: flex; align-items: center;"><br><div><img src="/img/2017-04-16/street2-ashikhmin.jpg" alt="" data-action="zoom"></div><br><div><img src="/img/2017-04-16/living_room2-gdc.jpg" alt="" data-action="zoom"></div><br></div><h1 id="Result-galleries"><a href="#Result-galleries" class="headerlink" title="Result galleries"></a>Result galleries</h1><div><img src="/img/2017-04-16/living_room2-gdc.jpg" alt="Living room, tone map algroithm: gdc, Camera: Nikon D5000" data-action="zoom"><span class="image-caption">Living room, tone map algroithm: gdc, Camera: Nikon D5000</span></div><div style="display: flex; align-items: center;"><br><div><img src="/img/2017-04-16/living_room2/DSC_0078.png" alt="" data-action="zoom"></div><br><div><img src="/img/2017-04-16/living_room2/DSC_0079.png" alt="" data-action="zoom"></div><br><div><img src="/img/2017-04-16/living_room2/DSC_0080.png" alt="" data-action="zoom"></div><br><div><img src="/img/2017-04-16/living_room2/DSC_0081.png" alt="" data-action="zoom"></div><br></div><div style="display: flex; align-items: center;"><br><div><img src="/img/2017-04-16/living_room2/DSC_0082.png" alt="" data-action="zoom"></div><br><div><img src="/img/2017-04-16/living_room2/DSC_0083.png" alt="" data-action="zoom"></div><br><div><img src="/img/2017-04-16/living_room2/DSC_0084.png" alt="" data-action="zoom"></div><br><div><img src="/img/2017-04-16/living_room2/DSC_0085.png" alt="" data-action="zoom"></div><br></div><div style="display: flex; align-items: center;"><br><div><img src="/img/2017-04-16/living_room2/DSC_0086.png" alt="" data-action="zoom"></div><br><div><img src="/img/2017-04-16/living_room2/DSC_0087.png" alt="" data-action="zoom"></div><br><div><img src="/img/2017-04-16/living_room2/DSC_0088.png" alt="" data-action="zoom"></div><br><div><img src="/img/2017-04-16/living_room2/DSC_0089.png" alt="" data-action="zoom"></div><br></div><hr><div><img src="/img/2017-04-16/taipei-drago.jpg" alt="Taipei city, tone map algroithm: drago, Camera: Nikon D5000" data-action="zoom"><span class="image-caption">Taipei city, tone map algroithm: drago, Camera: Nikon D5000</span></div><div style="display: flex; align-items: center;"><br><div><img src="/img/2017-04-16/taipei/DSC_0058.png" alt="" data-action="zoom"></div><br><div><img src="/img/2017-04-16/taipei/DSC_0060.png" alt="" data-action="zoom"></div><br><div><img src="/img/2017-04-16/taipei/DSC_0061.png" alt="" data-action="zoom"></div><br><div><img src="/img/2017-04-16/taipei/DSC_0062.png" alt="" data-action="zoom"></div><br></div><div style="display: flex; align-items: center;"><br><div><img src="/img/2017-04-16/taipei/DSC_0063.png" alt="" data-action="zoom"></div><br><div><img src="/img/2017-04-16/taipei/DSC_0064.png" alt="" data-action="zoom"></div><br><div><img src="/img/2017-04-16/taipei/DSC_0065.png" alt="" data-action="zoom"></div><br><div><img src="/img/2017-04-16/taipei/DSC_0066.png" alt="" data-action="zoom"></div><br></div><hr><div><img src="/img/2017-04-16/street-drago.jpg" alt="Street, tone map algroithm: drago, Camera: Nikon D5000" data-action="zoom"><span class="image-caption">Street, tone map algroithm: drago, Camera: Nikon D5000</span></div><div style="display: flex; align-items: center;"><br><div><img src="/img/2017-04-16/street/DSC_0099.png" alt="" data-action="zoom"></div><br><div><img src="/img/2017-04-16/street/DSC_0098.png" alt="" data-action="zoom"></div><br><div><img src="/img/2017-04-16/street/DSC_0097.png" alt="" data-action="zoom"></div><br><div><img src="/img/2017-04-16/street/DSC_0096.png" alt="" data-action="zoom"></div><br></div><div style="display: flex; align-items: center;"><br><div><img src="/img/2017-04-16/street/DSC_0095.png" alt="" data-action="zoom"></div><br><div><img src="/img/2017-04-16/street/DSC_0094.png" alt="" data-action="zoom"></div><br><div><img src="/img/2017-04-16/street/DSC_0093.png" alt="" data-action="zoom"></div><br><div><img src="/img/2017-04-16/street/DSC_0092.png" alt="" data-action="zoom"></div><br></div><hr><div><img src="/img/2017-04-16/street2-ashikhmin.jpg" alt="Street at night, tone map algroithm: ashikhmin, Camera: Nikon D5000" data-action="zoom"><span class="image-caption">Street at night, tone map algroithm: ashikhmin, Camera: Nikon D5000</span></div><div style="display: flex; align-items: center;"><br><div><img src="/img/2017-04-16/street2/DSC_0123.png" alt="" data-action="zoom"></div><br><div><img src="/img/2017-04-16/street2/DSC_0124.png" alt="" data-action="zoom"></div><br><div><img src="/img/2017-04-16/street2/DSC_0127.png" alt="" data-action="zoom"></div><br><div><img src="/img/2017-04-16/street2/DSC_0128.png" alt="" data-action="zoom"></div><br></div><div style="display: flex; align-items: center;"><br><div><img src="/img/2017-04-16/street2/DSC_0129.png" alt="" data-action="zoom"></div><br><div><img src="/img/2017-04-16/street2/DSC_0131.png" alt="" data-action="zoom"></div><br><div><img src="/img/2017-04-16/street2/DSC_0132.png" alt="" data-action="zoom"></div><br><div><img src="/img/2017-04-16/street2/DSC_0133.png" alt="" data-action="zoom"></div><br></div><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p>[1] Fast, Robust Image Registration for Compositing High Dynamic Range Photographs from Handheld Exposures, G. Ward, JGT 2003<br>[2] Recovering High Dynamic Range Radiance Maps from Photographs, Paul E. Debevec, Jitendra Malik, SIGGRAPH 1997</p><hr><h1 id="雜談"><a href="#雜談" class="headerlink" title="雜談"></a>雜談</h1><ol><li>結果說真的還是有不少人工的感覺，可能我太廢了吧…QQ</li><li>Latex 配 markdown 要注意該死的 <code>_</code>，在 Hexo 中底線會先被視為斜體字，所以在 Latex 中底線前面要用跳脫字元。</li><li>Hexo 的 markdown 真 robust! 愛怎亂搞都會跟預期中的一樣，也可以亂加 html 語法～(望向 github…</li><li>這篇文章照片真多，竟然要下載 30MB 之多，超不 friendly der~</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;高動態範圍成像（英語：High Dynamic Range Imaging，簡稱HDRI或HDR），在電腦圖形學與電影攝影術中，是用來實現比普通數點陣圖像技術更大曝光動態範圍（即更大的明暗差別）的一組技術。高動態範圍成像的目的就是要正確地表示真實世界中從太陽光直射到最暗的陰影這樣大的範圍亮度。&lt;br&gt;   – from wikipedia&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;由於一般數位相機的影像就是每個 pixel 8 bits，能夠表現的能量範圍就是這麼窄(過暴就全白，太暗就全黑)。&lt;br&gt;然而真實世界的能量範圍是非常廣的，為了能夠在 0~255 之間表現出最豐富的細節(亮部即暗部的細節)，才有所謂的 HDR 技術。&lt;br&gt;HDR Image 可以從多張不同曝光時間的照片中組合出來，而整個流程大致包含了:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;影像對齊&lt;/li&gt;
&lt;li&gt;計算出真實能量分佈&lt;/li&gt;
&lt;li&gt;把影像壓縮回低動態範圍成像(一般螢幕才能顯示)&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="opencv" scheme="https://ssarcandy.tw/tags/opencv/"/>
    
      <category term="paper" scheme="https://ssarcandy.tw/tags/paper/"/>
    
      <category term="python" scheme="https://ssarcandy.tw/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Setup x11 forwarding on Debian</title>
    <link href="https://ssarcandy.tw/2017/03/20/Setup-x11-forwarding-on-Debian/"/>
    <id>https://ssarcandy.tw/2017/03/20/Setup-x11-forwarding-on-Debian/</id>
    <published>2017-03-19T18:03:08.000Z</published>
    <updated>2020-01-29T16:42:43.264Z</updated>
    
    <content type="html"><![CDATA[<p>有時候會需要在 server 上使用有 GUI 介面的程式，像是我們會把 matlab 安裝在運算能力很好的工作站上供大家使用。但透過 ssh 連上工作站的話介面會是 terminal，使用上就會比較不便。</p><p>Linux 的 GUI 運作模式，其中</p><ul><li>X-client 負責程式的運作</li><li>X-server 負責畫面的顯示</li></ul><p>所以只要把工作站上的圖形顯示丟到本地端(windows/mac)的 X-server，就可以顯示出來了。<br>本篇將介紹如何設定才能使 Debian Server 的 GUI 程式的畫面顯示到 client 的電腦上。</p><a id="more"></a><h1 id="Debian-Server"><a href="#Debian-Server" class="headerlink" title="Debian Server"></a>Debian Server</h1><h2 id="安裝-X-server"><a href="#安裝-X-server" class="headerlink" title="安裝 X-server"></a>安裝 X-server</h2><p>如果 server 一開始就是灌沒有桌面環境的，現在就要安裝一下:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ apt-get install xserver-xorg-core</span><br></pre></td></tr></table></figure><p>也可以裝個 gvim 來測試。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ apt-get install vim-gtk</span><br></pre></td></tr></table></figure><h2 id="啟用-X11Forwarding"><a href="#啟用-X11Forwarding" class="headerlink" title="啟用 X11Forwarding"></a>啟用 <code>X11Forwarding</code></h2><p>server 這邊，必須要允許 ssh 的連線 forward 這些圖形介面的資訊到 client 端，所以需要去 <code>/etc/ssh/ssh_config</code> 中設定:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ vim /etc/ssh/ssh_config</span><br><span class="line"> </span><br><span class="line"><span class="comment"># add this line:</span></span><br><span class="line">X11Forwarding yes</span><br></pre></td></tr></table></figure><p>設定好記的重啟 sshd 服務:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ service sshd reload</span><br></pre></td></tr></table></figure><h1 id="Client-Setup"><a href="#Client-Setup" class="headerlink" title="Client Setup"></a>Client Setup</h1><p>本機端也是要有相應的設定才能正確地接收 server forward 過來的圖形介面，Mac 十分容易，而Windows 的設定比較麻煩。</p><h2 id="Mac"><a href="#Mac" class="headerlink" title="Mac"></a>Mac</h2><p>打開你的 terminal，用 ssh 連線至主機:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -X user@example.com</span><br><span class="line"> </span><br><span class="line"><span class="comment"># on remote server</span></span><br><span class="line">$ gvim <span class="comment"># open vim GUI version for testing</span></span><br></pre></td></tr></table></figure><p>不過最近 Mac 已不再內建 X11<sup>[1]</sup>，<br>所以如果你是最的 Sierra，則必須下載 <a href="https://www.xquartz.org/" target="_blank" rel="noopener">XQuartz</a>。</p><h2 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h2><p>在 windows 上需要安裝 X-server 才能使用 x11 forwarding，我推薦使用 Xming。<br>下載並安裝好以後，確認通知列有出現 Xming 的圖示。</p><p>並且要再更改 server 上的 <code>ssh_config</code> :</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ vim /etc/ssh/ssh_config</span><br><span class="line"> </span><br><span class="line"><span class="comment"># add these two lines</span></span><br><span class="line">X11DisplayOffset 10</span><br><span class="line">X11UseLocalhost yes</span><br></pre></td></tr></table></figure><p>記得重啟 <code>sshd</code> service</p><p>接下來使用 PuTTy 來連線:</p><ol><li>Session &gt; Host Name: 輸入 server ip</li><li>Connection &gt; SSH &gt; X11:<ul><li>Enable X11 forwarding → 打勾</li><li>x display location: <code>localhost:0</code></li></ul></li></ol><p>連上之後，可以試試輸入以下指令:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ echo $DISPLAY</span><br><span class="line">localhost:10.0</span><br></pre></td></tr></table></figure><p>如果看到如上的回傳，就表示一切正常。</p><p>試試 <code>gvim</code> ，就會跳出小巧可愛的視窗:</p><div><img src="/img/2017-03-20/01.PNG" alt="透過 X11-forwarding 讓 server 上的 gvim 顯示到本機(windows)" data-action="zoom"><span class="image-caption">透過 X11-forwarding 讓 server 上的 gvim 顯示到本機(windows)</span></div><hr><p>Reference:</p><p>[1] <a href="https://support.apple.com/zh-tw/HT201341" target="_blank" rel="noopener">Mac 已不再隨附 X11</a><br>[2] <a href="http://cypresslin.web.fc2.com/Memo/M-SSH.html" target="_blank" rel="noopener">SSH X11 Forwarding</a><br>[3] <a href="http://www.geo.mtu.edu/geoschem/docs/putty_install.html" target="_blank" rel="noopener">Installing/Configuring PuTTy and Xming</a><br>[4] <a href="https://www.vultr.com/docs/setup-x11-forwarding-over-ssh-on-debian-wheezy" target="_blank" rel="noopener">Setup X11 Forwarding over SSH on Debian Wheezy</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有時候會需要在 server 上使用有 GUI 介面的程式，像是我們會把 matlab 安裝在運算能力很好的工作站上供大家使用。但透過 ssh 連上工作站的話介面會是 terminal，使用上就會比較不便。&lt;/p&gt;
&lt;p&gt;Linux 的 GUI 運作模式，其中&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;X-client 負責程式的運作&lt;/li&gt;
&lt;li&gt;X-server 負責畫面的顯示&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以只要把工作站上的圖形顯示丟到本地端(windows/mac)的 X-server，就可以顯示出來了。&lt;br&gt;本篇將介紹如何設定才能使 Debian Server 的 GUI 程式的畫面顯示到 client 的電腦上。&lt;/p&gt;
    
    </summary>
    
    
      <category term="unix" scheme="https://ssarcandy.tw/tags/unix/"/>
    
      <category term="note" scheme="https://ssarcandy.tw/tags/note/"/>
    
  </entry>
  
  <entry>
    <title>防止 mail server 大量寄信的手段</title>
    <link href="https://ssarcandy.tw/2017/02/26/prevent-mail-server-sending-spam/"/>
    <id>https://ssarcandy.tw/2017/02/26/prevent-mail-server-sending-spam/</id>
    <published>2017-02-26T13:14:07.000Z</published>
    <updated>2020-01-29T16:42:43.264Z</updated>
    
    <content type="html"><![CDATA[<p>最近這幾周都一直被 cmlab 的 mail server 霸凌，覺得難過…<br>為了解決 mail server 時不時會大量寄出信件的問題，嘗試了許多方法，終於得到一點點平靜…<br>本篇整理了我們最近嘗試的方法及一些工具，做個紀錄…</p><h1 id="流量分析及監控"><a href="#流量分析及監控" class="headerlink" title="流量分析及監控"></a>流量分析及監控</h1><p>先介紹兩個好工具，</p><ul><li><code>pflogsumm</code></li><li><code>mailgraph</code></li></ul><p>方便監控以及分析 mail server 的狀況:</p><a id="more"></a><h2 id="pflogsumm"><a href="#pflogsumm" class="headerlink" title="pflogsumm"></a>pflogsumm</h2><p><code>pflogsumm</code> 是個可以把 mail.log 整理成一份比較好閱讀的報告，可以一目瞭然這時段內共收發多少信、誰寄最多信、誰收最多信等等的資訊。<br>用法也很簡單:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">$ apt-get install pflogsumm  <span class="comment"># install</span></span><br><span class="line">$ pflogsumm /var/<span class="built_in">log</span>/mail.log <span class="_">-d</span> today <span class="comment"># generate today's report</span></span><br><span class="line"> </span><br><span class="line">Postfix <span class="built_in">log</span> summaries <span class="keyword">for</span> Feb 26</span><br><span class="line"> </span><br><span class="line">Grand Totals</span><br><span class="line">------------</span><br><span class="line">messages</span><br><span class="line">      659   received</span><br><span class="line">     1047   delivered</span><br><span class="line">      135   forwarded</span><br><span class="line">        0   deferred</span><br><span class="line">        2   bounced</span><br><span class="line">     3285   rejected (75%)</span><br><span class="line">        0   reject warnings</span><br><span class="line">        0   held</span><br><span class="line">        0   discarded (0%)</span><br><span class="line">  </span><br><span class="line">    15378k  bytes received</span><br><span class="line">    20065k  bytes delivered</span><br><span class="line">      142   senders</span><br><span class="line">       88   sending hosts/domains</span><br><span class="line">      156   recipients</span><br><span class="line">       15   recipient hosts/domains</span><br></pre></td></tr></table></figure><p>這邊只列出 report 的一部份，還有很多有用的資訊，可以自己試試看。</p><h2 id="mailgraph"><a href="#mailgraph" class="headerlink" title="mailgraph"></a>mailgraph</h2><p>這是一個視覺化圖表呈現 mail server 狀態的工具，顯示整個時間軸收發了多少信之類的資訊，介面大概長這樣:</p><div><img src="/img/2017-02-26/01.png" alt="mailgrapgh 網頁統計資訊" data-action="zoom"><span class="image-caption">mailgrapgh 網頁統計資訊</span></div><p>這是以網頁來呈現的，原理就是每幾分鐘就會去整理 mail.log 中的資訊，然後產生圖表再呈現在網頁上。<br>安裝流程如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ apt-get install rrdtool mailgraph</span><br><span class="line">$ dpkg-reconfigure mailgraph</span><br></pre></td></tr></table></figure><p>然後會問你三個問題</p><ul><li>Should Mailgraph start on boot? &lt;– <strong>Yes</strong></li><li>Logfile used by mailgraph: &lt;– <code>/var/log/mail.log</code></li><li>Count incoming mail as outgoing mail? 這要看你是否有安裝一些過濾器 (amavisd 之類的)，有的話就選 <strong>NO</strong>，反之則選 <strong>YES</strong></li></ul><p>再來就是把對應檔案搬到 web server 下面</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir /var/www/mailgrapgh <span class="comment"># create a folder for mailgraph</span></span><br><span class="line">$ cp -p /usr/lib/cgi-bin/mailgraph.cgi /var/www/mailgraph </span><br><span class="line">$ cp -p /usr/lib/cgi-bin/mailgraph.css /var/www/mailgraph</span><br></pre></td></tr></table></figure><p>然後就可以連上 <code>http://yorurdomain.com/mailgraph/mailgraph.cgi</code> 查看結果。</p><h1 id="看-mail-log-揪出亂寄者"><a href="#看-mail-log-揪出亂寄者" class="headerlink" title="看 mail.log 揪出亂寄者"></a>看 mail.log 揪出亂寄者</h1><p>通常 mail server 寄信量暴增都是因為有使用者在大量寄信，無論是真人在搞鬼或是有程式在惡意寄信，都應該視情況直接封鎖他寄信的功能。</p><h2 id="找-nrcpt-過高者"><a href="#找-nrcpt-過高者" class="headerlink" title="找 nrcpt 過高者"></a>找 <code>nrcpt</code> 過高者</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cat mail.log | egrep <span class="string">'nrcpt=[1-9][0-9]'</span></span><br></pre></td></tr></table></figure><p>nrcpt 是 number of recipients 的縮寫，nrcpt 很大表示這封信要寄給很多人，合不合理還是要看情況，但至少由此下手比較能夠找到搞鬼的人。</p><h2 id="看-pflogsumm-誰寄太多信"><a href="#看-pflogsumm-誰寄太多信" class="headerlink" title="看 pflogsumm 誰寄太多信"></a>看 <code>pflogsumm</code> 誰寄太多信</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ pflogsumm /var/<span class="built_in">log</span>/mail.log <span class="_">-d</span> today</span><br><span class="line"> </span><br><span class="line">Senders by message count</span><br><span class="line">------------------------</span><br><span class="line">    1060   xxx@cmlab.csie.ntu.edu.tw</span><br><span class="line">      32   xxx@cmlab.csie.ntu.edu.tw</span><br><span class="line">      12   xxx@cmlab.csie.ntu.edu.tw</span><br><span class="line">       6   xxx@cml0.csie.ntu.edu.tw</span><br><span class="line">       2   xxx@cmlab.csie.ntu.edu.tw</span><br><span class="line">       2   xxx@ntu.edu.tw</span><br></pre></td></tr></table></figure><p>找到誰很詭異寄很多信之後，就加入 Postfix 的 sender 黑名單中限制寄信。(記得更新 .db 檔)</p><p>在 Postfix <code>main.cf</code> 中加入 <code>sender-access</code> 的黑名單:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">smtpd_sender_restrictions = </span><br><span class="line">    check_sender_access hash:/etc/postfix/sender-access,</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ vim sender-access</span><br><span class="line"> </span><br><span class="line"><span class="comment"># add this line to disable sender function</span></span><br><span class="line"><span class="comment"># xxx@cmlab.csie.ntu.edu.tw REJECT sorry, we don't provide smtp service for you.</span></span><br><span class="line"> </span><br><span class="line">$ postmap sender-access <span class="comment"># update .db file</span></span><br></pre></td></tr></table></figure><h1 id="設定內收外寄流量控制"><a href="#設定內收外寄流量控制" class="headerlink" title="設定內收外寄流量控制"></a>設定內收外寄流量控制</h1><p>有時候單靠黑名單其實有點治標不治本，因為今天鎖了 A 明天可能是 B 在大量寄信，所以若能設定每個使用者一小時允許的寄信量才可以防止這類大量寄信的事情發生。</p><p>Postfix 並沒有相關的設定可以設，必須依靠別的程式，而看起來最好的就是 Policyd 了<br>我之前已經有一篇是在講<a href="https://ssarcandy.tw/2016/12/24/policyd/">如何安裝及設定 Policyd</a> 了，可以直接參考那篇。</p><p>不過有幾點是需要注意的，我一開始設定是設定成<strong>「若超過寄信額度，則延後寄信(DEFER)」</strong>，我之所以這樣設是不想讓使用者的信沒寄出去，只是讓他晚一點寄出去。但這樣就又可能造成某人大量寄信結果因為超過額度所以全部都塞在 mail queue 中….崩潰….</p><p>所以我現在就直接設成<strong>「若超過寄信額度，則直接拒絕寄信(REJECT)」</strong>，這樣比較乾脆～</p><h1 id="設定重送間隔、生命週期"><a href="#設定重送間隔、生命週期" class="headerlink" title="設定重送間隔、生命週期"></a>設定重送間隔、生命週期</h1><p>有時候信件會寄不出去(可能是對方容量滿了、網路問題等等、或是對方伺服器黑名單我們的信)，Postfix 預設是有重送機制的，但假設信件一直重送而且又一直寄不出去那 mail queue 就會累積越來越多信，最後就會有超大寄信流量，而這時候就會被學校限制 IP 了。</p><p>Postfix 重送的相關設定預設值都相當長，像是一封信他能夠存活在 mail queue 中的時間竟然是五天，這也表示如果有一封信寄不出去的話 Postfix 會鍥而不捨的連試五天…..</p><p>以下列出 Postfix 有關於重送的設定及其預設值，想看每個的詳細說明可以看<a href="http://www.postfix.org/postconf.5.html" target="_blank" rel="noopener">官方文件</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">minimal_backoff_time (default: 300s)</span><br><span class="line">maximal_backoff_time (default: 4000s)</span><br><span class="line">queue_run_delay (default: 300s)</span><br><span class="line">maximal_queue_lifetime (default: 5d)</span><br><span class="line">bounce_queue_lifetime (default: 5d)</span><br></pre></td></tr></table></figure><p>根據我們自己 mail server 的用量，我最後將設定改為如下，這樣應該就可以避免 queue 中塞滿寄不出去的信的狀況了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">minimal_backoff_time = 10m</span><br><span class="line">maximal_backoff_time = 30m</span><br><span class="line">queue_run_delay = 10m</span><br><span class="line">bounce_queue_lifetime = 2h</span><br><span class="line">maximal_queue_lifetime = 2h</span><br></pre></td></tr></table></figure><hr><p>最近搞 mail server 真的大崩潰，連帶系上跟者我們一起崩潰 Sorry…QQ<br>果然還是盡快轉移到 G Suite 好了…..</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近這幾周都一直被 cmlab 的 mail server 霸凌，覺得難過…&lt;br&gt;為了解決 mail server 時不時會大量寄出信件的問題，嘗試了許多方法，終於得到一點點平靜…&lt;br&gt;本篇整理了我們最近嘗試的方法及一些工具，做個紀錄…&lt;/p&gt;
&lt;h1 id=&quot;流量分析及監控&quot;&gt;&lt;a href=&quot;#流量分析及監控&quot; class=&quot;headerlink&quot; title=&quot;流量分析及監控&quot;&gt;&lt;/a&gt;流量分析及監控&lt;/h1&gt;&lt;p&gt;先介紹兩個好工具，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;pflogsumm&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mailgraph&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;方便監控以及分析 mail server 的狀況:&lt;/p&gt;
    
    </summary>
    
    
      <category term="unix" scheme="https://ssarcandy.tw/tags/unix/"/>
    
      <category term="note" scheme="https://ssarcandy.tw/tags/note/"/>
    
  </entry>
  
  <entry>
    <title>From React to React Native</title>
    <link href="https://ssarcandy.tw/2017/02/02/from-react-to-react-native/"/>
    <id>https://ssarcandy.tw/2017/02/02/from-react-to-react-native/</id>
    <published>2017-02-02T03:04:00.000Z</published>
    <updated>2020-01-29T16:42:43.264Z</updated>
    
    <content type="html"><![CDATA[<p>接觸 React 其實也一段時間了，總是嚷嚷想做個自己的 Project 但始終沒有動手開始做。最近趁著寒假終於用 React 做了個<a href="https://ssarcandy.tw/colorblocks-react/">網頁小遊戲</a>，之後也改寫成 React Native 做出 Android and iOS 的原生 app，順便把 android 版上架到 <a href="https://play.google.com/store/apps/details?id=com.colorblocksrn" target="_blank" rel="noopener">Google play</a> 上～(iOS app store 費用太高付不起…)<br>算是完成幾個長久以來的小小目標(?)</p><div><img src="/img/2017-02-02/01.jpg" alt="用 React Native 做出 Android/iOS 原生 app" data-action="zoom"><span class="image-caption">用 React Native 做出 Android/iOS 原生 app</span></div><a id="more"></a><p>說真的寫好 React 版本以後要改寫成 React Native 還挺容易的，基本上要改的只有介面的部分，對應到程式碼大概就是每個 Component 中的 <code>render()</code>，當然還有 CSS 要改成 react-native 的 style，Animation 也不能用 CSS 來做了，這也是比較麻煩的地方。</p><h1 id="檔案結構"><a href="#檔案結構" class="headerlink" title="檔案結構"></a>檔案結構</h1><p>React 版跟 React Native 版的檔案結構其實幾乎都是差不多的，可以看下圖的對應：</p><div><img src="/img/2017-02-02/02.png" alt="左圖是 React 的檔案結構；右圖是 React Native 的檔案結構。" data-action="zoom"><span class="image-caption">左圖是 React 的檔案結構；右圖是 React Native 的檔案結構。</span></div><p>最大的差異是 <code>style/</code> 資料夾不見了，這是因為 React Native 的 style 我都寫在 components 檔案裡面了。React 版本的 <code>index.js</code> 是進入點。其他檔案基本上都維持一樣的結構、React 版本定義的 components 在 react-native 版中都依舊存在。</p><div><img src="/img/2017-02-02/03.png" alt="左為 React 版；右為 React Native 版，元件完全一致。" data-action="zoom"><span class="image-caption">左為 React 版；右為 React Native 版，元件完全一致。</span></div><h1 id="改寫-render"><a href="#改寫-render" class="headerlink" title="改寫 render()"></a>改寫 <code>render()</code></h1><blockquote><p>邏輯可以重用，要改的只有渲染的部分。</p></blockquote><p>我在改寫的時候，反正第一步就是把 <code>&lt;div&gt;</code> 通通改成 <code>&lt;View&gt;</code> ，把包住文字的 <code>&lt;span&gt;</code>、<code>&lt;div&gt;</code> 改成 <code>&lt;Text&gt;</code> ，這樣大概就完成一半了吧(?)<br>剩下的一半就是找找最適合的 native component ，這些可以上官方文件尋找。</p><h1 id="改寫-Style"><a href="#改寫-Style" class="headerlink" title="改寫 Style"></a>改寫 Style</h1><blockquote><p>看似像 CSS，但又沒這麼好用，比較像是閹割版的 CSS。</p></blockquote><p>React Native 的 style 是個 javascript 的物件，大概有七成可以跟 CSS 直接對應，寫法就是原本 CSS 改成 camlCase 寫，如果要寫得像 css 的 class 的話還要使用 <code>StyleSheet.create()</code> :</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// css</span></span><br><span class="line">.name &#123;</span><br><span class="line">    font-size: <span class="number">20</span>px;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// react native</span></span><br><span class="line"><span class="keyword">const</span> styles = StyleSheet.create(&#123;</span><br><span class="line">    name: &#123;</span><br><span class="line">        fontSize: <span class="number">20</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>套用樣式的寫法則是直接用 <code>style={Object}</code> ，若要套用複合樣式，則在 style 中放一個 object array(順序有差):</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">View</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Text</span> <span class="attr">style</span>=<span class="string">&#123;styles.red&#125;</span>&gt;</span>just red<span class="tag">&lt;/<span class="name">Text</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Text</span> <span class="attr">style</span>=<span class="string">&#123;[styles.red,</span> <span class="attr">styles.bigblue</span>]&#125;&gt;</span>red, then bigblue<span class="tag">&lt;/<span class="name">Text</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">View</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="Animation"><a href="#Animation" class="headerlink" title="Animation"></a>Animation</h1><p>原本 React 版的動畫全都是用 css 做出來的，但這些在 React Native 中就沒辦法用了，官方有提供 Animation 相關的 <a href="https://facebook.github.io/react-native/docs/animations.html" target="_blank" rel="noopener">API</a>，但說實在的真的有點難搞。<br>後來我是用某大神寫的 library <a href="https://github.com/oblador/react-native-animatable" target="_blank" rel="noopener">react-native-animatable</a>，比起官方提供的更好用。</p><h1 id="Divide-and-Conquer"><a href="#Divide-and-Conquer" class="headerlink" title="Divide and Conquer"></a>Divide and Conquer</h1><blockquote><p>改寫要一部份一部份改比較容易，一次要全改只會要你命！</p></blockquote><p>從 React 改成 React Native 雖然好像不用費很大的功夫，但是如果想要一次到位全部改好其實還是很困難的。<br>我這個 Project 已經是很小規模的了(約 500 多行)，但第一次想一次到位時我花了一兩個小時還是連 build 都沒辦法成功。所以果然還是一部份一部份改起來比較輕鬆。<br>以我的例子而言，是先改 <code>&lt;StatusPanel/&gt;</code> ，因為只要會倒數就好嘛，單純了自然就比較好寫；再來改 <code>&lt;ArrowKey/&gt;</code> 最後才是改 <code>&lt;QuestionList/&gt;</code> 跟 <code>&lt;Question/&gt;</code> ，這樣分批改前前後後大概只花兩個小時就全部搞定了。</p><h1 id="一些坑以及一些筆記"><a href="#一些坑以及一些筆記" class="headerlink" title="一些坑以及一些筆記"></a>一些坑以及一些筆記</h1><h4 id="進入點註冊程式就好"><a href="#進入點註冊程式就好" class="headerlink" title="進入點註冊程式就好"></a>進入點註冊程式就好</h4><p>React Native 官方 example 的主程式都是寫在 <code>index.android.js</code> (或 <code>.ios.js</code> ) 裡面，個人感覺是可以把主邏輯拆出來，進入點只負責註冊程式就好:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; AppRegistry &#125; <span class="keyword">from</span> <span class="string">'react-native'</span>;</span><br><span class="line"><span class="keyword">import</span> colorblocksRN <span class="keyword">from</span> <span class="string">'./src/app'</span>; <span class="comment">// 主程式 component</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 進入點只做 register 的動作</span></span><br><span class="line">AppRegistry.registerComponent(<span class="string">'colorblocksRN'</span>, () =&gt; colorblocksRN);</span><br></pre></td></tr></table></figure><h4 id="iOS-樣式有差"><a href="#iOS-樣式有差" class="headerlink" title="iOS 樣式有差"></a>iOS 樣式有差</h4><p>即使用一模一樣的 code，iOS 跑起來樣式跟 android 的還是有差別，這我也不知道為甚麼，反正最後記得針對 iOS 的樣式再修改修改。</p><h4 id="不能-react-native-run-ios"><a href="#不能-react-native-run-ios" class="headerlink" title="不能 react-native run-ios"></a>不能 <code>react-native run-ios</code></h4><p>假設遇到這問題，首先先檢查 port 8081 有沒有被佔用了:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ lsof -n -i4TCP:8081</span><br><span class="line">$ <span class="built_in">kill</span> &lt;pid&gt;</span><br></pre></td></tr></table></figure><p>如果問題沒排除，試試</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo react-native run-ios</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;接觸 React 其實也一段時間了，總是嚷嚷想做個自己的 Project 但始終沒有動手開始做。最近趁著寒假終於用 React 做了個&lt;a href=&quot;https://ssarcandy.tw/colorblocks-react/&quot;&gt;網頁小遊戲&lt;/a&gt;，之後也改寫成 React Native 做出 Android and iOS 的原生 app，順便把 android 版上架到 &lt;a href=&quot;https://play.google.com/store/apps/details?id=com.colorblocksrn&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Google play&lt;/a&gt; 上～(iOS app store 費用太高付不起…)&lt;br&gt;算是完成幾個長久以來的小小目標(?)&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;/img/2017-02-02/01.jpg&quot; alt=&quot;用 React Native 做出 Android/iOS 原生 app&quot; data-action=&quot;zoom&quot;&gt;&lt;/div&gt;
    
    </summary>
    
    
      <category term="react" scheme="https://ssarcandy.tw/tags/react/"/>
    
      <category term="react native" scheme="https://ssarcandy.tw/tags/react-native/"/>
    
  </entry>
  
</feed>
