{"meta":{"title":"SSARCandy","subtitle":"","description":"","author":"許書軒","url":"https://ssarcandy.tw"},"pages":[{"title":"","date":"2016-10-12T16:59:06.030Z","updated":"2016-10-12T16:59:06.030Z","comments":true,"path":"web-app-manifest.json","permalink":"https://ssarcandy.tw/web-app-manifest.json","excerpt":"","text":"{\"name\":\"ssarcandy\",\"start_url\":\"/\",\"display\":\"standalone\",\"orientation\":\"natural\"}"},{"title":"About","date":"2016-10-12T16:59:06.010Z","updated":"2016-10-12T16:59:06.010Z","comments":false,"path":"about/index.html","permalink":"https://ssarcandy.tw/about/index.html","excerpt":"","text":"drflkgtkre"},{"title":"Projects","date":"2016-10-12T16:59:06.030Z","updated":"2016-10-12T16:59:06.030Z","comments":false,"path":"projects/index.html","permalink":"https://ssarcandy.tw/projects/index.html","excerpt":"","text":""},{"title":"","date":"2016-10-12T16:59:06.030Z","updated":"2016-10-12T16:59:06.030Z","comments":false,"path":"tags/index.html","permalink":"https://ssarcandy.tw/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"改善 pbrt 中的 heightfield shape","slug":"pbrt-heightfield","date":"2016-10-10T13:14:41.000Z","updated":"2016-10-12T16:59:06.010Z","comments":true,"path":"2016/10/10/pbrt-heightfield/","link":"","permalink":"https://ssarcandy.tw/2016/10/10/pbrt-heightfield/","excerpt":"pbrt 是一個基於物理的 ray-tracing libarary，他可以拿來產生接近現實的真實場景，據說 IKEA 的型錄都是用類似方法產生的，而不是真的把產品擺出來拍照。 哈哈","text":"pbrt 是一個基於物理的 ray-tracing libarary，他可以拿來產生接近現實的真實場景，據說 IKEA 的型錄都是用類似方法產生的，而不是真的把產品擺出來拍照。 哈哈 據說 IKEA 型錄的圖都是渲染出來的[1] 關於 pbrt 與 ray-tracingRay-tracing 說穿了就是在模擬自然界光線的運作，我們之所以看的到東西，其實就是因為光線打到物體並反射到我們眼睛，這也是為甚麼在無光的地方會伸手不見五指(因為沒有任何光打到手指並反射到眼中)。至於電腦要怎麼模擬這件事，大致來說是光線從光源出發，途中遇到障礙物就要算交點，有交點就要根據材質特性反射，反射之後就是一條新的光線，就繼續做交點測試直到進到眼睛中(或直到能量遞減完畢)。可以看出，ray-tracing 最重要的大概就是與物件算交點了，因為 ray 會一直做交點測試，所以與物件的交點測試必須要夠快才行，不然就會算到天荒地老…. pbrt 除了最基本的 triangleMesh 以外，還實作很多其他一些常見的 shape(球體、圓柱體、圓形、heightfield…)，這其實是拿來給 api 使用的，一般人可以寫 pbrt 專用的描述檔來描述一個場景中的物體、光源等等，再藉由 pbrt 的程式來渲染出整張影像。 pbrt 中的各種 shape，有些是會先轉成 triangleMesh(對三角形求交點應該是圖學中最基礎的了，如果原本物件太複雜通常就會先把它拆成三角形組合再來算)；而有些是有實作對 shape 交點測試的。由於把物件轉成 triangleMesh 其實就硬是多一個步驟了啊，如果可以與 shape 直接求交點，那速度上當然會大躍進~ 實作 heightfield 交點測試Heightfield 其實就是平面但是有高低差，也就是說，對每個 $(x, y)$ 而言只會有一個 $z$ 值。算是個滿單純的shape。Heightfield 也是原本就有實作的一種 shape，是直接用 Refine() 來把形狀轉為 triangleMesh 再做交點測試的。 如果能夠跳過三角化而直接與 heightfield 做交點測試，可能可以比較快喔？參考一下別的 shape，包含球體、圓柱體等實作的交點測試的方法都是在幾何意義上直接求交點，也就是算數學求解~哈哈但 heightfield 似乎是沒辦法從幾何意義上直接解了，需要用更暴力的方法~ 這邊我是使用 DDA(digital differential analyzer) 來做交點測試，這東西其實原本是拿來畫線的演算法，因為實際上的線是連續的，但是呈現在電腦上卻必須以 pixel 為單位呈現。而這邊與 heightfield 的交點測試就是將 DDA 擴展至三維空間中(多了Z軸)。 2D-DDA 邏輯。[2] 可以看到其實可以在一開始就算出x, y要走多少會到下一個 pixel，這些都是定值，也讓遍歷整個 Pixel-Grid 變得很容易，而 3D-DDA 就只是再加入 z 軸的資訊，並且每一個 pixel 變成 voxel。3D-DDA 這樣的方式其實在 pbrt 裡面已有實作，是來作為加速結構用途，但是由於 heightfield 本身特性(對每個 $(x, y)$ 而言只會有一個 $z$ 值)，我們可以讓 Voxel 的高度等於 heightfield 的高度，如此一來就可以讓3D結構的 heightfield 套用 2D-DDA 了！耶~~~ 建好 DDA 需要的資訊後，接下來就是要實作 Ray 交點測試了，在遍歷 Voxel 的過程中，需要針對這個 Voxel 做交點測試，如果有交點就結束了；沒有就到下個 Voxel。而關於每個 Voxel 的交點測試其實也是滿單純的，在設計DDA的結構時，除了讓Voxel高等於 heightfield 高，可以變成 2D-DDA 以外，讓 Voxel 的寬等於一個單位的 x 及 y 也是有很大的好處的，如下圖: 從正上方看下來的 heightfield 樣子，數值為對應 z 值。讓 Voxel 寬度等於一格寬有好處。 依據這樣的設計，每次在做 Voxel 交點測試時，可以知道這 Voxel 中就是包含兩個三角形；也就是說分別對這兩個三角形做交點測試就好了~~ 根據這樣的算法，就可以得出與原本直接三角化的做法一模一樣的結果: 用直接求交點的方式取代原本先做三角化的方法。 平滑化看看上圖的結果，看得出都是一面一面的三角形面，這是因為同一個面上所有點都是一樣的法向量，所以反射角度也都一樣，自然就成這副德性。如果要做平滑化的話就必須內插三角形內部的點的法向量，使得三角面反射光會看起來滑順一點。 三角化後每個點 M 都有六個鄰居。 這邊我是直接平均法向量來達成這樣的效果，由於三角化之後每個點會有六個鄰居；點 M 的鄰居有 TL、T、R、BR、B、L 六點，點 M 的法向量可以藉由任意兩向量外積得出。 那我就平均一下六個法向量來當作真正的法向量，以 M 為原點，可算出平均法向量為:$\\underset{Normalize(}{ }\\underset{TL}{\\rightarrow} \\underset{\\times}{ } \\underset{L}{\\rightarrow} \\underset{+}{ } \\underset{L}{\\rightarrow} \\underset{\\times}{ } \\underset{B}{\\rightarrow} \\underset{+}{ } \\underset{B}{\\rightarrow} \\underset{\\times}{ } \\underset{BR}{\\rightarrow} \\underset{+}{ } \\underset{BR}{\\rightarrow} \\underset{\\times}{ } \\underset{R}{\\rightarrow} \\underset{+}{ } \\underset{R}{\\rightarrow} \\underset{\\times}{ } \\underset{T}{\\rightarrow} \\underset{+}{ } \\underset{T}{\\rightarrow} \\underset{\\times}{ } \\underset{TL}{\\rightarrow} \\underset{)}{ }$ 這樣子改進後，就可以讓結果變這樣: 平滑化的結果 加速很可惜的是我做完以後，速度沒有想像中的快速，反而比原本的還慢了兩倍以上….嗚嗚嗚….稍微看看別的 shape 的交點測試，其實有很多時候會先跟 Bbox(Bounding Box) 做測試，因為與 Bbox 交點是容易很多的，如果與 Bbox 無交點就也不用繼續做下去了。在 Voxel 交點測試中，也應當先與整個 Voxel 做測試，確定有交點再去試裡面的兩個三角形，這樣就可以省下很大量的做白工。 但這樣做完還是不夠好，所以我利用 CPU profiling 來測試我的程式的瓶頸到底在哪裡….利用這樣的檢測，我陸續做了幾次優化: 原因及改善方法 Intersect() 與未最佳化時比較 未最佳化。 90,274 100.0% 發現 ObjectBound() 很慢，改在 Heightfield construction 時就先存 minZ, maxZ。 82,731 91.6% 發現在算 Voxel BBox 使用的 Bbox(Union(Bbox, Bbox)) 超爆慢，改用 Bbox(Point,Point)。 53,408 59.1% 發現有不必要的坐標系轉換，由於在 Voxel 交點測試中會先測與 Voxel Bbox 交點，所以最好直接給他已轉好的 Ray(Object Space)。 46,922 51.9% 由於 Bbox(Point, Point) 建構時都要重新判斷 min max，改用先建構空的BBOX再直接給值(pmin, pmax)省去建構時間。 36,768 40.7% 把用不到的 Bbox 給 Voxel 交點測試中再利用，節省Construction Time(避免重新 relocate 記憶體位置以及建構空 Bbox 的時間)。 32,742 36.2% Intersect() 欄的數字是指CPU採樣時落在這函式的總樣本數，越多表示執行時間越長 測試的是 landsea-2.pbrt，並且使用 –ncores 1 以減少多執行緒的誤差 經過幾次最佳化後，成功壓低執行時間(單位為秒)，效能比較如下: 效能比較。[3] 雜談說真的這大概是我做過數一數二難的作業了，而且竟然只是作業一….其實寫的過程也不是我自己想到的，老師也有給提示，甚至網路上其實根本有答案….(不見得是最佳解就是了)為了這作業我甚至還上 Stack overflow 問了人生第一個問題 哈哈(雖然問題跟演算法沒關係)只能說不愧是 Stanford 的題目囉？ 註: [1]: 可以看這篇介紹 IKEA 渲染型錄 [2]: 原圖來自 Physically Based Rendering, Second Edition [3]: 執行時間用 bash 內建 time 指令來量測","categories":[],"tags":[{"name":"computer_graphic","slug":"computer-graphic","permalink":"https://ssarcandy.tw/tags/computer-graphic/"},{"name":"rendering","slug":"rendering","permalink":"https://ssarcandy.tw/tags/rendering/"},{"name":"pbrt","slug":"pbrt","permalink":"https://ssarcandy.tw/tags/pbrt/"},{"name":"c++","slug":"c","permalink":"https://ssarcandy.tw/tags/c/"}],"keywords":[]},{"title":"一些 Python 筆記","slug":"python-note","date":"2016-09-09T16:28:57.000Z","updated":"2016-10-12T16:59:06.010Z","comments":true,"path":"2016/09/09/python-note/","link":"","permalink":"https://ssarcandy.tw/2016/09/09/python-note/","excerpt":"最近的專案需要用到 OpenCV，官方有提供 C++ 以及 Python 的版本。我以前都用 C++，這次想說來換換口味使用 Python 好了，如果用的順手以後就都這樣搭配著用(Python + OpenCV)。說是這樣說，但其實我對 Python 根本一竅不通，從來沒在比較大的專案中使用過，所以新手如我自然就遇到很多坑(?)","text":"最近的專案需要用到 OpenCV，官方有提供 C++ 以及 Python 的版本。我以前都用 C++，這次想說來換換口味使用 Python 好了，如果用的順手以後就都這樣搭配著用(Python + OpenCV)。說是這樣說，但其實我對 Python 根本一竅不通，從來沒在比較大的專案中使用過，所以新手如我自然就遇到很多坑(?) 我這次專案是 Python 2.7 + OpenCV 3.1。安裝 OpenCV 一直都是很麻煩的事情，C++ 的免不了要自己 build，詳細的方法在我之前寫的另一篇有教學；而 Python 安裝 OpenCV 稍微簡單一點，把 cv2.pyd 放到 C:\\Python27\\Lib\\site-packages 就可以了 [1]。在 Mac/Linux 上更簡單，可以使用 conda [2] 來幫你安裝。 好，接下來就是用到現在所做的一些筆記～ Coding-stylePython 的 Coding-style 基本上就是參考 PEP8，簡結一下重點: 縮排用空格 一行不要超過 80 個字元，超過就換行。 除了 ClassName 以外，一律用 snake_case 為命名規則。 文件首行要加上編碼，一般 utf-8 就是加上這行 # -*- coding: utf-8 -*- DivisionPython2 的除法很特別，竟然只除到整數，意思就是 5 / 2 = 2，不過這其實就跟 C++ 一樣嘛，強制轉型一下就好: 123print(5 / 2) # 會無條件捨去小數點，印出 2print(5 / 2.0) # 2.5print(5 / float(2)) # 2.5 不過這樣好麻煩，有沒有一勞永逸的方法？有！就是用神奇的 __future__ 12# 在文件開頭處加上這行from __future__ import division future 是 Python2 很特別的東西，感覺上就是抓 Python3 的功能來用，而這邊 import division 就是使除法的行為與 Python3 一致，詳細運作原理可以參考 stackoverflow 上的說法: The internal difference is that without that import, / is mapped to the __div__() method, while with it, __truediv__() is used. Class網路上有許多宣告 Class 的教學，不過好像大部分的都不對或過時了。在 Python2 中，Class 宣告方式如下： class.py123456789101112131415class Foo(object): def __init__(self): self.bar1 = 'hello' self.bar2 = 'world' def hello_world(self): print(self.bar1 + ' ' + self.bar2) def __private_func(self): print('I am private function') foo = Foo() # new 一個新的 Foofoo.hello_world() # 不用帶任何參數foo.__private_func() # 無法呼叫，會噴 Error: AttributeError: 'Foo' object has no attribute '__private_func' 第一行的 object 是必須的。 __init__ 這個 function 也是必須的，這是 Class Constructor。 每個 function 的第一個參數必須放 self，這與 C++ Class 中的 this 相似，基本上就是拿來存取自己用的。 例如 hello_world() 中就有存取 bar1 跟 bar2，而在呼叫時 self 會被跳過。 如果要寫 private method [3]，就在 function name 前加上雙底線 __，如同上面的第 9 行處。 Path檔案路徑也是一個滿麻煩的事情，假設要讀一個檔案，一開始可能會這樣寫： 1cv2.imread('../data/foo.jpg') # cv2.imread 是 opencv 的讀圖函式 這樣當然可以讀的到，但當你換了一個工作環境，像是 Windows，這樣寫就炸了～(因為 Window 路徑是用反斜線 \\)Python 提供了個好工具 os.path.join()，簡單來說就是幫忙處理斜線。所以上面那個例子可以改寫成這樣： 12import oscv2.imread(os.path.join('..', 'data', 'foo.jpg')) 這樣的寫法就可以順利地在各平台運作～！ Function name and Variable name每個程式語言都有保留字，像是 for, while, if 之類的都是常見的保留字，而 Python 也不例外，你可以在這邊看到全部的保留字。而通常 function name 也跟保留字一樣不能當作變數名稱 [4]。特別的是 Python 允許變數名稱與 function 名稱一樣，像是： 123sum = sum([1,2,3,4,5]) # sum() is built-in function for pythonprint(sum) # 15print(sum([1,2,3,4,5])) # 15 上面的例子可以看到，Python 能夠清楚的分辨這個 sum 是指變數還是內建函式。javascript 就不行： 123btoa = btoa('hello') // btoa() is built-in function for javascriptconsole.log(btoa) // aGVsbG8=console.log(btoa('hello')) // Uncaught TypeError: btoa is not a function 可以發現在第三行就噴錯了，因為 btoa 在第一行已經被蓋掉了，後面要用 btoa() 就會以為你是指那個變數，而變數當然不是 function 囉。 The Zen of PythonPython 作者 Tim Peters 把一首詩藏在 import this 中， Beautiful is better than ugly.Explicit is better than implicit.Simple is better than complex.Complex is better than complicated.Flat is better than nested.Sparse is better than dense.Readability counts.Special cases aren’t special enough to break the rules.Although practicality beats purity.Errors should never pass silently.Unless explicitly silenced.In the face of ambiguity, refuse the temptation to guess.There should be one– and preferably only one –obvious way to do it.Although that way may not be obvious at first unless you’re Dutch.Now is better than never.Although never is often better than right now.If the implementation is hard to explain, it’s a bad idea.If the implementation is easy to explain, it may be a good idea.Namespaces are one honking great idea – let’s do more of those! 寫 Python 就是要追求乾淨、易讀、簡單，這也是我這幾周使用 Python 所感覺到的。再引用 David 老師所言， 寫 Python 就像是在寫 pseudo-code 一樣爽！ 註一： cv.pyd 可以在 build 好的 opencv 資料夾中找到。註二： OpenCV 不能用 pip 安裝，而 conda 是類似 pip 的 Python 套件管理軟體。註三： Python 是沒有 private function 的，只是在 runtime 藉由更改 function name 來達到這樣的效果，詳細可以參考這篇。註四： 函式名子不一定不能當作變數名稱，在 C/C++ 中會有 Compile-time Error，在 javascript 中是可以的，但是會覆蓋其內容。","categories":[],"tags":[{"name":"note","slug":"note","permalink":"https://ssarcandy.tw/tags/note/"},{"name":"opencv","slug":"opencv","permalink":"https://ssarcandy.tw/tags/opencv/"},{"name":"python2","slug":"python2","permalink":"https://ssarcandy.tw/tags/python2/"}],"keywords":[]},{"title":"談談 vim plugin-manager","slug":"vim-plugin-manager","date":"2016-08-17T03:02:10.000Z","updated":"2016-10-12T16:59:06.010Z","comments":true,"path":"2016/08/17/vim-plugin-manager/","link":"","permalink":"https://ssarcandy.tw/2016/08/17/vim-plugin-manager/","excerpt":"我用過了幾乎所有有名的 vim plugin-manager，包含 Pathogen, Vundle 以及比較新的 vim-plug。而以時間序來說也是 Pathogen -&gt; Vundle -&gt; vim-plug 先來談談用過這三個分別的感想好了：","text":"我用過了幾乎所有有名的 vim plugin-manager，包含 Pathogen, Vundle 以及比較新的 vim-plug。而以時間序來說也是 Pathogen -&gt; Vundle -&gt; vim-plug 先來談談用過這三個分別的感想好了： Pathogen簡單好用，與其說是 plugin-manager，個人覺得比較像是個純粹的 run-time loader，沒有什麼其他的功能。但已十分好用，要新增什麼 plugin，只需把 plugin 的資料夾放在 bundle/ 底下就完工了！刪除也是，直接砍掉 bundle/ 底下對應資料夾就OK Vundle目前應該是這三者中 github stars 最多的。plugin 安裝方式是在 .vimrc 中寫你要的 plugin name 1Plugin 'tpope/vim-fugitive' 然後在 vim 中打 :PluginInstall 就會幫你安裝。 這樣的好處是你裝過什麼一目了然，而且到新環境要重新設置的時候也很方便，直接:PluginInstall就完成了。(如果用 Pathogen 就必須自己把要用的 plugins clone 下來。) vim-plug我目前在使用的 plugin-manager ，給我的感覺就是 Vundle 的加強版。新增 plugin 的方式跟 Vundle 很像(只是關鍵字不同)，都是在 .vimrc 中寫你要的 plugin name 1Plug 'tpope/vim-fugitive' 安裝也是跟 Vundle 差不多，關鍵字不一樣而已 (:PlugInstall) 比較厲害的是 vim-plug 可以 on-demand loading！像是 vim-go(強大的 Golang Dev-plugin)，這種只有在寫 golang 時候才要的 plugin，就應該只在副檔名是.go的時候載入就好；NERDTree 也是，有時候只是打開一個檔案要編輯而已，用不著這個套件，只有當真的觸發開啟 NERDTree 的時候再載入就好。這些 vim-plug 都可以設定(設定方式詳見 readme)，大幅提升 vim 開啟速度～ 效能我從 Pathogen 換到 Vundle 是為了可以很容易的在新環境設定好 vim，而從 Vundle 換到 vim-plug 則是為了他的 on-demand loading。 所以說到底效能差多少？其實我並不是個重度 plugins 使用者，有在用的 plugins 大概 20 個吧。所以從 Vundle 換到 vim-plug 說實在並沒有顯著效能差異。不過還是可以看看別人的實驗不同 plugin-manager 的開啟速度(plug = vim-plug)。圖片出自 vim-plugins-and-startup-time 不難發現，有 on-demand loading 的 plugin-manager 開啟速度會快不少，以圖中為例大概都可以快上個 30% ！如果有興趣，也可以自己試試 vim 的開啟速度，可以用以下的方法測量。 1$ vim --startuptime vim.log 詳細開啟資訊都會寫入 vim.log ref: vim-plugins-and-startup-time vim.tw","categories":[],"tags":[{"name":"vim","slug":"vim","permalink":"https://ssarcandy.tw/tags/vim/"}],"keywords":[]},{"title":"用 Travis CI 自動部屬 hexo 到 GitHub","slug":"hexo-auto-deploy","date":"2016-07-28T16:51:43.000Z","updated":"2016-10-12T16:59:06.010Z","comments":true,"path":"2016/07/28/hexo-auto-deploy/","link":"","permalink":"https://ssarcandy.tw/2016/07/28/hexo-auto-deploy/","excerpt":"其實 hexo 作者 TC 已經有發過一篇文章在講這個主題了，也講得很清楚了，基本上矇著眼睛照做就行了。而這篇主要是再補充幾個細節。","text":"其實 hexo 作者 TC 已經有發過一篇文章在講這個主題了，也講得很清楚了，基本上矇著眼睛照做就行了。而這篇主要是再補充幾個細節。 SSH KEY 矇著眼照做那篇，到這行: 1$ travis encrypt-file ssh_key --add 這邊會幫你上傳 ssh_key 到 Travis 上，--add這個flag可以幫你插入解密指令到.travis.yml的before_install。 不過這flag真的很機車，會把你的.travis.yml排版全搞亂，順便把註解刪光光！ 建議不要加--add自己手動插入解密指令，排版就不會亂掉。 另外，如果因某種天災人禍導致忘記或沒辦法用指令插入解密指令，還是可以上 Travis 上的設定中看到環境變數名稱。 repository > more options 可以設定、看到 Travis 的環境變數 USE SSH Travis 是用 GitHub 的 Deploy key 來存取 repository 的，關於如何產生以及設定 Deploy key 都照著 TC 那篇文章做就可以了。 如果不幸在hexo deploy時遇到錯誤如下: 12remote: Invalid username or password.fatal: Authentication failed for &quot;....&quot; 那可以檢查一下 hexo 的_config.yml deploy的部分，要用 ssh 的形式設定 repository _config.yml1234deploy: type: git repo: git@github.com:SSARCandy/ssarcandy.github.io.git branch: master SETTING UP .travis.yml我這個網站結構如下: [develop] -&gt; default branch，我在這條 branch 新增文章、修改樣式等等[master] -&gt; 放 static-files，也就是 hexo generate 出來的東東 讓 Travis 自動部屬時，Clone 的是 develop branch， 經過hexo generate後推到master branch 上，為了避免 forced-update，在.travis.yml中需要再設定一下。 附上我的 .travis.yml，基本上跟 TC 那篇 87% 像啦…title: .travis.yml123456789101112131415161718192021222324252627282930313233language: node_jsnode_js: - \"4\" before_install: # Decrypt the private key - openssl aes-256-cbc -K $encrypted_d7634ff77415_key -iv $encrypted_d7634ff77415_iv -in .travis/ssh_key.enc -out ~/.ssh/id_rsa -d # Set the permission of the key - chmod 600 ~/.ssh/id_rsa # Start SSH agent - eval $(ssh-agent) # Add the private key to the system - ssh-add ~/.ssh/id_rsa # Copy SSH config - cp .travis/ssh_config ~/.ssh/config # Set Git config - git config --global user.name \"ssarcandy\" - git config --global user.email ssarcandy@gmail.com # Install Hexo - npm install hexo -g # Clone the repository - git clone https://github.com/SSARCandy/ssarcandy.github.io .deploy_git # My static-files store on master branch - cd .deploy_git &amp;&amp; git checkout master - cd .. script: - hexo generate - hexo deploy branches: only: - develop 比較需要解說的是這段1234# Clone the repository- git clone https://github.com/SSARCandy/ssarcandy.github.io .deploy_git- cd .deploy_git &amp;&amp; git checkout master- cd .. .deploy_git是 hexo 會產生的資料夾，用於紀錄 git history，不過由於每次 clone 都是全新的，所以每次.deploy_git也都會是新的，這會導致每次更新都會是 forced-update。所以，複製一份 repo (at master branch)，並改名叫.deploy_git就是為了讓新產生出的靜態檔案可以有之前的 git history，就可以避免 forced-update。","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://ssarcandy.tw/tags/hexo/"},{"name":"CI","slug":"CI","permalink":"https://ssarcandy.tw/tags/CI/"}],"keywords":[]},{"title":"自動分享每日天文圖(APOD)到 Dcard","slug":"bot-battle","date":"2016-07-26T16:16:45.000Z","updated":"2016-10-12T16:59:06.010Z","comments":true,"path":"2016/07/26/bot-battle/","link":"","permalink":"https://ssarcandy.tw/2016/07/26/bot-battle/","excerpt":"原本其實只是要做個 Slack bot，因為我懶得每天都上 APOD 官網看…乾脆做個 bot 每天都會在中午 12:30 發今日的圖跟說明到 Slack channel 裡～","text":"原本其實只是要做個 Slack bot，因為我懶得每天都上 APOD 官網看…乾脆做個 bot 每天都會在中午 12:30 發今日的圖跟說明到 Slack channel 裡～自動發文到 slack channel 裡，然後還隨機搭配內容農場風格的一句話。 不過除了我自己以外好像都沒什麼人捧場，幾乎都被無視 QQDavid老師 還表示很煩要我關掉 (明明一天才 Po 一次啊啊啊 ಠ_ಠ 所以我只好忍痛取消這個 Slack bot，改成直接用 Direct message 傳給 David老師 XD 結果 David老師 也做了個每半小時就發名言佳句給我的 bot，害我只好也把我的 bot 改成每十分鐘隨機發天文圖給他，看誰比較耐得住煩～每半小時發給我一句名言佳句，真是世界煩。 當然這種互相毀滅的 bot 大戰持續沒多久就在雙方讓步之下都停止了….. — 以上都是前言 — 即使 Slack 上都沒人要鳥我，我還是秉持著推廣基礎天文教育的偉大理念，認為優質的每日天文圖的不應該被埋沒，要讓這樣優質的內容給更多人接觸到！最後突然想到：「不然乾脆發在 Dcard 廢版好了，那邊最多人在看了而且不受版規限制」可是懶人如我是不可能每天上去 Po 文的，所以又寫了個 bot 每天中午戳 Dcard API，發優質天文圖到廢版(廢文？發廢文到廢版 結果意外反應還不錯？還有人想要我整理系列文，不愧是廢版版友，就是有眼光！大家都很捧場，覺得溫馨 ╰(〞︶〝) ╯ 不知道要過多久才會有人會發現這都是 bot 在發文 XDD –最後自己推銷一下，由於 APOD 只有 NASA 有提供官方 API，除了英文以外其他語言的子站(像是中文版)都沒辦法簡單的取得內容，所以我寫了一個 npm 套件，專門處理取得指定日期、指定語言的 APOD 內容。Github: https://github.com/SSARCandy/node-apodDemo: http://ssarcandy.tw/node-apod/demo.html","categories":[],"tags":[{"name":"trashtalk","slug":"trashtalk","permalink":"https://ssarcandy.tw/tags/trashtalk/"}],"keywords":[]},{"title":"Setting up OpenCV using Cmake GUI","slug":"Setting-up-OpenCV-using-Cmake-GUI","date":"2016-07-22T16:46:45.000Z","updated":"2016-10-12T16:59:06.010Z","comments":true,"path":"2016/07/22/Setting-up-OpenCV-using-Cmake-GUI/","link":"","permalink":"https://ssarcandy.tw/2016/07/22/Setting-up-OpenCV-using-Cmake-GUI/","excerpt":"Build OpenCV Download OpenCV and Cmake Build opencv with cmake Press configure, choose visual studio 2015, finish Then press generate","text":"Build OpenCV Download OpenCV and Cmake Build opencv with cmakeCmake configuration Press configure, choose visual studio 2015, finish Then press generate Open OpenCV.sln under build/ Build it using Debug, Release Right click > build right click &gt; build switch to Release mode and build again [Windows] Setting up environment variable add &lt;opencv&gt;/bin into PATHAdd new environment variable add new env named OpenCV_DIR, value as &lt;opencv&gt;/build it may need logout to apply setting, you can check it by echo %PATH%, echo %OpenCV_DIR% Build with EXTRA MODULES In step 2. Build opencv with cmake, press configure Set up OPENCV_EXTRA_MODULES_PATH to proper path(&lt;opencv_contrib&gt;/modules) Set OPENCV_EXTRA_MODULES_PATH as opencv_contrib/modules Press configure again, then generate To see more details instructions, see opencv_contrib README Travis.yml exampletitle: travis.yml12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061language: - cpp sudo: required compiler: - gcc # building opencv is time consuming, caching it is bettercache: apt: true ccache: true directories: - opencv-3.1.0 - opencv_contrib-3.1.0 install: # OpenCV dependencies - Details available at: http://docs.opencv.org/trunk/doc/tutorials/introduction/linux_install/linux_install.html - sudo apt-get install -y build-essential - sudo apt-get install -y cmake git libgtk2.0-dev pkg-config libavcodec-dev libavformat-dev libswscale-dev - sudo apt-get install -y python-dev python-numpy libtbb2 libtbb-dev libjpeg-dev libpng-dev libtiff-dev libjasper-dev libdc1394-22-dev # Download v3.1.0 .zip file and extract. - curl -sL https://github.com/Itseez/opencv/archive/3.1.0.zip &gt; opencv.zip - unzip -n opencv.zip &gt; log1 # Download EXTRA MODULES and extract. - curl -sL https://github.com/Itseez/opencv_contrib/archive/3.1.0.zip &gt; opencv_contrib.zip - unzip -n opencv_contrib.zip &gt; log2 # Create a new 'build' folder. - cd opencv-3.1.0 - mkdir -p build - cd build # if Makefile is cached, then skip cmake opencv # Set build instructions for Ubuntu distro. - cat Makefile &gt; l1 || cmake -D OPENCV_EXTRA_MODULES_PATH=../../opencv_contrib-3.1.0/modules CMAKE_BUILD_TYPE=RELEASE -D CMAKE_INSTALL_PREFIX=/usr/local -D WITH_TBB=ON -D BUILD_NEW_PYTHON_SUPPORT=ON -D WITH_V4L=ON -D INSTALL_C_EXAMPLES=ON -D INSTALL_PYTHON_EXAMPLES=ON -D BUILD_EXAMPLES=ON -D WITH_QT=ON -D WITH_OPENGL=ON .. # if Makefile is cached, then skip make opencv # Run 'make' with four threads. - cat Makefile &gt; l2 ||make -j5 &gt; make_log # Install to OS. - sudo make install # Add configuration to OpenCV to tell it where the library files are located on the file system (/usr/local/lib) - sudo sh -c 'echo \"/usr/local/lib\" &gt; /etc/ld.so.conf.d/opencv.conf' - sudo ldconfig - echo \"OpenCV installed.\" # We need to return to the repo \"root\" folder, so we can then 'cd' into the C++ project folder. - cd ../../ - ls -al script: - cmake CMakeLists.txt - make - \"./a.out &gt; log1.txt\"","categories":[],"tags":[{"name":"note","slug":"note","permalink":"https://ssarcandy.tw/tags/note/"},{"name":"opencv","slug":"opencv","permalink":"https://ssarcandy.tw/tags/opencv/"},{"name":"cmake","slug":"cmake","permalink":"https://ssarcandy.tw/tags/cmake/"}],"keywords":[]}]}